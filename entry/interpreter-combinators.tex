\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={The Applicative Interpreter Combinator Design Pattern},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{The Applicative Interpreter Combinator Design Pattern}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/interpreter-combinators.html}{in
Code}}.}

Recently I've been having a lot of fun with what I have been calling the
``Applicative Interpreter Combinator'' design pattern. It is heavily influenced
by ideas like
\href{http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf}{Data
types a la Carte} and
\href{http://oleg.fi/gists/posts/2018-02-21-single-free.html}{unified free
monoidal functors}, but the end goal is slightly different in spirit.

The goal is to represent Applicative (typically non-monadic) computations
(things like parsers, things to execute, things to consume or produce data) by
assembling ``self-evident'' basic primitives and subjecting them to many
\emph{different} successive transformations and combiners. The process of doing
so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forces you to make explicit decisions about the structure of your computation
  type as an ADT.
\item
  Allows you to retain isolation of fundamental parts of your domain as separate
  types
\item
  Lets you manipulate the structure of your final computation type through
  \emph{normal Haskell techniques} like pattern matching. The structure is
  available throughout the entire process, so you can replace individual
  components and values within your structure.
\item
  Allows you to fully \emph{reflect} the structure of your final computation
  through pattern matching and folds, so you can inspect the structure and
  produce useful summaries.
\end{enumerate}

Like ``data types a la carte'' and free monad/applicative/alternative designs,
these techniques allow you to separate the assembly and inspection of your
programs from the ``running'' of them. However, the main difference is that here
we focus not just on products and sums, but many different varied and
multi-purpose combinators --- a bona fide ``zoo'' of combinators. Furthermore,
our goal is not to design a functor that we can throw into \texttt{Fix} or
\texttt{Free} in the end. We might use a fixed-point or two, not as a ``big
picture'', but rather as an intermediate step. The \emph{functor itself} is the
goal, \emph{not} its fixed point.

This post will be a tour of many different combinators (taken from all over the
Haskell ecosystem --- places like
\href{https://hackage.haskell.org/package/kan-extensions}{kan-extensions},
\href{https://hackage.haskell.org/package/transformers}{transformers},
\href{https://hackage.haskell.org/package/free}{free}, and even
\href{https://hackage.haskell.org/package/base}{base}) and try to compile and
compare them in a systematic way. We'll be looking at how they act on a couple
of base primitives, and seeing the effect that each one has on our primitives.

\hypertarget{setting-the-playing-field}{%
\section{Setting the Playing Field}\label{setting-the-playing-field}}

First, let's set up our base primitive functors that we will be playing around
with and seeing how all of these primitives are affected by our combinators.

In the end, we're going to be building a \emph{command line options schema},
which we can run as a parser or summarize.

A command line options schema has two basic parts:

\begin{itemize}
\tightlist
\item
  \emph{Positional arguments} (think
  \texttt{mv\ \textless{}src\textgreater{}\ \textless{}dest\textgreater{}})
\item
  \emph{Options} (think \texttt{ls\ -\/-all})
\end{itemize}

These two will be the building blocks of our parser!

These blocks will represent \emph{schemas} for building a command line argument
parser (or otherwise). They will have kind \texttt{Type\ -\textgreater{}\ Type}
(that is, they will take one type parameter, or at least be able to be partially
applied to that point), and the type parameter represents ``what'' the schema
parses. They will \emph{usually} be \texttt{Functor} instances, for
convenience\ldots{}but not necessarily always.

\hypertarget{arg}{%
\subsection{Arg}\label{arg}}

First, a Functor to represent a schema for a positional argument:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L27-L32}

\KeywordTok{data} \DataTypeTok{Arg}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{Arg}
\NormalTok{    \{}\OtherTok{ argName  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ argHelp  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ argRead  ::} \DataTypeTok{ReadM}\NormalTok{ a}
\NormalTok{    \}}
  \KeywordTok{deriving} \DataTypeTok{Functor}
\end{Highlighting}
\end{Shaded}

A schema describing an argument that parses a value of type \texttt{a} contains
a name, a help message, and a \texttt{ReadM\ a}, which is
\emph{optparse-applicative}'s string parser data type (it contains information
on how to parse a \texttt{String} into an \texttt{a}). For the most part, we
only need to care about two \texttt{ReadM\ a}s,
\texttt{auto\ ::\ Read\ a\ =\textgreater{}\ ReadM\ a}, a \texttt{ReadM} that
works for all \texttt{Read} instances, and
\texttt{str\ ::\ IsString\ s\ =\textgreater{}\ ReadM\ a}, a \texttt{ReadM} that
works for all string-like types (like \texttt{String} and \texttt{Text}).

Let's define two simple \emph{interpreters} for this schema primitive.

An \emph{interpreter} is a \emph{natural transformation} from our \emph{schema}
to some other functor that we will ``execute'' our primitive in. A \emph{natural
transformation} between functors \texttt{F} and \texttt{G} is a function
\texttt{forall\ a.\ F\ a\ -\textgreater{}\ G\ a}, that works for \emph{all}
\texttt{a}s. An interpreter will basically \emph{interpret a schema}.

Here's a simple interpreter that executes our argument into a ``summary
aggregator'', which aggregates information into a list of summary lines:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L25-L54}

\KeywordTok{type} \DataTypeTok{Summary} \FunctionTok{=} \DataTypeTok{Const}\NormalTok{ [}\DataTypeTok{String}\NormalTok{]}

\OtherTok{argSummary ::} \DataTypeTok{Arg}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Summary}\NormalTok{ a}
\NormalTok{argSummary }\DataTypeTok{Arg}\NormalTok{\{}\FunctionTok{..}\NormalTok{\} }\FunctionTok{=} \DataTypeTok{Const}\NormalTok{ [ argName }\FunctionTok{++} \StringTok{": "} \FunctionTok{++}\NormalTok{ argHelp ]}
\end{Highlighting}
\end{Shaded}

Here we using the \texttt{-XRecordWildcards} extension to bind all of the fields
in \texttt{Arg} for us to use, for convenience.

We build an ``action'' in the \texttt{Summary} type, where we just log a single
help line. The \texttt{Summary} Applicative is a data type containing a list of
strings, where the sequencing of \texttt{Summary} actions is the appending of
those strings together. More on this later!

For example, we'll make a test \texttt{Arg} that parses a name:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L94-L99}

\OtherTok{nameArg ::} \DataTypeTok{Arg} \DataTypeTok{String}
\NormalTok{nameArg }\FunctionTok{=} \DataTypeTok{Arg}
\NormalTok{    \{ argName }\FunctionTok{=} \StringTok{"<name>"}
\NormalTok{    , argHelp }\FunctionTok{=} \StringTok{"A person's name"}
\NormalTok{    , argRead }\FunctionTok{=}\NormalTok{ str}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Let's run it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ argSummary nameArg}
\CommentTok{-- Const ["<name>: A person's name"]}
\end{Highlighting}
\end{Shaded}

Okay, that's a simple one. How about a slightly more complicated one? We can
define an interpreter into an \emph{optparse-applicative} command line argument
parser:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L48-L51}

\OtherTok{argParser ::} \DataTypeTok{Arg}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Parser}\NormalTok{ a}
\NormalTok{argParser }\DataTypeTok{Arg}\NormalTok{\{}\FunctionTok{..}\NormalTok{\} }\FunctionTok{=}\NormalTok{ argument argRead }\FunctionTok{$}
\NormalTok{        help    argHelp}
     \FunctionTok{<>}\NormalTok{ metavar argName}
\end{Highlighting}
\end{Shaded}

This how you use \emph{optparse-applicative} to describe a parser with a single
argument. When we ``run'' it, it will parse it as a single positional argument
using the \texttt{ReadM}.

To see this in action, let's create a handy tester:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L108-L111}

\OtherTok{testParser ::} \DataTypeTok{Parser}\NormalTok{ a }\OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{IO}\NormalTok{ a}
\NormalTok{testParser p }\FunctionTok{=}\NormalTok{ handleParseResult}
             \FunctionTok{.}\NormalTok{ execParserPure defaultPrefs (info (p }\FunctionTok{<**>}\NormalTok{ helper) }\FunctionTok{mempty}\NormalTok{)}
             \FunctionTok{.} \FunctionTok{words}
\end{Highlighting}
\end{Shaded}

We can now test out \texttt{nameArg}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ testParser (argParser nameArg) }\StringTok{"--help"}
\CommentTok{-- Usage: <interactive> <name>}
\CommentTok{--}
\CommentTok{-- Available options:}
\CommentTok{--   <name>                   A person's name}
\CommentTok{--   -h,--help                Show this help text}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ testParser (argParser nameArg) }\StringTok{"alice"}
\CommentTok{-- "alice"}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ testParser (argParser nameArg) }\StringTok{"bob"}
\CommentTok{-- "bob"}
\end{Highlighting}
\end{Shaded}

So if we enter a single positional argument, it gets parsed as itself.

Note that \texttt{Arg} is a \texttt{Functor}, so we can fmap a transformation on
the result:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ testParser (argParser (}\FunctionTok{map} \FunctionTok{toUpper} \FunctionTok{<$>}\NormalTok{ nameArg)) }\StringTok{"carol"}
\StringTok{"CAROL"}
\end{Highlighting}
\end{Shaded}

\hypertarget{opt}{%
\subsection{Opt}\label{opt}}

Now, let's define \texttt{Opt}, schema for non-positional
\texttt{-\/-option\ \textless{}blah\textgreater{}}s in a command line interface.

We \emph{could} define \texttt{Opt} in the same way as \texttt{Arg}, but just
for fun, and to look at more subtle aspects of schema functor design, let's make
it a little more complicated.

Namely, let's add the ability to define three \emph{types} of options: required
options, optional options, and boolean switches. Each of these have different
``result types''. A \emph{required} option produces an \texttt{a} (depending on
the \texttt{ReadM}), an \emph{optional} option produces a \texttt{Maybe\ a}
(depending on the \texttt{ReadM}), and a \emph{switch} produces a \texttt{Bool}.
Here, we use a GADT to associate the result types with the type of option, where
an \texttt{OptType\ a} is an option type that generates a value of type
\texttt{a}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L34-L39}

\KeywordTok{data} \DataTypeTok{OptType}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \CommentTok{-- ^ Contains a "name" for the argument, and a reader}
    \DataTypeTok{OTRequired}\OtherTok{ ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{ReadM}\NormalTok{ a }\OtherTok{->} \DataTypeTok{OptType}\NormalTok{ a}
    \CommentTok{-- ^ Contains a "name" for the argument, and a reader}
    \DataTypeTok{OTOptional}\OtherTok{ ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{ReadM}\NormalTok{ a }\OtherTok{->} \DataTypeTok{OptType}\NormalTok{ (}\DataTypeTok{Maybe}\NormalTok{ a)}
    \DataTypeTok{OTSwitch}\OtherTok{   ::} \DataTypeTok{OptType} \DataTypeTok{Bool}
\end{Highlighting}
\end{Shaded}

If you're unfamiliar with \texttt{GADT} syntax, it's an alternative syntax to
declaring a new data type, but instead of specifying what's ``in'' a constructor
(like \texttt{data\ Maybe\ a\ =\ Nothing\ \textbar{}\ Just\ a}), we specify the
\emph{types} of our constructors as functions (like
\texttt{data\ Maybe\ a\ where\ Nothing\ ::\ Maybe\ a;\ Just\ ::\ a\ -\textgreater{}\ Maybe\ a}).

Now notice that \texttt{OptType} has kind \texttt{Type\ -\textgreater{}\ Type},
so it is, itself, an interpreter schema. However, it's not a \texttt{Functor}
--- do you see why? You can't really \texttt{fmap\ show} an \texttt{OTSwitch},
since it would need to change its type.

So close, yet so far, right? \emph{But}, we can actually use it as if it was a
\texttt{Functor} by giving it to \texttt{Coyoneda}, the ``free functor''.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Coyoneda}
\OtherTok{    ::}\NormalTok{ (}\DataTypeTok{Type} \OtherTok{->} \DataTypeTok{Type}\NormalTok{)       }\CommentTok{-- ^ given a correctly kinded type}
    \OtherTok{->}\NormalTok{ (}\DataTypeTok{Type} \OtherTok{->} \DataTypeTok{Type}\NormalTok{)       }\CommentTok{-- ^ produce a Functor}

\KeywordTok{instance} \DataTypeTok{Functor}\NormalTok{ (}\DataTypeTok{Coyoneda}\NormalTok{ f)}
\end{Highlighting}
\end{Shaded}

We can embed an \texttt{f} into a \texttt{Coyoneda\ f} by using
\texttt{liftCoyoneda}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L56-L63}

\OtherTok{otRequired ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{ReadM}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Coyoneda} \DataTypeTok{OptType}\NormalTok{ a}
\NormalTok{otRequired n }\FunctionTok{=}\NormalTok{ liftCoyoneda }\FunctionTok{.} \DataTypeTok{OTRequired}\NormalTok{ n}

\OtherTok{otOptional ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{ReadM}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Coyoneda} \DataTypeTok{OptType}\NormalTok{ (}\DataTypeTok{Maybe}\NormalTok{ a)}
\NormalTok{otOptional n }\FunctionTok{=}\NormalTok{ liftCoyoneda }\FunctionTok{.} \DataTypeTok{OTOptional}\NormalTok{ n}

\OtherTok{otSwitch ::} \DataTypeTok{Coyoneda} \DataTypeTok{OptType} \DataTypeTok{Bool}
\NormalTok{otSwitch }\FunctionTok{=}\NormalTok{ liftCoyoneda }\DataTypeTok{OTSwitch}
\end{Highlighting}
\end{Shaded}

Now we can write our \texttt{Opt} schema, using \texttt{Coyoneda\ OptType} to
let our type be a \texttt{Functor}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L34-L39}

\KeywordTok{data} \DataTypeTok{OptType}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \CommentTok{-- ^ Contains a "name" for the argument, and a reader}
    \DataTypeTok{OTRequired}\OtherTok{ ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{ReadM}\NormalTok{ a }\OtherTok{->} \DataTypeTok{OptType}\NormalTok{ a}
    \CommentTok{-- ^ Contains a "name" for the argument, and a reader}
    \DataTypeTok{OTOptional}\OtherTok{ ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{ReadM}\NormalTok{ a }\OtherTok{->} \DataTypeTok{OptType}\NormalTok{ (}\DataTypeTok{Maybe}\NormalTok{ a)}
    \DataTypeTok{OTSwitch}\OtherTok{   ::} \DataTypeTok{OptType} \DataTypeTok{Bool}
\end{Highlighting}
\end{Shaded}

Here's a sample \texttt{Opt} getting a person's age, to demonstrate how things
fit together.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L101-L106}

\OtherTok{ageOpt ::} \DataTypeTok{Opt} \DataTypeTok{Int}
\NormalTok{ageOpt }\FunctionTok{=} \DataTypeTok{Opt}
\NormalTok{    \{ optFlag }\FunctionTok{=} \StringTok{"age"}
\NormalTok{    , optHelp }\FunctionTok{=} \StringTok{"A person's age"}
\NormalTok{    , optType }\FunctionTok{=}\NormalTok{ otRequired }\StringTok{"<int>"}\NormalTok{ auto}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Interpreting \texttt{Coyoneda} is a two-step process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  First, use \texttt{hoistCoyoneda} to \emph{interpret} the schema inside, to
  our target action type
\item
  Then, use
  \texttt{lowerCoyoneda\ ::\ Functor\ f\ =\textgreater{}\ Coyoneda\ f\ a\ -\textgreater{}\ f\ a}
  to \emph{extract} our target action.
\end{enumerate}

This pattern (``interpret within the combinator, then extract from the
combinator'') is a common one we will be using to interface with \emph{all} of
our combinators.

Interpreting into \texttt{Summary}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L65-L75}

\OtherTok{optSummary ::} \KeywordTok{forall}\NormalTok{ a}\FunctionTok{.} \DataTypeTok{Opt}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Summary}\NormalTok{ a}
\NormalTok{optSummary }\DataTypeTok{Opt}\NormalTok{\{}\FunctionTok{..}\NormalTok{\} }\FunctionTok{=}\NormalTok{ lowerCoyoneda }\FunctionTok{$}\NormalTok{ hoistCoyoneda go optType}
  \KeywordTok{where}
\OtherTok{    go ::} \DataTypeTok{OptType}\NormalTok{ x }\OtherTok{->} \DataTypeTok{Summary}\NormalTok{ x}
\NormalTok{    go }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
      \DataTypeTok{OTRequired}\NormalTok{ n _ }\OtherTok{->} \DataTypeTok{Const}
\NormalTok{        [ }\StringTok{"--"} \FunctionTok{++}\NormalTok{ optFlag }\FunctionTok{++} \StringTok{" "} \FunctionTok{++}\NormalTok{ n }\FunctionTok{++} \StringTok{": "} \FunctionTok{++}\NormalTok{ optHelp ]}
      \DataTypeTok{OTOptional}\NormalTok{ n _ }\OtherTok{->} \DataTypeTok{Const}
\NormalTok{        [ }\StringTok{"[--"} \FunctionTok{++}\NormalTok{ optFlag }\FunctionTok{++} \StringTok{" "} \FunctionTok{++}\NormalTok{ n }\FunctionTok{++} \StringTok{"]: "} \FunctionTok{++}\NormalTok{ optHelp ]}
      \DataTypeTok{OTSwitch} \OtherTok{->} \DataTypeTok{Const}
\NormalTok{        [ }\StringTok{"[--"} \FunctionTok{++}\NormalTok{ optFlag }\FunctionTok{++} \StringTok{"]: "} \FunctionTok{++}\NormalTok{ optHelp ]}
\end{Highlighting}
\end{Shaded}

Here we \emph{interpret} our \texttt{Coyoneda\ OptType\ a} into a
\texttt{Summary\ a} using \texttt{go}.
\texttt{hoistCoyoneda\ go\ optType\ ::\ Coyoneda\ Summary\ a}, and
\texttt{lowerCoyoneda\ ::\ Coyoneda\ Summary\ a\ -\textgreater{}\ Summary\ a}
\emph{extracts} it.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ optSummary ageOpt}
\CommentTok{-- Const ["--age <int>: A person's age"]}
\end{Highlighting}
\end{Shaded}

Next, into \texttt{Parser}, using \emph{optparse-applicative}. Again, interpret
then extract:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L77-L92}

\OtherTok{optParser ::} \DataTypeTok{Opt}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Parser}\NormalTok{ a}
\NormalTok{optParser }\DataTypeTok{Opt}\NormalTok{\{}\FunctionTok{..}\NormalTok{\} }\FunctionTok{=}\NormalTok{ lowerCoyoneda }\FunctionTok{$}\NormalTok{ hoistCoyoneda go optType}
  \KeywordTok{where}
\OtherTok{    go ::} \DataTypeTok{OptType}\NormalTok{ x }\OtherTok{->} \DataTypeTok{Parser}\NormalTok{ x}
\NormalTok{    go }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
      \DataTypeTok{OTRequired}\NormalTok{ n r }\OtherTok{->}\NormalTok{ option r }\FunctionTok{$}
\NormalTok{           long optFlag}
        \FunctionTok{<>}\NormalTok{ help optHelp}
        \FunctionTok{<>}\NormalTok{ metavar n}
      \DataTypeTok{OTOptional}\NormalTok{ n r }\OtherTok{->}\NormalTok{ optional }\FunctionTok{$}\NormalTok{ option r }\FunctionTok{$}
\NormalTok{           long optFlag}
        \FunctionTok{<>}\NormalTok{ help optHelp}
        \FunctionTok{<>}\NormalTok{ metavar n}
      \DataTypeTok{OTSwitch}       \OtherTok{->}\NormalTok{ switch }\FunctionTok{$}
\NormalTok{           long optFlag}
        \FunctionTok{<>}\NormalTok{ help optHelp}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ testParser (optParser ageOpt) }\StringTok{"--help"}
\CommentTok{-- Usage: <interactive> --age <int>}
\CommentTok{--}
\CommentTok{-- Available options:}
\CommentTok{--   --age <int>              A person's age}
\CommentTok{--   -h,--help                Show this help text}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ testParser (optParser ageOpt) }\StringTok{"--age 25"}
\CommentTok{-- 25}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ testParser (optParser ((}\FunctionTok{*}\DecValTok{2}\NormalTok{) }\FunctionTok{<$>}\NormalTok{ ageOpt)) }\StringTok{"--age 25"}
\CommentTok{-- 25}
\end{Highlighting}
\end{Shaded}

Now that we laid out our basic schemas, let's now think about how we might want
to \emph{combine} them into richer schemas. How about:

\begin{itemize}
\tightlist
\item
  A schema that can have multiple \texttt{Arg}s
\item
  A schema that can have multiple \texttt{Opt}s
\item
  A schema that can have a single \texttt{Arg}, and multiple \texttt{Opt}s (or
  vice versa)
\item
  A schema that has different \texttt{Opt}s and \texttt{Arg}s according to
  different subcommands
\item
  A schema that specifies an \texttt{Arg} or an \texttt{Opt}, but not both.
\item
  A schema that specifies both an \texttt{Arg} and an \texttt{Opt}, but where
  the interpreting function has the option to pick which one
\item
  A schema that specifies both an \texttt{Arg} and an \texttt{Opt}, but where
  the interpreting function \emph{must} present both to the user.
\end{itemize}

Think about all of the interesting schemas you could build using a combination
of \texttt{Arg} and \texttt{Opt}. Now, let's see what tools we have at our
disposal!

\hypertarget{sums}{%
\section{Sums}\label{sums}}

\hypertarget{products}{%
\section{Products}\label{products}}

\hypertarget{convolutions}{%
\section{Convolutions}\label{convolutions}}

\hypertarget{compositions}{%
\section{Compositions}\label{compositions}}

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
