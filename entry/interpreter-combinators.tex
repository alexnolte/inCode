\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={The Applicative Interpreter Combinator Design Pattern},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{The Applicative Interpreter Combinator Design Pattern}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/interpreter-combinators.html}{in
Code}}.}

Recently I've been having a lot of fun with what I have been calling the
``Applicative Interpreter Combinator'' design pattern. It is heavily influenced
by ideas like
\href{http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf}{Data
types a la Carte} and
\href{http://oleg.fi/gists/posts/2018-02-21-single-free.html}{unified free
monoidal functors}, but the end goal is slightly different in spirit.

The goal is to represent Applicative (typically non-monadic) computations
(things like parsers, things to execute, things to consume or produce data) by
assembling ``self-evident'' basic primitives and subjecting them to many
\emph{different} successive transformations and combiners. The process of doing
so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forces you to make explicit decisions about the structure of your computation
  type as an ADT.
\item
  Allows you to retain isolation of fundamental parts of your domain as separate
  types
\item
  Lets you manipulate the structure of your final computation type through
  \emph{normal Haskell techniques} like pattern matching. The structure is
  available throughout the entire process, so you can replace individual
  components and values within your structure.
\item
  Allows you to fully \emph{reflect} the structure of your final computation
  through pattern matching and folds, so you can inspect the structure and
  produce useful summaries.
\end{enumerate}

Like ``data types a la carte'' and free monad/applicative/alternative designs,
these techniques allow you to separate the assembly and inspection of your
programs from the ``running'' of them. However, the main difference is that here
we focus not just on products and sums, but many different varied and
multi-purpose combinators --- a bona fide ``zoo'' of combinators. Furthermore,
our goal is not to design a functor that we can throw into \texttt{Fix} or
\texttt{Free} in the end. We might use a fixed-point or two, not as a ``big
picture'', but rather as an intermediate step. The \emph{functor itself} is the
goal, \emph{not} its fixed point.

This post will be a tour of many different combinators (taken from all over the
Haskell ecosystem --- places like
\href{https://hackage.haskell.org/package/kan-extensions}{kan-extensions},
\href{https://hackage.haskell.org/package/transformers}{transformers},
\href{https://hackage.haskell.org/package/free}{free}, and even
\href{https://hackage.haskell.org/package/base}{base}) and try to compile and
compare them in a systematic way. We'll be looking at how they act on a couple
of base primitives, and seeing the effect that each one has on our primitives.

\hypertarget{setting-the-playing-field}{%
\section{Setting the Playing Field}\label{setting-the-playing-field}}

First, let's set up our base primitive functors that we will be playing around
with and seeing how all of these primitives are affected by our combinators.

In the end, we're going to be building a \emph{command line options schema},
which we can run as a parser or summarize.

A command line options schema has two basic parts:

\begin{itemize}
\tightlist
\item
  \emph{Positional arguments} (think
  \texttt{mv\ \textless{}src\textgreater{}\ \textless{}dest\textgreater{}})
\item
  \emph{Options} (think \texttt{ls\ -\/-all})
\end{itemize}

These two will be the building blocks of our parser!

First, a Functor to represent a schema for a positional argument:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L26-L31}

\KeywordTok{data} \DataTypeTok{Arg}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{Arg}
\NormalTok{    \{}\OtherTok{ argName  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ argHelp  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ argRead  ::} \DataTypeTok{ReadM}\NormalTok{ a}
\NormalTok{    \}}
  \KeywordTok{deriving} \DataTypeTok{Functor}
\end{Highlighting}
\end{Shaded}

A schema describing an argument that parses a value of type \texttt{a} contains
a name, a help message, and a \texttt{ReadM\ a}, which is
\emph{optparse-applicative}'s string parser data type (it contains information
on how to parse a \texttt{String} into an \texttt{a}). For the most part, we
only need to care about two \texttt{ReadM\ a}s,
\texttt{auto\ ::\ Read\ a\ =\textgreater{}\ ReadM\ a}, a \texttt{ReadM} that
works for all \texttt{Read} instances, and
\texttt{str\ ::\ IsString\ s\ =\textgreater{}\ ReadM\ a}, a \texttt{ReadM} that
works for all string-like types (like \texttt{String} and \texttt{Text}).

Let's define a simple interpreter for this primitive, creating an
\emph{optparse-applicative} parser:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L47-L50}

\OtherTok{argParser ::} \DataTypeTok{Arg}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Parser}\NormalTok{ a}
\NormalTok{argParser }\DataTypeTok{Arg}\NormalTok{\{}\FunctionTok{..}\NormalTok{\} }\FunctionTok{=}\NormalTok{ argument argRead }\FunctionTok{$}
\NormalTok{        help    argHelp}
     \FunctionTok{<>}\NormalTok{ metavar argName}
\end{Highlighting}
\end{Shaded}

Here we using the \texttt{-XRecordWildcards} extension to bind all of the fields
in \texttt{Arg} for us to use, for convenience. This is just
\emph{optparse-applicative}'s method of describing parser with a single
argument, and when we ``run'' it, it will parse it as a single positional
argument using the \texttt{ReadM}.

For example, we'll make a test \texttt{Arg} that parses a name:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L71-L76}

\OtherTok{nameArg ::} \DataTypeTok{Arg} \DataTypeTok{String}
\NormalTok{nameArg }\FunctionTok{=} \DataTypeTok{Arg}
\NormalTok{    \{ argName }\FunctionTok{=} \StringTok{"<name>"}
\NormalTok{    , argHelp }\FunctionTok{=} \StringTok{"A person's name"}
\NormalTok{    , argRead }\FunctionTok{=}\NormalTok{ str}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

And we'll create handy tester:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/applicative-interp.hs#L78-L81}

\OtherTok{testParser ::} \DataTypeTok{Parser}\NormalTok{ a }\OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{IO}\NormalTok{ a}
\NormalTok{testParser p }\FunctionTok{=}\NormalTok{ handleParseResult}
             \FunctionTok{.}\NormalTok{ execParserPure defaultPrefs (info (p }\FunctionTok{<**>}\NormalTok{ helper) }\FunctionTok{mempty}\NormalTok{)}
             \FunctionTok{.} \FunctionTok{words}
\end{Highlighting}
\end{Shaded}

We can now test it out:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ testParser (argParser nameArg) }\StringTok{"--help"}
\CommentTok{-- Usage: <interactive> <name>}
\CommentTok{--}
\CommentTok{-- Available options:}
\CommentTok{--   <name>                   A person's name}
\CommentTok{--   -h,--help                Show this help text}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ testParser (argParser nameArg) }\StringTok{"alice"}
\CommentTok{-- "alice"}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ testParser (argParser nameArg) }\StringTok{"bob"}
\CommentTok{-- "bob"}
\end{Highlighting}
\end{Shaded}

So if we enter a single positional argument, it gets parsed as itself.

Note that \texttt{Arg} is a \texttt{Functor}, so we can fmap a transformation on
the result:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ testParser (argParser (}\FunctionTok{map} \FunctionTok{toUpper} \FunctionTok{<$>}\NormalTok{ nameArg)) }\StringTok{"carol"}
\StringTok{"CAROL"}
\end{Highlighting}
\end{Shaded}

\hypertarget{sums}{%
\section{Sums}\label{sums}}

\hypertarget{products}{%
\section{Products}\label{products}}

\hypertarget{convolutions}{%
\section{Convolutions}\label{convolutions}}

\hypertarget{compositions}{%
\section{Compositions}\label{compositions}}

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
