\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={dhall-typed: Exploring an implementation of a typed lambda calculus},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{dhall-typed: Exploring an implementation of a typed lambda calculus}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/exploring-typed-lambda-calculus.html}{in
Code}}.}

I've been wrapped up on a side-project for a while that has been an interesting
deep dive into the limits of type-level Haskell. I've been stuck many times, but
I've often come back later with new ideas to go around certain problems. Now at
another stuck point, I just wanted to take some time to put my thoughts out into
a blog post for those interested to see what it feels like to be down in these
miry pits, and also for those more skilled than me to be able to maybe help :)

Keep in mind that the struggles contained in this post are:

\begin{itemize}
\tightlist
\item
  Not representative of most day-to-day practical type-level Haskell, a la
  \emph{servant} and other type-level user-friendly libraries.
\item
  More likely than not to be very trivial in a language with actual dependent
  types, like Idris.
\end{itemize}

\hypertarget{the-motivation}{%
\section{The motivation}\label{the-motivation}}

Here I summarize the motivation behind this project. Feel free to skip!

One of my favorite Haskell projects in the past year or so has been
\href{https://dhall-lang.org/}{dhall}, a typed and functional turing-incomplete
strongly normalizing configuration language. I honestly believe that dhall is
the solution to many of the problems of configuration languages (w.r.t json,
yaml, xml) in modern software development, and I hope to see it gain widespread
adoption some day as a ``killer app'' of functional turing-incomplete
programming.

One day I came across a post on the Haskell subreddit asking if there was a nice
way to allow user scripts within a Haskell application, and I suggested maybe to
allow users to provide scripts as dhall programs that are interpreted by Haskell
applications. This idea interested me; I tried out a proof-of-concept with
monoidal actions, and it wasn't too bad. But to allow for more expressive
scripts, I tried implementing a framework with \emph{monadic} actions. I tried
implementing a general framework using church-encoded free monads, and (aside
from the lack of type inference) it wasn't altogether too awful.

However, writing the Haskell code to \emph{import} these monadic actions into
Haskell wasn't very fun. The only way I knew how was basically to interpret an
untyped Dhall AST (parsed into Haskell) into something you could run within
Haskell.

Interpreting an untyped Dhall AST within Haskell is as much fun as you'd think
it would be (that is, not very). It's essentially the same thing as writing a
\texttt{FromJSON} instance --- something you want to avoid doing by hand
whenever possible.

This is where I got the idea: instead of interpreting an untyped Dhall
AST\ldots{}why don't we interpret a \emph{typed} Dhall AST? That is, an AST
where the \emph{type} of the Dhall expression is directly a part of the type of
the AST value. In my mind, a \texttt{DTerm\ a} would be a dhall term that
represents something of type \texttt{a}. From there, you can then convert any
typed Dhall AST term into a Haskell value representing a type you can know
statically.

Instead of parsing a \texttt{Expr} into your ADT in a way that might fail
(because of a bad \texttt{Expr}), you can parse an \emph{explicitly typed}
\texttt{Expr} into your ADT, in a way that you ensure all of the fields exist,
etc., in a \emph{total} way.

And, in the context of dhall scripting, you could actually just explicitly
``run'' the typed ADT directly within Haskell to produce something of an
expected type (like a free monad instantiation).

So, that was the dream. How hard could it be?

\hypertarget{dhall-calculus}{%
\section{Dhall Calculus}\label{dhall-calculus}}

The first step in my journey was to understand the formal system that Dhall is
based on. According to the documentation, dhall has roots in
\href{https://en.wikipedia.org/wiki/System_F\#System_F.CF.89}{System Fω}.

After doing some heavy digging and reading, this is what I gathered:

\hypertarget{the-hierarchy}{%
\subsection{The Hierarchy}\label{the-hierarchy}}

We have a hierarchy of values and their meta-level ``types''. At the bottom, we
have terms (\texttt{1}, \texttt{True}, \texttt{"hello"}, etc.). You can write
functions, applications, etc. with terms. To help us reason with terms, all
terms are categorized into \emph{types} (\texttt{Bool}, \texttt{Natural}, etc.).

However, types are also their own level of values, in that we can have
type-level functions and things like that. In order to allow us to reason with
these type-level constructs, we categories types into \emph{kinds}
(\texttt{Type}, \texttt{Type\ -\textgreater{}\ Type}), and say that the kind of
types that can categorize values is \texttt{Type}.

In Dhall, kinds are also their own level of values. We can have kind-level
functions and function application, and all of those complex structures. To help
us reason with kinds, we categorize kinds into \emph{sorts} (\texttt{Kind},
\texttt{Kind\ -\textgreater{}\ Kind}, etc.), and say that the sort of kinds that
can categorize types is \texttt{Kind}.

In Dhall, the level of sorts is where things essentially end. While Dhall sorts
are also their own level of values in a sense, there is a limitation: we cannot
make \emph{sort functions}, and we cannot have \emph{sort variables}. They are
(perhaps superficially) forbidden in Dhall. This effectively stops the
hierarchy, because there is no need to consider the meta-level ``type'' of a
sort. By forbidding sort variables and sort functions and similar abstractions,
we basically make ``order'' (the ``type'' of a sort) a meaningless construct. We
make \texttt{Sort} the ``order'' of sorts that can categorize kinds, but this
fundamental limitation means that \texttt{Sort} is the only order that exists.

\hypertarget{within-a-level}{%
\subsection{Within a Level}\label{within-a-level}}

Alright, so we've established \emph{why} the hierarchy exists, what gives rise
to them, and the mechanism that essentially cuts it off at \emph{sort}.

So, what actually \emph{lives} at each of these levels? What sort of structures
do we allow that exist completely \emph{within} a level (discounting things that
span multiple levels)?

\hypertarget{primitives}{%
\subsubsection{Primitives}\label{primitives}}

At each level exists the primitives of that level that are provided by the
language. Think of these as the ``built-in terms'', ``built-in types'',
``built-in kinds'', etc. Without primitives, we'd just be manipulating lambdas
all day (which is, incidentally, what
\href{http://hackage.haskell.org/package/morte}{morte} is. In a way, Dhall can
be thought of as just a fork of morte that adds primitives).

At the \emph{term} level, we have primitives like:

\begin{verbatim}
1
"hello"
-8
List/fold
Natural/even
\end{verbatim}

And also more complex primitive ``constructors'', that combine sub-terms

\begin{verbatim}
x + y                       -- operators in Dhall
[x,y,z]                     -- list literals in Dhall
{ foo = x, bar = y }        -- record literals in Dhall
x ∧ y                       -- record merging in Dhall
< Left = x | Right : y >    -- union literals in Dhall; x is a term, y is a type
\end{verbatim}

At the \emph{type} level, we have primitives like:

\begin{verbatim}
Bool
Text
List
\end{verbatim}

And primitive ``constructors:''

\begin{verbatim}
{ foo : x, bar : y }       -- record types in Dhall; x and y are types of kind Type
x ⩓ y                      -- merging record types in Dhall
{ foo = x, bar = y }       -- type-level record literals in Dhall; x and y are types
< Left : x | Right : y >   -- union types in Dhall; x and y are types of kind Type
< Left = x | Right : y >   -- type-level union literals in Dhall; x is a type, y is a kind
\end{verbatim}

At the \emph{kind} level, we only have the kinds of type-level records and
unions and also kind-level records and unions (and the operations on them) as
primitives. At the \emph{sort} level, we only have the sorts of kind-level
records and unions, and also sort-level records and unions (and operations on
them).

\hypertarget{function-abstraction}{%
\subsubsection{Function abstraction}\label{function-abstraction}}

At all levels (except for \emph{sort}), we have the \emph{function abstraction},
that looks like:

\begin{verbatim}
\(x : blah) -> thing
\end{verbatim}

Here are examples at the term, type, and kind levels:

\begin{verbatim}
-- Term-level
\(x : Natural) -> x + 2
-- Type-level
\(x : Type) -> List x
-- Kind-level
\(x : Kind -> Kind) -> x Type
\end{verbatim}

Disallowing sort-level function abstractions is a mechanism of artificially
``cutting off'' the effective hierarchy at sort. In theory, we could go on
forever; but what ever level we disallow lambdas at is the level that our
hierarchy stops at.

An important point here is that these are all lambdas ``within'' a single level.
The \emph{input} and the \emph{output} are all within the same level: term to
term, type to type, kind to kind, etc.

As a consequence of ``having function abstractions'', we also gain a couple of
other constructs:

\begin{itemize}
\item
  \textbf{Variables}: At all levels with function abstractions, we can talk
  about \emph{variables} at that level. A variable is \emph{bound} if it's
  inside the body of a lambda that introduces it, and is \emph{free} otherwise.
\item
  \textbf{Function Application}: At all levels with function abstractions, we
  also have \emph{function applications}, which is the application of a function
  abstraction to a value:

\begin{verbatim}
-- Term level
(\(x : Natural) -> x + 2) 4
-- Type level
(\(x : Type) -> List x) Bool
\end{verbatim}

  \emph{Technically}, we can actually have function application on levels
  without function applications, of that level has the apropriate primitives
  (like \texttt{List} on the type level, \texttt{Natural/show} at the value
  level). However, in Dhall, this doesn't happen, so we're going to address this
  as essentially paired with function abstraction.
\end{itemize}

\hypertarget{type-levels}{%
\subsubsection{Type levels}\label{type-levels}}

If a level is a ``type'' of another (type, kind, sort), they also have a
\emph{function type} construct, which is the \emph{type} of lambda abstractions
on the level below.

For example, a term-level lambda abstraction of type
\texttt{\textbackslash{}(x\ :\ Natural)\ -\textgreater{}\ x\ +\ 2} has the type
\texttt{Natural\ -\textgreater{}\ Natural}, which lives on the type level.
Again, this is specifically for functions on the ``same level''.

This construct might also classify primitives on the level above. For example,
the \texttt{Natural/isEven} primitive in Dhall has type
\texttt{Natural\ -\textgreater{}\ Bool}.

\hypertarget{type-of-type-levels}{%
\subsubsection{Type-of-type levels}\label{type-of-type-levels}}

If a level is the ``type'' of a level that is a ``type'' of another type, it
must also have a ``constant'' to tie the levels below together. That is, there
is a kind \texttt{Type}, that is the kind of all types that categorize terms. We
also have the sort \texttt{Kind}, that is the sort of all kinds that categorize
types.

\hypertarget{recap}{%
\subsubsection{Recap}\label{recap}}

That's a lot of constructs, and a lot of conditions. So just to recap, here's a
list of all constructors on each of the levels that we have gone over so far:

\begin{description}
\tightlist
\item[Term]
Primitives

Function abstraction

Function application
\item[Type]
Primitives

Function abstraction

Function application

Function type
\item[Kind]
Primitives

Function abstraction

Function application

Function type

Constant (\texttt{Type})
\item[Sort]
Primitives

Function type

Constant (\texttt{Kind})
\end{description}

All of these constructs are things that are ``within the same level''.

\hypertarget{inter-level}{%
\subsection{Inter-Level}\label{inter-level}}

Finally, we have three inter-level constructs: \emph{type abstraction},
\emph{type application}, and \emph{type abstraction type}. I like to call them
\emph{polymorphism}, \emph{instantiation}, and \emph{forall}, as they are
realized in Haskell.

\textbf{Type abstraction} (polymorphism) lets us parameterize a value based on
something of a type above. A common example is the identity function in Haskell,
which has type \texttt{forall\ a.\ a\ -\textgreater{}\ a}. In Haskell, type
abstractions are always implicit; we don't ever explicitly write them out, and
instead the Haskell compiler implicitly creates it for us with no syntactic
overhead. In Dhall, type abstractions are always explicit: the polymorphic
identity function is written as
\texttt{\textbackslash{}(a\ :\ Type)\ -\textgreater{}\ \textbackslash{}(x\ :\ a)\ -\textgreater{}\ x}.

In Dhall, there are three type abstractions allowed:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Terms parameterized on types (polymorphic terms)
\item
  Terms parameterized on kinds (kind-polymorphic terms)
\item
  Types parameterized on kinds (kind-polymorphic types)
\end{enumerate}

I believe this is a fundamental limit of disallowing sort variables. If we
allowed sort-variables, then we'd also have terms parameterized on sorts, types
parameterized on sorts, and kinds parameterized on sorts, adding three new type
abstractions.

\textbf{Type application} (instantiation) lets us \emph{apply} a type
abstraction to some input of the appropriate level, or to ``instantiate a type
variable'', in Haskell-speak.

Finally, the \textbf{type abstraction type} is the meta-level ``type* of a type
abstraction, just like how a function type is the''type" of a function
abstraction. Again, there are three in Dhall:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The type of terms parameterized on types
\item
  The type of terms parameterized on kinds
\item
  The kind of types parameterized on kinds
\end{enumerate}

Note that although these are the types of type abstractions, \emph{primitives}
can also have these types. For example, the \texttt{None} term primitive in
Dhall has type \texttt{forall\ (a\ :\ Type).\ Optional\ a}. Its type is \#1 on
the list above: \texttt{None} is a term parameterized on a type, and its type is
the type of terms parameterized on types.

\hypertarget{final-summary}{%
\subsection{Final Summary}\label{final-summary}}

To summarize, here's all of the constructs in Dhall:

\begin{description}
\tightlist
\item[Term]
Primitives

Function abstraction

Function application

Type abstraction (parameterized on types)

Type application (parameterized on types)

Type abstraction (parameterized on kinds)

Type application (parameterized on kinds)
\item[Type]
Primitives

Function abstraction

Function application

Type abstraction (parameterized on kinds)

Type application (parameterized on kinds)

Function type

Type abstraction type (terms parameterized on types)

Type abstraction type (terms parameterized on kinds)
\item[Kind]
Primitives

Function abstraction

Function application

Function type

Type abstraction type (types parameterized on kinds)

Constant (\texttt{Type})
\item[Sort]
Primitives

Function type

Constant (\texttt{Kind})
\end{description}

Note that Dhall also has \texttt{let\ ..\ in\ ..} constructs, for mostly quality
of life purposes. They don't really affect the semantics, but we can essentially
treat them like function abstractions or type applications that are immediately
applied. So, \texttt{let\ x\ =\ Natural\ in\ blah} is
\texttt{(\textbackslash{}(x\ :\ Type)\ -\textgreater{}\ blah)\ Natural}.
However, this does restrict us to only have \texttt{let\ ..\ in\ ..}s that
correspond to an appropriate function or type abstraction --- so we can't, say,
do \texttt{let\ x\ =\ 1\ in\ Kind}, since there is no abstraction that takes a
term and returns a sort.

\hypertarget{normalization-and-typing-rules}{%
\subsection{Normalization and Typing
Rules}\label{normalization-and-typing-rules}}

Of course, listing these constructs is one story. Getting the type of them (and
the type of their components) is a different one. For example, we know that
applying a function of type \texttt{Natural\ -\textgreater{}\ Bool} to a term of
type \texttt{Natural} gives us a term of type \texttt{Bool}. However, we'll
gloss over this for now as we continue on this high-level overview.

\hypertarget{how-does-dhall-do-it}{%
\subsection{How does Dhall do it?}\label{how-does-dhall-do-it}}

In the typical Haskell way, the system is implemented as an ADT, where each
construct is (surprise) a constructor.

However, the untyped Dhall AST squishes all of the distinction between all of
the levels. Half of my journey was actually in re-separating each of these
levels!

The untyped Dhall AST has the following constructors:

\begin{itemize}
\tightlist
\item
  A constructor for each primitive (on all levels)
\item
  A constructor for each constant
\item
  A single constructor for all function abstractions \emph{and} type
  abstractions (that is, a single constructor for all levels).
\item
  A single constructor for all function applications \emph{and} type
  applications (again, one constructor for all levels).
\item
  A single constructor for all function types \emph{and} type application (of
  all levels).
\end{itemize}

(And also the \texttt{let\ ..\ in\ ..} constructor)

So at this point, the plan seems clear: simply distinguish each of the
``squished'' abstractions into the four different levels (``unsquish'' them),
and make them a GADT parameterized on on the types with the right inductive
rules.

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
