<!DOCTYPE HTML>
<html><head><title>Applicative Regular Expressions using the Free Alternative · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="We’re going to implement applicative regular expressions and parsers (in the style of the regex-applicative library) using free structures! Free structures are some of my favorite tools in Haskell, and I’ve actually written a few posts about them before, including this one using free groups, this one on a free monad variation, and this one on a “free” applicative on a monoid. Regular expressions (and parsers) are ubiquitous in computer science and programming, and I hope that demonstrating that they are pretty straightforward to implement using free structures will help you see the value in free structures without getting too bogged down in the details!"><meta property="og:type" content="article"><meta property="og:title" content="Applicative Regular Expressions using the Free Alternative"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/free-alternative-regexp.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/free-alternative-regexp.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Applicative Regular Expressions using the Free Alternative</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/regexp.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/free-alternative-regexp.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/free-alternative-regexp.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@math.html" class="tag-a-category" title="@MATH">Math</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>We’re going to implement applicative regular expressions and parsers (in the style of the <a href="https://hackage.haskell.org/package/regex-applicative">regex-applicative</a> library) using free structures!</p>
<p>Free structures are some of my favorite tools in Haskell, and I’ve actually written a few posts about them before, including <a href="https://blog.jle.im/entry/alchemical-groups.html">this one using free groups</a>, <a href="https://blog.jle.im/entry/interpreters-a-la-carte-duet.html">this one on a free monad variation</a>, and <a href="https://blog.jle.im/entry/const-applicative-and-monoids.html">this one on a “free” applicative on a monoid</a>.</p>
<p>Regular expressions (and parsers) are ubiquitous in computer science and programming, and I hope that demonstrating that they are pretty straightforward to implement using free structures will help you see the value in free structures without getting too bogged down in the details!</p>
<h2 id="regular-languages">Regular Languages</h2>
<p>A <em>regular expression</em> is something that defines a <em>regular language</em>. <a href="https://en.wikipedia.org/wiki/Regular_expression#Formal_language_theory">Formally</a>, it consists of the following primitives:</p>
<ol type="1">
<li>The empty set, which always fails to match.</li>
<li>The empty string, which always succeeds matching the empty string.</li>
<li>The literal character, denoting a single matching character</li>
</ol>
<p>And the following operations:</p>
<ol type="1">
<li>Concatenation: <code>RS</code>, sequence one after the other. A set product.</li>
<li>Alternation: <code>R|S</code>, one or the other. A set union.</li>
<li>Kleene Star: <code>R*</code>, the repetition of <code>R</code> one or more times.</li>
</ol>
<h2 id="alternative">Alternative</h2>
<p>Looking at this, does this look a little familiar? It reminds me a lot of the <code>Alternative</code> hierarchy. If a functor <code>f</code> has an <code>Alternative</code> instance, it means that it has:</p>
<ol type="1">
<li><code>empty</code>, the failing operation</li>
<li><code>pure x</code>, the always-succeeding operation (from the <code>Applicative</code> class)</li>
<li><code>&lt;*&gt;</code>, the sequencing operation (from the <code>Applicative</code> class)</li>
<li><code>&lt;|&gt;</code>, the alternating operation</li>
<li><code>many</code>, the “one or more” operation.</li>
</ol>
<p>This…looks a lot like the construction of a regular language. The only thing missing is the literal character primitive.</p>
<p>So, one way we can look at regular expressions is “The entire <code>Alternative</code> interface, plus a character primitive”. <em>But!</em> There’s another way of looking at this, that leads us directly to free structures.</p>
<p>Instead of seeing things as “<code>Alternative</code> with a character primitive”, we can look at it as <em>a character primitive with a Alternative instance</em>.</p>
<h2 id="free">Free</h2>
<p>Let’s write this out. Our character primitive will be:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Prim</span> a <span class="fu">=</span> <span class="dt">Prim</span> <span class="dt">Char</span> a</a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>Note that because we’re working with functors, applicatives, alternatives, etc., all of our regular expressions must have an associated “result”. The value <code>Prim 'a' 1 :: Prim Int</code> will represent a primitive character that, when parsed, will give a result of <code>1</code>.</p>
<p>And now…we give it an <code>Alternative</code> instance using the <em>Free Alternative</em>, from the <em><a href="https://hackage.haskell.org/package/free">free</a></em> package:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> <span class="dt">Control.Alternative.Free</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">type</span> <span class="dt">RegExp</span> <span class="fu">=</span> <span class="dt">Alt</span> <span class="dt">Prim</span></a></code></pre></div>
<p>And that’s it! That’s our entire regular expression type! By giving a <code>Alt</code> a <code>Functor</code>, we get all of the operations of <code>Applicative</code> and <code>Alternative</code> over our base. That’s because we have <code>instance Applicative (Alt f)</code> and <code>instance Alternative (Alt f)</code>. We now have:</p>
<ol type="1">
<li>The empty set, coming from <code>empty</code> from <code>Alternative</code></li>
<li>The empty string, coming from <code>pure</code> from <code>Applicative</code></li>
<li>The character primitive, coming from the underlying functor <code>Prim</code> that we are enhancing</li>
<li>The concatenation operation, from <code>&lt;*&gt;</code>, from <code>Applicative</code>.</li>
<li>The alternating operation, from <code>&lt;|&gt;</code>, from <code>Alternative</code>.</li>
<li>The kleene star, from <code>many</code>, from <code>Alternative</code>.</li>
</ol>
<p>All of these (except for the primitive) come “for free”!</p>
<p>After adding some convenient wrappers…we’re done here!</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="co">-- | Parse a given character as a given constant result.</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">charAs ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">RegExp</span> a</a>
<a class="sourceLine" id="cb3-3" title="3">charAs c x <span class="fu">=</span> liftAlt (<span class="dt">Prim</span> c x)    <span class="co">-- liftAlt lets us use the underlying functor Prim in RegExp</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="co">-- | Parse a given character as itself.</span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">RegExp</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb3-7" title="7">char c <span class="fu">=</span> charAs c c</a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="co">-- | Parse a given string as itself.</span></a>
<a class="sourceLine" id="cb3-10" title="10"><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">RegExp</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-11" title="11">string <span class="fu">=</span> <span class="fu">traverse</span> char        <span class="co">-- neat, huh</span></a></code></pre></div>
<h3 id="examples">Examples</h3>
<p>Let’s try it out! Let’s match on <code>(a|b)(cd)*e</code> and return <code>()</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">testRegExp_ ::</span> <span class="dt">RegExp</span> ()</a>
<a class="sourceLine" id="cb4-2" title="2">testRegExp_ <span class="fu">=</span> void <span class="fu">$</span> (char <span class="ch">&#39;a&#39;</span> <span class="fu">&lt;|&gt;</span> char <span class="ch">&#39;b&#39;</span>)</a>
<a class="sourceLine" id="cb4-3" title="3">                  <span class="fu">*&gt;</span> many (string <span class="st">&quot;cd&quot;</span>)</a>
<a class="sourceLine" id="cb4-4" title="4">                  <span class="fu">*&gt;</span> char <span class="ch">&#39;e&#39;</span></a></code></pre></div>
<p><code>void</code> from <em>Data.Functor</em> discards the results, since we only care if it matches or not. But we use <code>&lt;|&gt;</code> and <code>*&gt;</code> and <code>many</code> exactly how we’d expect to concatenate and alternate things with <code>Applicative</code> and <code>Alternative</code>.</p>
<p>Or maybe more interesting (but slightly more complicated), let’s match on the same one and return how many <code>cd</code>s are repeated</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">testRegExp ::</span> <span class="dt">RegExp</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-2" title="2">testRegExp <span class="fu">=</span> (char <span class="ch">&#39;a&#39;</span> <span class="fu">&lt;|&gt;</span> char <span class="ch">&#39;b&#39;</span>)</a>
<a class="sourceLine" id="cb5-3" title="3">          <span class="fu">*&gt;</span> (<span class="fu">length</span> <span class="fu">&lt;$&gt;</span> many (string <span class="st">&quot;cd&quot;</span>))</a>
<a class="sourceLine" id="cb5-4" title="4">          <span class="fu">&lt;*</span> char <span class="ch">&#39;e&#39;</span></a></code></pre></div>
<p>This one does require a little more finesse with <code>*&gt;</code> and <code>&lt;*</code>: the arrows point towards which result to “keep”. And since <code>many (string "cd") :: RegExp [String]</code> (it returns a list, with an item for each repetition), we can <code>fmap length</code> to get the <code>Int</code> result of “how many repetitions”.</p></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@math.html" class="tag-a-category">@MATH</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/free-alternative-regexp.html';
    this.page.identifier = 'regexp';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>