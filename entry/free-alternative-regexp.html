<!DOCTYPE HTML>
<html><head><title>Applicative Regular Expressions using the Free Alternative · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="We’re going to implement applicative regular expressions and parsers (in the style of the regex-applicative library) using free structures! Free structures are some of my favorite tools in Haskell, and I’ve actually written a few posts about them before, including this one using free groups, this one on a free monad variation, and this one on a “free” applicative on a monoid. Regular expressions (and parsers) are ubiquitous in computer science and programming, and I hope that demonstrating that they are pretty straightforward to implement using free structures will help you see the value in free structures without getting too bogged down in the details!"><meta property="og:type" content="article"><meta property="og:title" content="Applicative Regular Expressions using the Free Alternative"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/free-alternative-regexp.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/free-alternative-regexp.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Applicative Regular Expressions using the Free Alternative</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/regexp.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/free-alternative-regexp.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/free-alternative-regexp.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@math.html" class="tag-a-category" title="@MATH">Math</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>We’re going to implement applicative regular expressions and parsers (in the style of the <a href="https://hackage.haskell.org/package/regex-applicative">regex-applicative</a> library) using free structures!</p>
<p>Free structures are some of my favorite tools in Haskell, and I’ve actually written a few posts about them before, including <a href="https://blog.jle.im/entry/alchemical-groups.html">this one using free groups</a>, <a href="https://blog.jle.im/entry/interpreters-a-la-carte-duet.html">this one on a free monad variation</a>, and <a href="https://blog.jle.im/entry/const-applicative-and-monoids.html">this one on a “free” applicative on a monoid</a>.</p>
<p>Regular expressions (and parsers) are ubiquitous in computer science and programming, and I hope that demonstrating that they are pretty straightforward to implement using free structures will help you see the value in free structures without getting too bogged down in the details!</p>
<h2 id="regular-languages">Regular Languages</h2>
<p>A <em>regular expression</em> is something that defines a <em>regular language</em>. <a href="https://en.wikipedia.org/wiki/Regular_expression#Formal_language_theory">Formally</a>, it consists of the following primitives:</p>
<ol type="1">
<li>The empty set, which always fails to match.</li>
<li>The empty string, which always succeeds matching the empty string.</li>
<li>The literal character, denoting a single matching character</li>
</ol>
<p>And the following operations:</p>
<ol type="1">
<li>Concatenation: <code>RS</code>, sequence one after the other. A set product.</li>
<li>Alternation: <code>R|S</code>, one or the other. A set union.</li>
<li>Kleene Star: <code>R*</code>, the repetition of <code>R</code> one or more times.</li>
</ol>
<h2 id="alternative">Alternative</h2>
<p>Looking at this, does this look a little familiar? It reminds me a lot of the <code>Alternative</code> hierarchy. If a functor <code>f</code> has an <code>Alternative</code> instance, it means that it has:</p>
<ol type="1">
<li><code>empty</code>, the failing operation</li>
<li><code>pure x</code>, the always-succeeding operation (from the <code>Applicative</code> class)</li>
<li><code>&lt;*&gt;</code>, the sequencing operation (from the <code>Applicative</code> class)</li>
<li><code>&lt;|&gt;</code>, the alternating operation</li>
<li><code>many</code>, the “one or more” operation.</li>
</ol>
<p>This…looks a lot like the construction of a regular language, doesn’t it? It’s almost as if <code>Alternative</code> has almost <em>exactly</em> what we need. The only thing missing is the literal character primitive.</p>
<p>If you’re unfamiliar with <code>Alternative</code>, the <a href="https://wiki.haskell.org/Typeclassopedia">typeclassopedia</a> has a good step-by-step introduction. But for the purposes of this article, it’s basically just a “double monoid”, with two “combining” actions <code>&lt;*&gt;</code> and <code>&lt;|&gt;</code>, which roughly correspond to <code>*</code> and <code>+</code> in the integers. It’s basically pretty much nothing more than 1-5 in the list above, and some distributivity laws.</p>
<p>So, one way we can look at regular expressions is “The entire <code>Alternative</code> interface, plus a character primitive”. <em>But!</em> There’s another way of looking at this, that leads us directly to free structures.</p>
<p>Instead of seeing things as “<code>Alternative</code> with a character primitive”, we can look at it as <em>a character primitive enriched with an blank-slate Alternative instance</em>.</p>
<h2 id="free">Free</h2>
<p>Let’s write this out. Our character primitive will be:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L14-L15</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">data</span> <span class="dt">Prim</span> a <span class="fu">=</span> <span class="dt">Prim</span> <span class="dt">Char</span> a</a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>Note that because we’re working with functors, applicatives, alternatives, etc., all of our regular expressions must have an associated “result”. The value <code>Prim 'a' 1 :: Prim Int</code> will represent a primitive character that, when parsed, will give a result of <code>1</code>.</p>
<p>And now…we give it <code>Alternative</code> structure using the <em>Free Alternative</em>, from the <em><a href="https://hackage.haskell.org/package/free">free</a></em> package:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> <span class="dt">Control.Alternative.Free</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L17-L17</span></a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="kw">type</span> <span class="dt">RegExp</span> <span class="fu">=</span> <span class="dt">Alt</span> <span class="dt">Prim</span></a></code></pre></div>
<p>And that’s it! That’s our entire regular expression type! By giving a <code>Alt</code> a <code>Functor</code>, we get all of the operations of <code>Applicative</code> and <code>Alternative</code> over our base. That’s because we have <code>instance Applicative (Alt f)</code> and <code>instance Alternative (Alt f)</code>. We now have:</p>
<ol type="1">
<li>The empty set, coming from <code>empty</code> from <code>Alternative</code></li>
<li>The empty string, coming from <code>pure</code> from <code>Applicative</code></li>
<li>The character primitive, coming from the underlying functor <code>Prim</code> that we are enhancing</li>
<li>The concatenation operation, from <code>&lt;*&gt;</code>, from <code>Applicative</code>.</li>
<li>The alternating operation, from <code>&lt;|&gt;</code>, from <code>Alternative</code>.</li>
<li>The kleene star, from <code>many</code>, from <code>Alternative</code>.</li>
</ol>
<p>All of these (except for the primitive) come “for free”!</p>
<p>Essentially, what a free structure gives us is the structure of the abstraction (<code>Alternative</code>, here) automatically for our base type, and <em>nothing else</em>. There’s no structure or properties at <em>all</em> about <code>RegExp</code>…other that it contains <code>Prim</code> and the minimal structure/scaffolding to be an <code>Alternative</code> instance.</p>
<p>After adding some convenient wrappers…we’re done here!</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L19-L30</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co">-- | charAs: Parse a given character as a given constant result.</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">charAs ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">RegExp</span> a</a>
<a class="sourceLine" id="cb3-5" title="5">charAs c x <span class="fu">=</span> liftAlt (<span class="dt">Prim</span> c x)     <span class="co">-- liftAlt lets us use the underlying</span></a>
<a class="sourceLine" id="cb3-6" title="6">                                    <span class="co">-- functor Prim in RegExp</span></a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="co">-- | charAs: Parse a given character as a given constant result.</span></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="ot">charAs ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">RegExp</span> a</a>
<a class="sourceLine" id="cb3-10" title="10">charAs c x <span class="fu">=</span> liftAlt (<span class="dt">Prim</span> c x)     <span class="co">-- liftAlt lets us use the underlying</span></a>
<a class="sourceLine" id="cb3-11" title="11">                                    <span class="co">-- functor Prim in RegExp</span></a>
<a class="sourceLine" id="cb3-12" title="12"></a>
<a class="sourceLine" id="cb3-13" title="13"><span class="co">-- | string: Parse a given string as itself.</span></a>
<a class="sourceLine" id="cb3-14" title="14"><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">RegExp</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-15" title="15">string <span class="fu">=</span> <span class="fu">traverse</span> char              <span class="co">-- neat, huh</span></a></code></pre></div>
<h3 id="examples">Examples</h3>
<p>Let’s try it out! Let’s match on <code>(a|b)(cd)*e</code> and return <code>()</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L32-L35</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="ot">testRegExp_ ::</span> <span class="dt">RegExp</span> ()</a>
<a class="sourceLine" id="cb4-4" title="4">testRegExp_ <span class="fu">=</span> void <span class="fu">$</span> (char <span class="ch">&#39;a&#39;</span> <span class="fu">&lt;|&gt;</span> char <span class="ch">&#39;b&#39;</span>)</a>
<a class="sourceLine" id="cb4-5" title="5">                  <span class="fu">*&gt;</span> many (string <span class="st">&quot;cd&quot;</span>)</a>
<a class="sourceLine" id="cb4-6" title="6">                  <span class="fu">*&gt;</span> char <span class="ch">&#39;e&#39;</span></a></code></pre></div>
<p><code>void</code> from <em>Data.Functor</em> discards the results, since we only care if it matches or not. But we use <code>&lt;|&gt;</code> and <code>*&gt;</code> and <code>many</code> exactly how we’d expect to concatenate and alternate things with <code>Applicative</code> and <code>Alternative</code>.</p>
<p>Or maybe more interesting (but slightly more complicated), let’s match on the same one and return how many <code>cd</code>s are repeated</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L37-L40</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="ot">testRegExp ::</span> <span class="dt">RegExp</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-4" title="4">testRegExp <span class="fu">=</span> (char <span class="ch">&#39;a&#39;</span> <span class="fu">&lt;|&gt;</span> char <span class="ch">&#39;b&#39;</span>)</a>
<a class="sourceLine" id="cb5-5" title="5">          <span class="fu">*&gt;</span> (<span class="fu">length</span> <span class="fu">&lt;$&gt;</span> many (string <span class="st">&quot;cd&quot;</span>))</a>
<a class="sourceLine" id="cb5-6" title="6">          <span class="fu">&lt;*</span> char <span class="ch">&#39;e&#39;</span></a></code></pre></div>
<p>This one does require a little more finesse with <code>*&gt;</code> and <code>&lt;*</code>: the arrows point towards which result to “keep”. And since <code>many (string "cd") :: RegExp [String]</code> (it returns a list, with an item for each repetition), we can <code>fmap length</code> to get the <code>Int</code> result of “how many repetitions”.</p>
<h2 id="parsing">Parsing</h2>
<p>Okay, so all we did was define a data structure that supports character matching, concatenation, alternation, and starring. Big whoop. What we really want to do is use it to parse things, right? How does the Free Alternative help us with <em>that</em>?</p>
<p>Well, a lot, actually. Let’s look at the definition of the free alternative:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">newtype</span> <span class="dt">Alt</span> f a <span class="fu">=</span> <span class="dt">Alt</span> {<span class="ot"> alternatives ::</span> [<span class="dt">AltF</span> f a] }</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">data</span> <span class="dt">AltF</span> f a <span class="fu">=</span> <span class="kw">forall</span> r<span class="fu">.</span> <span class="dt">Ap</span> (f r) (<span class="dt">Alt</span> f (r <span class="ot">-&gt;</span> a))</a>
<a class="sourceLine" id="cb6-4" title="4">              <span class="fu">|</span>           <span class="dt">Pure</span> a</a></code></pre></div>
<p>It’s a mutually recursive type, so it might be a little confusing. One way to understand <code>Alt</code> is that <code>Alt xs</code> contains a <em>list of alternatives</em>, or a list of <code>&lt;|&gt;</code>s. And each of those alternatives is an <code>AltF</code>, which is a <em>sequence of <code>f a</code>s</em> (as a chain of function applications).</p>
<p>You can essentially think of <code>AltF f a</code> as a linked list <code>[f r]</code>, except with a different <code>r</code> for each item. <code>Ap</code> is cons (<code>:</code>), containing the <code>f r</code>, and <code>Pure</code> is nil (<code>[]</code>).</p>
<p>It’s like a list (<code>Alt</code> list) of lists (<code>AltF</code> chains), which take turn alternating between alternative lists and application sequences.</p>
<p>Ultimately we want to write a <code>RegExp a -&gt; String -&gt; Maybe a</code>, which parses a string based on a <code>RegExp</code>. TO do this, we can simply pattern match and handle the cases.</p>
<p>First, the top-level <code>Alt</code> case. When faced with a list of chains, we can try to parse each one. The result is the first success. <code>asum :: [Maybe a] -&gt; Maybe a</code> finds the first <code>Just</code> (success) in a list of attempts.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L55-L56</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ot">matchAlts ::</span> <span class="dt">RegExp</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb7-4" title="4">matchAlts (<span class="dt">Alt</span> ls) xs <span class="fu">=</span> asum [ matchChain l xs <span class="fu">|</span> l <span class="ot">&lt;-</span> ls  ]</a></code></pre></div>
<p>Now, we need to handle the chain case. To do this, we can pattern match on each constructor, and handle each case.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">matchChain ::</span> <span class="dt">AltF</span> <span class="dt">Prim</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb8-2" title="2">matchChain (<span class="dt">Ap</span> (<span class="dt">Prim</span> c x) next) []     <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb8-3" title="3">matchChain (<span class="dt">Ap</span> (<span class="dt">Prim</span> c x) next) (d<span class="fu">:</span>ds)</a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="fu">|</span> c <span class="fu">==</span> d    <span class="fu">=</span> _             <span class="co">-- succesful match</span></a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> _             <span class="co">-- bad match</span></a>
<a class="sourceLine" id="cb8-6" title="6">matchChain (<span class="dt">Pure</span> x)             []     <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb8-7" title="7">matchChain (<span class="dt">Pure</span> x)             (d<span class="fu">:</span>ds) <span class="fu">=</span> _</a></code></pre></div>
<p>From here, it’s mostly “type tetris”! We just continually ask GHC what goes in what holes (and what types need to change) until we get something that typechecks.</p>
<p>In the end of the very mechanical process, we get:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L58-L63</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="ot">matchChain ::</span> <span class="dt">AltF</span> <span class="dt">Prim</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb9-4" title="4">matchChain (<span class="dt">Ap</span> _          _   ) []     <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-5" title="5">matchChain (<span class="dt">Ap</span> (<span class="dt">Prim</span> c x) next) (d<span class="fu">:</span>ds)</a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="fu">|</span> c <span class="fu">==</span> d    <span class="fu">=</span> matchAlts ((<span class="fu">$</span> x) <span class="fu">&lt;$&gt;</span> next) ds</a>
<a class="sourceLine" id="cb9-7" title="7">    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-8" title="8">matchChain (<span class="dt">Pure</span> x)             _      <span class="fu">=</span> <span class="dt">Just</span> x</a></code></pre></div>
<ol type="1">
<li><p>If it’s <code>Ap</code> (like cons, <code>:</code>), it means we’re in the middle of the chain.</p>
<ul>
<li>If the input string is empty, then we fail to match.</li>
<li>Otherwise, here’s the interesting thing. We have the <code>Prim</code> with the character we want to match, and the first letter in the string.
<ul>
<li>If the match is a success, we continue down the chain, to <code>next :: RegExp (r -&gt; a)</code>. We just need to massage the types a bit to make it all work out.</li>
<li>Otherwise, it’s a failure. We’re done here.</li>
</ul></li>
</ul></li>
<li><p>If it’s <code>Pure x</code> (like nil, <code>[]</code>), it means we’re at the end of the chain. We return the result in <code>Just</code>.</p></li>
</ol>
<p>In the end though, you don’t really need to understand any of this in order to write this. Sure, it’s nice to understand what <code>Ap</code>, <code>Pure</code>, <code>AltF</code>, etc. really “mean”. But, we don’t have to — the types take care of all of it for you :)</p>
<p><code>matchAlts</code> will match the <em>prefix</em> of the string, so we need to try all successive prefixes on an input string until we get a match.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L65-L66</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ot">match2 ::</span> <span class="dt">RegExp</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb10-4" title="4">match2 l xs <span class="fu">=</span> asum [ matchAlts l ys <span class="fu">|</span> ys <span class="ot">&lt;-</span> tails xs ]</a></code></pre></div></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@math.html" class="tag-a-category">@MATH</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/free-alternative-regexp.html';
    this.page.identifier = 'regexp';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>