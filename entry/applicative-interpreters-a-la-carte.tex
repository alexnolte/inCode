\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Day by Day: Applicative Interpreters a la Carte},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Day by Day: Applicative Interpreters a la Carte}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/applicative-interpreters-a-la-carte.html}{in
Code}}.}

I had the pleasure of working with both the
\emph{\href{https://hackage.haskell.org/package/servant}{servant}} and
\emph{\href{https://hackage.haskell.org/package/optparse-applicative}{optparse-applicative}}
libraries recently, which culminated in the
\emph{\href{https://hackage.haskell.org/package/servant-cli}{servant-cli}}
library. At first, I did everything by directly manipulating a \texttt{Parser}
type, which is the type of command line argument parsers from
\emph{optparse-applicative}. However, I ran into an issue very quickly: I needed
to be able to manipulate the \emph{structure} of a command line parser directly
--- deleting and modifying commands, the desire to be able to pattern match,
reflect on the arguments needed, move arguments around, etc. By working directly
with \texttt{Parser}, I threw everything into a black box that I could not
easily inspect. Have you ever felt like this with IO, or any other Applicative
(parsers or otherwise) you've had to use?

I realized that I needed to make an algebraic data type that could represent the
\emph{structure} of a command line parser. I needed an ADT that I could:

\begin{itemize}
\tightlist
\item
  Pattern match on to modify, shift, and re-arrange components of the parser
\item
  Reflect to inspect what sort of arguments the parser will ask for, what
  command line options are being asked for, etc.
\item
  Build from on very simple components that I could combine together in a
  logical way with semantic combinators.
\item
  Finally, ``run'' as an \emph{optparse-applicative} combinator, an interactive
  wizard, or generate rich documentation, etc.
\end{itemize}

During this journey, I ended up falling in love with a pattern I am calling
``Applicative Interpreters a la Carte'', that I believe is unique to Functor and
Applicative (that is, explicitly non-monadic) interpreters.

In this post we'll be creating such a structure from simple components using
Applicative Interpreter Combinators such as \texttt{Day}, \texttt{:*:},
\texttt{:+:}, \texttt{:*:}, \texttt{Ap} (the free Applicative), \texttt{Alt}
(the free Alternative), \texttt{Coyoneda} (the free Functor), \texttt{Lift} (the
free Pointed), and more! We'll also explore fundamental principles of each
combinator as they relate to a bigger picture.

\hypertarget{the-goal}{%
\section{The Goal}\label{the-goal}}

Let's define the overall structure of our command line menu: We will have a
hierarchy of nested sub-command menus that we can dig down. We can go down a
menu by specifying a ``command'' (with a catch-all wildcard command), and once
we get down to the action we want, we can finish up by specifying
\texttt{-\/-option}s.

For example, we can make a command line tool like ``git''

\begin{itemize}
\item
\end{itemize}

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
