\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={The Functor Combinatorpedia},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{The Functor Combinatorpedia}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/functor-combinatorpedia.html}{in
Code}}.}

Recently I've been very productive what I have been calling the ``Functor
Combinator'' design pattern. It is heavily influenced by ideas like
\href{http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf}{Data
types a la Carte} and
\href{http://oleg.fi/gists/posts/2018-02-21-single-free.html}{unified free
monoidal functors}, but the end goal is slightly different in spirit.

The goal is to represent schemas, DSL's, and computations (things like parsers,
things to execute, things to consume or produce data) by assembling
``self-evident'' basic primitives and subjecting them to many \emph{different}
successive transformations and combiners. The process of doing so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forces you to make explicit decisions about the structure of your computation
  type as an ADT.
\item
  Allows you to retain isolation of fundamental parts of your domain as separate
  types
\item
  Lets you manipulate the structure of your final computation type through
  \emph{normal Haskell techniques} like pattern matching. The structure is
  available throughout the entire process, so you can replace individual
  components and values within your structure.
\item
  Allows you to fully \emph{reflect} the structure of your final computation
  through pattern matching and folds, so you can inspect the structure and
  produce useful summaries.
\end{enumerate}

Like ``data types a la carte'' and free monad/applicative/alternative designs,
these techniques allow you to separate the assembly and inspection of your
programs from the ``running'' of them. However, the main difference is that here
we focus not just on products and sums, but many different varied and
multi-purpose combinators --- a bona fide ``zoo'' of combinators. So, this
focuses less on ``fixed-points'' like \texttt{Free}, \texttt{Ap}, \texttt{Alt},
and more on non-recursive simple building blocks\ldots where recursive
combinators like \texttt{Free} might be used along the way. The \emph{functor
itself} is the goal, \emph{not} its fixed point.

This post, then, will be a run-down on the wide variety of such ``functor
combinators'' across the Haskell ecosystem --- a functor combinator ``zoo'' of
sorts. To speak about them all with the same language and vocabulary, this post
also serves as an overview of the
\emph{\href{https://hackage.haskell.org/package/functor-combinators}{functor-combinators}}
library, which mostly pulls them all together and provides a unified interface
for working with them.

\hypertarget{prologue-what-is-a-functor-combinator}{%
\section{Prologue: What is a functor
combinator?}\label{prologue-what-is-a-functor-combinator}}

A functor combinator takes ``functors'' (or other indexed types) and returns a
new functor, enhances or mixes them together in some way.

That is, they take things of kind \texttt{k\ -\textgreater{}\ Type} and
themselves return a \texttt{k\ -\textgreater{}\ Type}. This lets us build
complex functors out of simpler ``primitive'' ones.

For example, \texttt{ReaderT\ r} is a famous one that takes a functor \texttt{f}
and enhances it with ``access to an \texttt{r} environment'' functionality.
Another famous one is \texttt{Free}, which takes a functor \texttt{f} and
enhances it with ``sequential binding'' capabilities: it turns \texttt{f} into a
\texttt{Monad}. Yet another is \texttt{EnvT\ e}, which takes a functor
\texttt{f} and enhances it by ``tagging an \texttt{e} value'' along our
\texttt{f\ a}s.

Sometimes, we have binary functor combinators, like \texttt{:+:}, which takes
two functors \texttt{f} and \texttt{g} and returns a functor that is ``either''
\texttt{f} or \texttt{g}. Binary functor combinators ``mix together'' the
functionality of different functors in different ways.

\hypertarget{examples}{%
\subsection{Examples}\label{examples}}

If your final DSL/program/schema is some functor, then functor combinators allow
you to construct your final functor by combining simpler ``primitive'' functors,
and take advantage of common functionality.

For example, if you were making a data type/EDSL to describe a command line
parser, you might have two primitives: \texttt{data\ Arg\ a}, for positional
arguments parsing \texttt{a}, and \texttt{data\ Option\ a}, for
\texttt{-\/-flag} non-positional options parsing \texttt{a}. From there, you can
\emph{choose} what structure of command line arguments you want to be able to
express.

For instance, a structure that can support multiple arguments and optionally a
single \texttt{Option} would be:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{CommandArgs} \OtherTok{=} \DataTypeTok{Ap} \DataTypeTok{Arg} \OperatorTok{:*:} \DataTypeTok{Lift} \DataTypeTok{Option}
\end{Highlighting}
\end{Shaded}

And a structure that supports \emph{multiple commands} on top of that would be:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{CommandArgs} \OtherTok{=} \DataTypeTok{MapF} \DataTypeTok{String}\NormalTok{ (}\DataTypeTok{Ap} \DataTypeTok{Arg} \OperatorTok{:*:} \DataTypeTok{Lift} \DataTypeTok{Option}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can mix or match combinators to decide exactly what sort of structures you
allow in your DSL.

Now, instead of writing one ``giant''
\texttt{runParser\ ::\ MapF\ String\ (Ap\ Arg\ :*:\ Lift\ Option)\ a\ -\textgreater{}\ IO\ a}
function, you can instead just write parsers for your simple primitives
\texttt{Arg\ a\ -\textgreater{}\ IO\ a} and
\texttt{Option\ a\ -\textgreater{}\ IO\ a}, and then use functor combinator
tools to ``promote'' them to being runnable on a full
\texttt{MapF\ String\ (Ap\ Arg\ :*:\ Lift\ Option)} without any extra work.

\hypertarget{common-functionality}{%
\subsection{Common Functionality}\label{common-functionality}}

Most of these functor combinators allow us to ``swap out'' the underlying
functor, retaining all of the ``enhanced'' structure. We abstract over all of
these using \texttt{hmap} for single-argument functor combinators
(``enhancers'') and \texttt{hbimap} for two-argument functor combinators
(``mixers'').

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{HFunctor}\NormalTok{ t }\KeywordTok{where}
    \CommentTok{{-}{-} | Swap out underlying functor for a single{-}argument functor combinator}
\NormalTok{    hmap}
\OtherTok{        ::}\NormalTok{ t f a }\OtherTok{{-}>}\NormalTok{ t g a}

\KeywordTok{class} \DataTypeTok{HBifunctor}\NormalTok{ t }\KeywordTok{where}
    \CommentTok{{-}{-} | Swap out underlying functors for a two{-}argument functor combinator}
\NormalTok{    hbimap}
\OtherTok{        ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}>}\NormalTok{ h x)}
        \OtherTok{{-}>}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ g x }\OtherTok{{-}>}\NormalTok{ j x)}
        \OtherTok{{-}>}\NormalTok{ t f g a}
        \OtherTok{{-}>}\NormalTok{ t g j a}
\end{Highlighting}
\end{Shaded}

However, for this post, the concept of a ``natural transformation'' between
\texttt{f} and \texttt{g} --- a function of type
\texttt{forall\ x.\ f\ x\ -\textgreater{}\ g\ x}, is given a type synonym:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ g }\OtherTok{=} \KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}>}\NormalTok{ g x}
\end{Highlighting}
\end{Shaded}

Then the type signatures of \texttt{hmap} and \texttt{hbimap} become:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{HFunctor}\NormalTok{ t }\KeywordTok{where}
\NormalTok{    hmap}
\OtherTok{        ::}\NormalTok{ t f }\OperatorTok{\textasciitilde{}>}\NormalTok{ t g}

\KeywordTok{class} \DataTypeTok{HBifunctor}\NormalTok{ t }\KeywordTok{where}
\NormalTok{    hbimap}
\OtherTok{        ::}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
        \OtherTok{{-}>}\NormalTok{ g }\OperatorTok{\textasciitilde{}>}\NormalTok{ j}
        \OtherTok{{-}>}\NormalTok{ t f g }\OperatorTok{\textasciitilde{}>}\NormalTok{ t h j}
\end{Highlighting}
\end{Shaded}

What does it mean exactly when we say that \texttt{hmap} and \texttt{hbimap}
``preserve the enhanced structure''? Well, for example, \texttt{ListF\ f\ a} is
essentially a list of \texttt{f\ a}s. \texttt{hmap} will swap out and replace
each \texttt{f\ a}, but it must \emph{preserve the relative order} between each
of the original \texttt{f\ a}s. And it must preserve the length of the list.
It's a complete ``in-place swap''. This is formalizing by requiring
\texttt{hmap\ id\ ==\ id} and \texttt{hbimap\ id\ id\ ==\ id}.

You can also always ``lift'' a functor value into its transformed type. We
abstract over this by using \texttt{inject} (for single-argument functors) and
\texttt{inL} and \texttt{inR} (for two-argument functors):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Inject}\NormalTok{ t }\KeywordTok{where}
    \CommentTok{{-}{-} | Lift \textasciigrave{}f\textasciigrave{} into \textasciigrave{}t f\textasciigrave{}}
\OtherTok{    inject ::}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ t f}

\OtherTok{inL ::}\NormalTok{ (}\DataTypeTok{Monoidal}\NormalTok{ t, }\DataTypeTok{CM}\NormalTok{ t g)     }\CommentTok{{-}{-} more on the \textasciigrave{}CM t\textasciigrave{} later}
    \OtherTok{=>}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ t f g}

\OtherTok{inR ::}\NormalTok{ (}\DataTypeTok{Monoidal}\NormalTok{ t, }\DataTypeTok{CM}\NormalTok{ t f)     }\CommentTok{{-}{-} more on the \textasciigrave{}CM t\textasciigrave{} later}
    \OtherTok{=>}\NormalTok{ g }\OperatorTok{\textasciitilde{}>}\NormalTok{ t f g}
\end{Highlighting}
\end{Shaded}

Finally, in order to \emph{use} any functor combinators, you have to
\emph{interpret} them into some target context. The choice of combinator imposes
some constraints on the target context. We abstract over this using
\texttt{interpret} and \texttt{binterpret}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Interpret}\NormalTok{ t }\KeywordTok{where}
    \KeywordTok{type} \DataTypeTok{C}\OtherTok{ t ::}\NormalTok{ (}\DataTypeTok{Type} \OtherTok{{-}>} \DataTypeTok{Type}\NormalTok{) }\OtherTok{{-}>} \DataTypeTok{Constraint}

    \CommentTok{{-}{-} | Interpret unary functor combinator}
\NormalTok{    interpret}
\OtherTok{        ::} \DataTypeTok{C}\NormalTok{ t g}
        \OtherTok{=>}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ g             }\CommentTok{{-}{-} \^{} interpreting function}
        \OtherTok{{-}>}\NormalTok{ t f }\OperatorTok{\textasciitilde{}>}\NormalTok{ g}

\KeywordTok{instance} \DataTypeTok{Semigroupoidal}\NormalTok{ t }\KeywordTok{where}
    \CommentTok{{-}{-} | Interpret binary functor combinator}
\NormalTok{    binterpret}
\OtherTok{        ::}\NormalTok{ (}\DataTypeTok{Semigroupoidal}\NormalTok{ t, }\DataTypeTok{CS}\NormalTok{ t h)}
        \OtherTok{=>}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h             }\CommentTok{{-}{-} \^{} interpreting function on f}
        \OtherTok{=>}\NormalTok{ g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h             }\CommentTok{{-}{-} \^{} interpreting function on g}
        \OtherTok{{-}>}\NormalTok{ t f g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
\end{Highlighting}
\end{Shaded}

Each functor combinator defines a constraint (\texttt{C} for unary functor
combinators, and \texttt{CS} and \texttt{CM} for binary functor combinators)
that allows you to ``exit'', or ``run'' the functor combinator.

For some concrete examples:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{C}\NormalTok{ (}\DataTypeTok{ReaderT}\NormalTok{ r) }\OtherTok{=} \DataTypeTok{MonadReader}\NormalTok{ r}

\NormalTok{interpret }\OperatorTok{@}\NormalTok{(}\DataTypeTok{MonadReader}\NormalTok{ r)}
\OtherTok{    ::} \DataTypeTok{MonadReader}\NormalTok{ r g}
    \OtherTok{=>}\NormalTok{ (f }\OperatorTok{\textasciitilde{}>}\NormalTok{ g)}
    \OtherTok{{-}>} \DataTypeTok{ReaderT}\NormalTok{ r f a}
    \OtherTok{{-}>}\NormalTok{ g a}

\KeywordTok{type} \DataTypeTok{C} \DataTypeTok{Free} \OtherTok{=} \DataTypeTok{Monad}

\NormalTok{interpret }\OperatorTok{@}\DataTypeTok{Free}
\OtherTok{    ::} \DataTypeTok{Monad}\NormalTok{ g}
    \OtherTok{=>}\NormalTok{ (f }\OperatorTok{\textasciitilde{}>}\NormalTok{ g)}
    \OtherTok{{-}>} \DataTypeTok{Free}\NormalTok{ f a}
    \OtherTok{{-}>}\NormalTok{ g a}

\KeywordTok{type} \DataTypeTok{CM}\NormalTok{ (}\OperatorTok{:+:}\NormalTok{) }\OtherTok{=} \DataTypeTok{Unconstrained}   \CommentTok{{-}{-} no constraints on exiting}

\NormalTok{binterpret }\OperatorTok{@}\NormalTok{(}\OperatorTok{:+:}\NormalTok{)}
\OtherTok{    ::}\NormalTok{ (f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{{-}>}\NormalTok{ (g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{{-}>}\NormalTok{ (f }\OperatorTok{:+:}\NormalTok{ g) a}
    \OtherTok{{-}>}\NormalTok{ h a}
\end{Highlighting}
\end{Shaded}

We see that \texttt{interpret} lets you ``run'' a \texttt{ReaderT\ r\ f} into
any \texttt{MonadReader\ r\ g} and ``run'' a \texttt{Free} in any monad
\texttt{g}, and \texttt{binterpret} lets you ``run'' a function over both
branches of an \texttt{f\ :+:\ g} to produce an \texttt{h}.

From these, we can build a lot of useful utility functions (like
\texttt{retract}, \texttt{biretract}, \texttt{getI}, \texttt{biget}, etc.) for
convenience in actually working on them. These are provided in
\emph{\href{https://hackage.haskell.org/package/functor-combinators}{functor-combinators}}.

Without further ado, let's dive into the zoo of functor combinators!

\hypertarget{the-zoo}{%
\section{The Zoo}\label{the-zoo}}

\hypertarget{two-argument}{%
\subsection{Two-Argument}\label{two-argument}}

Binary functor combinators ``mix together'' two functors/indexed types in
different ways.

We can finally \emph{interpret} (or ``run'') these into some target context
(like \texttt{Parser}, or \texttt{IO}), provided the target satisfies some
constraints.

This constraint depends on the functor combinator in question; in particular,
there are two, which we will call \texttt{CS} and \texttt{CM}:

\begin{itemize}
\item
  \texttt{CS\ t} is what we will call the constraint on where you can
  \emph{interpret} or \emph{run} values of the enhanced type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binterpret}
\OtherTok{    ::}\NormalTok{ (}\DataTypeTok{Semigroupoidal}\NormalTok{ t, }\DataTypeTok{CS}\NormalTok{ t h)}
    \OtherTok{=>}\NormalTok{ (f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{=>}\NormalTok{ (g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{{-}>}\NormalTok{ (t f g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{CM\ t} is the constraint on where you can \emph{create} values of the
  enhanced type (\texttt{pureT}, \texttt{inL}, \texttt{inR})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pureT}
\OtherTok{    ::}\NormalTok{ (}\DataTypeTok{Monoidal}\NormalTok{ t, }\DataTypeTok{CM}\NormalTok{ t f)}
    \OtherTok{=>} \DataTypeTok{I}\NormalTok{ t }\OperatorTok{\textasciitilde{}>}\NormalTok{ f}

\OtherTok{inL ::}\NormalTok{ (}\DataTypeTok{Monoidal}\NormalTok{ t, }\DataTypeTok{CM}\NormalTok{ t g)}
    \OtherTok{=>}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ t f g}

\OtherTok{inR ::}\NormalTok{ (}\DataTypeTok{Monoidal}\NormalTok{ t, }\DataTypeTok{CM}\NormalTok{ t f)}
    \OtherTok{=>}\NormalTok{ g }\OperatorTok{\textasciitilde{}>}\NormalTok{ t f g}
\end{Highlighting}
\end{Shaded}

  It should always be a subclass of \texttt{CS}.
\end{itemize}

As it turns out, \texttt{CS} and \texttt{CM} generalize the ``has an identity''
property of many typeclasses --- for example, for \texttt{Comp} (functor
composition), \texttt{CS} is \texttt{Bind} (``\texttt{Monad} without
\texttt{pure}''), and \texttt{CM} is \texttt{Monad}.

Most of these also have an identity, \texttt{I\ t}, where applying
\texttt{t\ f\ (I\ t)} leaves \texttt{f} unchanged (\texttt{t\ f\ (I\ t)} is
isomorphic to \texttt{f}) and \texttt{t\ (I\ t)\ f} is also just \texttt{f}.
This is represented by the associated type \texttt{I\ t}.

One interesting property of these is that for a lot of these, if we have a
binary functor combinator \texttt{*}, we can represent a type
\texttt{f\ \textbar{}\ f\ *\ f\ \textbar{}\ f\ *\ f\ *\ f\ \textbar{}\ f\ *\ f\ *\ f\ *\ f\ \textbar{}\ ...}
(``repeatedly apply to something multiple times''), which essentially forms a
linked list along that functor combinator. We call this the ``induced monoidal
functor combinator'', given by \texttt{MF\ t}. We can also make a ``non-empty
variant'', \texttt{SF\ t}, the ``induced semigroupoidal functor combinator'',
which contains ``at least one \texttt{f}''.

You can ``convert'' back and forth by using:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{toMF   ::}\NormalTok{ t f f }\OperatorTok{\textasciitilde{}>} \DataTypeTok{MF}\NormalTok{ t}
\OtherTok{nilMF  ::} \DataTypeTok{I}\NormalTok{ t }\OperatorTok{\textasciitilde{}>} \DataTypeTok{MF}\NormalTok{ t}
\OtherTok{consMF ::}\NormalTok{ t f (}\DataTypeTok{MF}\NormalTok{ t) }\OperatorTok{\textasciitilde{}>} \DataTypeTok{MF}\NormalTok{ t}
\end{Highlighting}
\end{Shaded}

and other helper functions.

If this is unclear, hopefully the following concrete examples will help
illustrate.

\hypertarget{sum}{%
\subsubsection{:+: / Sum}\label{sum}}

\begin{itemize}
\item
  \textbf{Origin}:
  \emph{\href{https://hackage.haskell.org/package/base/docs/GHC-Generics.html}{GHC.Generics}}
  (for \texttt{:+:}) /
  \emph{\href{https://hackage.haskell.org/package/base/docs/Data-Functor-Sum.html}{Data.Functor.Sum}}
  (for \texttt{Sum})
\item
  \textbf{Mixing Strategy}: ``Either-or'': provide either case, and user has to
  handle both possibilities. Basically higher-order \texttt{Either}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{ (f }\OperatorTok{:+:}\NormalTok{ g) a}
    \OtherTok{=} \DataTypeTok{L1}\NormalTok{ (f a)}
    \OperatorTok{|} \DataTypeTok{R1}\NormalTok{ (g a)}

\KeywordTok{data} \DataTypeTok{Sum}\NormalTok{ f g a}
    \OtherTok{=} \DataTypeTok{InL}\NormalTok{ (f a)}
    \OperatorTok{|} \DataTypeTok{InR}\NormalTok{ (g a)}
\end{Highlighting}
\end{Shaded}

  It can be useful for situations where you can validly use one or the other in
  your schema or functor. For example, if you are describing an HTTP request, we
  could have \texttt{data\ GET\ a} describing a GET request and
  \texttt{data\ POST\ a} describing a POST request; \texttt{(GET\ :+:\ POST)\ a}
  would be a functor that describes either a GET or POST request.

  The person who creates the \texttt{f\ :+:\ g} decides which one to give, and
  the person who consumes/interprets/runs the \texttt{f\ :+:\ g} must provide a
  way of handling \emph{both}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binterpret }\OperatorTok{@}\NormalTok{(}\OperatorTok{:+:}\NormalTok{)}
\OtherTok{    ::}\NormalTok{ (f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{{-}>}\NormalTok{ (g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{{-}>}\NormalTok{ (f }\OperatorTok{:+:}\NormalTok{ g) a}
    \OtherTok{{-}>}\NormalTok{ h a}
\end{Highlighting}
\end{Shaded}

  \texttt{binterpret} becomes analogous to \texttt{either} from
  \emph{\href{https://hackage.haskell.org/package/base/docs/Data-Either.html}{Data.Either}}
\item
  \textbf{Identity}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{I}\NormalTok{ (}\OperatorTok{:+:}\NormalTok{) }\OtherTok{=} \DataTypeTok{Void1}

\CommentTok{{-}{-} | Data type with no inhabitants}
\KeywordTok{data} \DataTypeTok{Void1}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

  \texttt{f\ :+:\ Void1} is equivalent to just \texttt{f}, because you can never
  have a value of the right branch.
\item
  \textbf{Constraints}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{CS}\NormalTok{ (}\OperatorTok{:+:}\NormalTok{) }\OtherTok{=} \DataTypeTok{Unconstrained}
\KeywordTok{type} \DataTypeTok{CM}\NormalTok{ (}\OperatorTok{:+:}\NormalTok{) }\OtherTok{=} \DataTypeTok{Unconstrained}

\NormalTok{binterpret }\OperatorTok{@}\NormalTok{(}\OperatorTok{:+:}\NormalTok{)}
\OtherTok{    ::}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
    \OtherTok{{-}>}\NormalTok{ g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
    \OtherTok{{-}>}\NormalTok{ (f }\OperatorTok{:+:}\NormalTok{ g) }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}

\NormalTok{inL   }\OperatorTok{@}\OtherTok{(:+:) ::}\NormalTok{ f     }\OperatorTok{\textasciitilde{}>}\NormalTok{ f }\OperatorTok{:+:}\NormalTok{ g}
\NormalTok{inR   }\OperatorTok{@}\OtherTok{(:+:) ::}\NormalTok{ g     }\OperatorTok{\textasciitilde{}>}\NormalTok{ f }\OperatorTok{:+:}\NormalTok{ g}
\NormalTok{pureT }\OperatorTok{@}\OtherTok{(:+:) ::} \DataTypeTok{Void1} \OperatorTok{\textasciitilde{}>}\NormalTok{ h}
\end{Highlighting}
\end{Shaded}

  You don't need any constraint in order to use \texttt{binterpret},
  \texttt{inL}, \texttt{inR}, etc.

  However, note that \texttt{pureT} is effectively impossible to call, because
  no values of type \texttt{Void1\ a} exist.
\item
  \textbf{Induced Monoid}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{SF}\NormalTok{ (}\OperatorTok{:+:}\NormalTok{) }\OtherTok{=} \DataTypeTok{Step}
\KeywordTok{type} \DataTypeTok{MF}\NormalTok{ (}\OperatorTok{:+:}\NormalTok{) }\OtherTok{=} \DataTypeTok{Step}
\end{Highlighting}
\end{Shaded}

  \texttt{Step} is the result of an infinite application of \texttt{:+:} to the
  same value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Step}\NormalTok{ f }\OtherTok{=}\NormalTok{ f }\OperatorTok{:+:}\NormalTok{ f }\OperatorTok{:+:}\NormalTok{ f }\OperatorTok{:+:}\NormalTok{ f }\OperatorTok{:+:}\NormalTok{ f }\OperatorTok{:+:}\NormalTok{ f }\OperatorTok{:+:} \OperatorTok{...}\NormalTok{ etc}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

  The correspondence is:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{L1}\NormalTok{ x           }\OperatorTok{<=>} \DataTypeTok{Step} \DecValTok{0}\NormalTok{ x}
\DataTypeTok{R1}\NormalTok{ (}\DataTypeTok{L1}\NormalTok{ y)      }\OperatorTok{<=>} \DataTypeTok{Step} \DecValTok{1}\NormalTok{ y}
\DataTypeTok{R1}\NormalTok{ (}\DataTypeTok{R1}\NormalTok{ (}\DataTypeTok{L1}\NormalTok{ z)) }\OperatorTok{<=>} \DataTypeTok{Step} \DecValTok{2}\NormalTok{ z}
\CommentTok{{-}{-} etc.}
\end{Highlighting}
\end{Shaded}

  It's not a particularly useful type, but it can be useful if you want to
  provide an \texttt{f\ a} alongside ``which position'' it is on the infinite
  list. Repeatedly using \texttt{consMF} will push the \texttt{f} further and
  further along the list.
\end{itemize}

\hypertarget{product}{%
\subsubsection{:*: / Product}\label{product}}

\begin{itemize}
\item
  \textbf{Origin}:
  \emph{\href{https://hackage.haskell.org/package/base/docs/GHC-Generics.html}{GHC.Generics}}
  (for \texttt{:*:}) /
  \emph{\href{https://hackage.haskell.org/package/base/docs/Data-Functor-Product.html}{Data.Functor.Product}}
  (for \texttt{Product})
\item
  \textbf{Mixing Strategy}: ``Both, separately'': provide values from
  \emph{both} functors, and the user can choose which one they want to use.
  Basically a higher-order tuple.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{ (f }\OperatorTok{:*:}\NormalTok{ g) a }\OtherTok{=}\NormalTok{ f a }\OperatorTok{:*:}\NormalTok{ g a}

\KeywordTok{data} \DataTypeTok{Product}\NormalTok{ f g a }\OtherTok{=} \DataTypeTok{Pair}\NormalTok{ (f a) (g a)}
\end{Highlighting}
\end{Shaded}

  It can be useful for situations where your schema/functor must be
  \emph{specified} using \emph{both} functors, but the \emph{interpreter} can
  choose to use only one or the other (or both).

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{prodOutL ::}\NormalTok{ (f }\OperatorTok{:*:}\NormalTok{ g) }\OperatorTok{\textasciitilde{}>}\NormalTok{ f}
\NormalTok{prodOutL (x }\OperatorTok{:*:}\NormalTok{ \_) }\OtherTok{=}\NormalTok{ x}

\OtherTok{prodOutR ::}\NormalTok{ (f }\OperatorTok{:*:}\NormalTok{ g) }\OperatorTok{\textasciitilde{}>}\NormalTok{ g}
\NormalTok{prodOutR (\_ }\OperatorTok{:*:}\NormalTok{ y) }\OtherTok{=}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Identity}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{I}\NormalTok{ (}\OperatorTok{:*:}\NormalTok{) }\OtherTok{=} \DataTypeTok{Proxy}

\CommentTok{{-}{-} | Data type with only a single constructor and no information}
\KeywordTok{data} \DataTypeTok{Proxy}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Proxy}
\end{Highlighting}
\end{Shaded}

  \texttt{f\ :+:\ Proxy} is equivalent to just \texttt{f}, because the left hand
  side doesn't add anything extra to the pair.
\item
  \textbf{Constraints}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{CS}\NormalTok{ (}\OperatorTok{:*:}\NormalTok{) }\OtherTok{=} \DataTypeTok{Alt}
\KeywordTok{type} \DataTypeTok{CM}\NormalTok{ (}\OperatorTok{:*:}\NormalTok{) }\OtherTok{=} \DataTypeTok{Plus}

\NormalTok{binterpret }\OperatorTok{@}\NormalTok{(}\OperatorTok{:*:}\NormalTok{)}
\OtherTok{    ::} \DataTypeTok{Alt}\NormalTok{ h}
    \OtherTok{=>}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
    \OtherTok{{-}>}\NormalTok{ g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
    \OtherTok{{-}>}\NormalTok{ (f }\OperatorTok{:*:}\NormalTok{ g) }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}

\NormalTok{inL   }\OperatorTok{@}\OtherTok{(:*:) ::} \DataTypeTok{Plus}\NormalTok{ g }\OtherTok{=>}\NormalTok{ f     }\OperatorTok{\textasciitilde{}>}\NormalTok{ f }\OperatorTok{:*:}\NormalTok{ g}
\NormalTok{inR   }\OperatorTok{@}\OtherTok{(:*:) ::} \DataTypeTok{Plus}\NormalTok{ f }\OtherTok{=>}\NormalTok{ g     }\OperatorTok{\textasciitilde{}>}\NormalTok{ f }\OperatorTok{:*:}\NormalTok{ g}
\NormalTok{pureT }\OperatorTok{@}\OtherTok{(:*:) ::} \DataTypeTok{Plus}\NormalTok{ h }\OtherTok{=>} \DataTypeTok{Proxy} \OperatorTok{\textasciitilde{}>}\NormalTok{ h}
\end{Highlighting}
\end{Shaded}

  \texttt{Alt}, from
  \emph{\href{https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Alt.html}{Data.Functor.Alt}}
  in \emph{semigroupoids}, can be thought of a ``higher-kinded semigroup'': it's
  like \texttt{Alternative}, but with no \texttt{Applicative} constraint and no
  identity:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Alt}\NormalTok{ f }\KeywordTok{where}
\OtherTok{    (<!>) ::}\NormalTok{ f a }\OtherTok{{-}>}\NormalTok{ f a }\OtherTok{{-}>}\NormalTok{ f a}
\end{Highlighting}
\end{Shaded}

  It is used to combine the results in both branches of the \texttt{:*:}.

  To introduce an ``empty'' branch, we need \texttt{Plus} (in
  \emph{\href{https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Plus.html}{Data.Functor.Plus}}),
  which is like a higher-kinded \texttt{Monoid}, or \texttt{Alternative} with no
  \texttt{Applicative}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Alt}\NormalTok{ f }\OtherTok{=>} \DataTypeTok{Plus}\NormalTok{ f }\KeywordTok{where}
\OtherTok{    zero ::}\NormalTok{ f a}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Induced Monoid}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{SF}\NormalTok{ (}\OperatorTok{:*:}\NormalTok{) }\OtherTok{=} \DataTypeTok{NonEmptyF}
\KeywordTok{type} \DataTypeTok{MF}\NormalTok{ (}\OperatorTok{:*:}\NormalTok{) }\OtherTok{=} \DataTypeTok{ListF}
\end{Highlighting}
\end{Shaded}

  \texttt{ListF\ f\ a} is a ``list of \texttt{f\ a}s''. It represents the
  posibility of having \texttt{Proxy} (zero items), \texttt{x\ ::\ f\ a} (one
  item), \texttt{x\ :*:\ y} (two items), \texttt{x\ :*:\ y\ :*:\ z} (three
  items), etc.

  It's basically an ordered collection of \texttt{f\ a}s \texttt{:*:}d with each
  other.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{Proxy}         \OperatorTok{<=>} \DataTypeTok{ListF}\NormalTok{ []}
\NormalTok{x             }\OperatorTok{<=>} \DataTypeTok{ListF}\NormalTok{ [x]}
\NormalTok{x }\OperatorTok{:*:}\NormalTok{ y       }\OperatorTok{<=>} \DataTypeTok{ListF}\NormalTok{ [x,y]}
\NormalTok{x }\OperatorTok{:*:}\NormalTok{ y }\OperatorTok{:*:}\NormalTok{ z }\OperatorTok{<=>} \DataTypeTok{ListF}\NormalTok{ [x,y,z]}
\CommentTok{{-}{-} etc.}
\end{Highlighting}
\end{Shaded}

  It is useful if you want to define a schema where you can offer
  \emph{multiple} options for the \texttt{f\ a}, and the interpreter/consumer
  can freely pick any one that they want to use.

  \texttt{NonEmptyF} is the version of \texttt{ListF} that has ``at least one
  \texttt{f\ a}''.

  Incidentally, \texttt{NonEmptyF} is the ``free \texttt{Alt}'' (it gives a
  functor \texttt{Alt}-ness, and nothing more), and \texttt{ListF} is the ``free
  \texttt{Plus}'' (it gives a functor \texttt{Plus}-ness, and nothing more).
\end{itemize}

\hypertarget{day}{%
\subsubsection{Day}\label{day}}

\begin{itemize}
\item
  \textbf{Origin}:
  \emph{\href{https://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Day.html}{Data.Functor.Day}}
\item
  \textbf{Mixing Strategy}: ``Both, together forever'': provide values from
  \emph{both} functors, and the user \emph{must} also \emph{use} both.

  It can be useful for situations where your schema/functor must be
  \emph{specified} using \emph{both} functors, and the user must also \emph{use}
  both.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binterpret }\OperatorTok{@}\DataTypeTok{Day}
\OtherTok{    ::} \DataTypeTok{Apply}\NormalTok{ h          }\CommentTok{{-}{-} superclass of Applicative}
    \OtherTok{=>}\NormalTok{ (f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{{-}>}\NormalTok{ (g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{{-}>} \DataTypeTok{Day}\NormalTok{ f g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
\end{Highlighting}
\end{Shaded}

  Unlike for \texttt{:*:}, you always have to interpret \emph{both} functor
  values in order to interpret a \texttt{Day}. It's a ``full mixing''.
\item
  \textbf{Identity}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{I} \DataTypeTok{Day} \OtherTok{=} \DataTypeTok{Identity}
\end{Highlighting}
\end{Shaded}

  \texttt{Day\ f\ Identity} is equivalent to just \texttt{f}, because
  \texttt{Identity} adds no extra effects or structure.
\item
  \textbf{Constraints}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{CS} \DataTypeTok{Day} \OtherTok{=} \DataTypeTok{Apply}
\KeywordTok{type} \DataTypeTok{CM} \DataTypeTok{Day} \OtherTok{=} \DataTypeTok{Applicative}

\NormalTok{binterpret }\OperatorTok{@}\DataTypeTok{Day}
\OtherTok{    ::} \DataTypeTok{Apply}\NormalTok{ h}
    \OtherTok{=>}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
    \OtherTok{{-}>}\NormalTok{ g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
    \OtherTok{{-}>} \DataTypeTok{Day}\NormalTok{ f g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}

\NormalTok{inL   }\OperatorTok{@}\DataTypeTok{Day}\OtherTok{ ::} \DataTypeTok{Applicative}\NormalTok{ g }\OtherTok{=>}\NormalTok{ f        }\OperatorTok{\textasciitilde{}>} \DataTypeTok{Day}\NormalTok{ f g}
\NormalTok{inR   }\OperatorTok{@}\DataTypeTok{Day}\OtherTok{ ::} \DataTypeTok{Applicative}\NormalTok{ f }\OtherTok{=>}\NormalTok{ g        }\OperatorTok{\textasciitilde{}>} \DataTypeTok{Day}\NormalTok{ f g}
\NormalTok{pureT }\OperatorTok{@}\DataTypeTok{Day}\OtherTok{ ::} \DataTypeTok{Applicative}\NormalTok{ h }\OtherTok{=>} \DataTypeTok{Identity} \OperatorTok{\textasciitilde{}>}\NormalTok{ h}
\end{Highlighting}
\end{Shaded}

  \texttt{Apply}, from
  \emph{\href{https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Apply.html}{Data.Functor.Apply}}
  in \emph{semigroupoids}, is ``\texttt{Applicative} without \texttt{pure}''; it
  only has \texttt{\textless{}*\textgreater{}} (called
  \texttt{\textless{}.\textgreater{}}).

  \texttt{pureT} is essentially
  \texttt{pure\ ::\ Applicative\ h\ =\textgreater{}\ a\ -\textgreater{}\ h\ a}.
\item
  \textbf{Induced Monoid}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{SF} \DataTypeTok{Day} \OtherTok{=} \DataTypeTok{Ap1}
\KeywordTok{type} \DataTypeTok{MF} \DataTypeTok{Day} \OtherTok{=} \DataTypeTok{Ap}
\end{Highlighting}
\end{Shaded}

  \texttt{Ap\ f\ a} is a bunch of \texttt{f\ x}s \texttt{Day}d with each other.
  It is either:

  \begin{itemize}
  \tightlist
  \item
    \texttt{a} (zero \texttt{f}s)
  \item
    \texttt{f\ a} (one \texttt{f})
  \item
    \texttt{Day\ f\ f\ a} (two \texttt{f}s)
  \item
    \texttt{Day\ f\ (Day\ f\ f)\ a} (three \texttt{f}s)
  \item
    .. etc.
  \end{itemize}

  Like \texttt{ListF} this is very useful if you want your schema to provide a
  ``bag'' of \texttt{f\ a}s and your interpreter \emph{must use all of them}.

  For example, if we have a schema for a command line argument parser, each
  \texttt{f} may represent a command line option. To interpret it, we must look
  at \emph{all} command line options.

  \texttt{Ap1} is a version with ``at least one'' \texttt{f\ a}.

  Incidentally, \texttt{Ap1} is the ``free \texttt{Apply}'' (it gives a functor
  \texttt{Apply}-ness, and nothing more), and \texttt{Ap} is the ``free
  \texttt{Applicative}'' (it gives a functor \texttt{Applicative}-ness, and
  nothing more).
\end{itemize}

\hypertarget{comp}{%
\subsubsection{Comp}\label{comp}}

\begin{itemize}
\item
  \textbf{Origin}:
  \emph{\href{https://hackage.haskell.org/package/functor-combinators/docs/Control-Monad-Freer-Church.html}{Control.Monad.Freer.Church}}.
  Note that an equivalent type is also found in
  \emph{\href{https://hackage.haskell.org/package/base/docs/GHC-Generics.html}{GHC.Generics}}
  and
  \emph{\href{https://hackage.haskell.org/package/base/docs/Data-Functor-Compose.html}{Data.Functor.Compose}},
  but they are incompatible with the \texttt{HBifunctor} typeclass because they
  require the second input to have a \texttt{Functor} instance.
\item
  \textbf{Mixing Strategy}: ``Both, together, sequentially'' : provide values
  from \emph{both} functors; the user must \emph{use} both, and \emph{in order}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Comp}\NormalTok{ f g a }\OtherTok{=} \DataTypeTok{Comp}\NormalTok{ (f (g a))}
\end{Highlighting}
\end{Shaded}

  It can be useful for situations where your schema/functor must be specified
  using both functors, and the user must \emph{use} both, but also enforcing
  that they must use both in the \emph{given order}: that is, for a
  \texttt{Comp\ f\ g}, they interpret \texttt{f} \emph{before} they interpret
  \texttt{g}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binterpret }\OperatorTok{@}\DataTypeTok{Day}
\OtherTok{    ::} \DataTypeTok{Bind}\NormalTok{ h          }\CommentTok{{-}{-} superclass of Monad}
    \OtherTok{=>}\NormalTok{ (f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{{-}>}\NormalTok{ (g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{{-}>} \DataTypeTok{Comp}\NormalTok{ f g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
\end{Highlighting}
\end{Shaded}

  Unlike for \texttt{:*:}, you always have to interpret \emph{both} functor
  values. And, unlike for \texttt{Day}, you must interpret both functor values
  \emph{in that order}.
\item
  \textbf{Identity}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{I} \DataTypeTok{Comp} \OtherTok{=} \DataTypeTok{Identity}
\end{Highlighting}
\end{Shaded}

  \texttt{Comp\ f\ Identity} is equivalent to just \texttt{f}, because
  \texttt{Identity} adds no extra effects or structure.
\item
  \textbf{Constraints}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{CS} \DataTypeTok{Comp} \OtherTok{=} \DataTypeTok{Bind}
\KeywordTok{type} \DataTypeTok{CM} \DataTypeTok{Comp} \OtherTok{=} \DataTypeTok{Monad}

\NormalTok{binterpret }\OperatorTok{@}\DataTypeTok{Comp}
\OtherTok{    ::} \DataTypeTok{Bind}\NormalTok{ h}
    \OtherTok{=>}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
    \OtherTok{{-}>}\NormalTok{ g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
    \OtherTok{{-}>} \DataTypeTok{Comp}\NormalTok{ f g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}

\NormalTok{inL   }\OperatorTok{@}\DataTypeTok{Comp}\OtherTok{ ::} \DataTypeTok{Monad}\NormalTok{ g }\OtherTok{=>}\NormalTok{ f        }\OperatorTok{\textasciitilde{}>} \DataTypeTok{Comp}\NormalTok{ f g}
\NormalTok{inR   }\OperatorTok{@}\DataTypeTok{Comp}\OtherTok{ ::} \DataTypeTok{Monad}\NormalTok{ f }\OtherTok{=>}\NormalTok{ g        }\OperatorTok{\textasciitilde{}>} \DataTypeTok{Comp}\NormalTok{ f g}
\NormalTok{pureT }\OperatorTok{@}\DataTypeTok{Comp}\OtherTok{ ::} \DataTypeTok{Monad}\NormalTok{ h }\OtherTok{=>} \DataTypeTok{Identity} \OperatorTok{\textasciitilde{}>}\NormalTok{ h}
\end{Highlighting}
\end{Shaded}

  \texttt{Bind}, from \emph{semigroupoids}, is ``\texttt{Monad} without
  \texttt{return}''; it only has \texttt{\textgreater{}\textgreater{}=} (called
  \texttt{\textgreater{}\textgreater{}-}).

  Somewhat serendipitously, the \texttt{CM} constraint associated with
  \texttt{Comp} is the infamous \texttt{Monad}. Hopefully this insight also
  gives you some insight on the nature of \texttt{Monad} as an abstraction: it's
  a way to ``interpret'' in and out of \texttt{Comp} :)
\item
  \textbf{Induced Monoid}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{SF} \DataTypeTok{Day} \OtherTok{=} \DataTypeTok{Free1}
\KeywordTok{type} \DataTypeTok{MF} \DataTypeTok{Day} \OtherTok{=} \DataTypeTok{Free}
\end{Highlighting}
\end{Shaded}

  \texttt{Free\ f\ a} is a bunch of \texttt{f\ x}s composed with each other. It
  is either:

  \begin{itemize}
  \tightlist
  \item
    \texttt{a} (zero \texttt{f}s)
  \item
    \texttt{f\ a} (one \texttt{f})
  \item
    \texttt{f\ (f\ a)} (two \texttt{f}s)
  \item
    \texttt{f\ (f\ (f\ a))} (three \texttt{f}s)
  \item
    .. etc.
  \end{itemize}

  \texttt{Free} is very useful because it allows you to specify that your schema
  can have many \texttt{f}s, sequenced one after the other, in which the
  \emph{choice} of ``the next \texttt{f}'' is allowed to depend on the
  \emph{result} of ``the previous \texttt{f}''.

  For example, in an interactive ``wizard'' sort of schema, where \texttt{f}
  represents a wizard dialog box, we can represent our wizard using
  \texttt{Free\ f\ a} --- an ordered sequence of dialog boxes, where the choice
  of the next box can depend on result of the previous box.

  \texttt{Free1} is a version with ``at least one'' \texttt{f\ a}.

  Incidentally, \texttt{Free1} is the ``free \texttt{Bind}'' (it gives a functor
  \texttt{Bind}-ness, and nothing more), and \texttt{Free} is the ``free
  \texttt{Monad}'' (it gives a functor \texttt{Monad}-ness, and nothing more).
\end{itemize}

\hypertarget{these1}{%
\subsubsection{These1}\label{these1}}

\begin{itemize}
\item
  \textbf{Origin}:
  \emph{\href{https://hackage.haskell.org/package/these/docs/Data-Functor-These.html}{Data.Functor.These}}.
\item
  \textbf{Mixing Strategy}: ``Either-or, or both'': provide either (or both)
  cases, and user has to handle both possibilities. An ``inclusive either''

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{These1}\NormalTok{ f g a}
    \OtherTok{=} \DataTypeTok{This1}\NormalTok{  (f a)}
    \OperatorTok{|} \DataTypeTok{That1}\NormalTok{        (g a)}
    \OperatorTok{|} \DataTypeTok{These1}\NormalTok{ (f a) (g a)}
\end{Highlighting}
\end{Shaded}

  This can be useful for situations where your schema/functor can be specified
  using one functor or another, or even both. See description on \texttt{:+:}
  for examples.

  The person who creates the \texttt{These1\ f\ g} decides which one to give,
  and the person who consumes/interprets/runs the \texttt{f\ :+:\ g} must
  provide a way of handling \emph{both} situations.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binterpret }\OperatorTok{@}\DataTypeTok{These}
\OtherTok{    ::} \DataTypeTok{Alt}\NormalTok{ h}
    \OtherTok{=>}\NormalTok{ (f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{{-}>}\NormalTok{ (g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h)}
    \OtherTok{{-}>} \DataTypeTok{These}\NormalTok{ f g a}
    \OtherTok{{-}>}\NormalTok{ h a}
\end{Highlighting}
\end{Shaded}

  You can also pattern match on the \texttt{These1} directly to be more explicit
  with how you handle each of the tree cases.
\item
  \textbf{Identity}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{I} \DataTypeTok{These1} \OtherTok{=} \DataTypeTok{Void}
\end{Highlighting}
\end{Shaded}

  \texttt{These1\ f\ Void} is equivalent to just \texttt{f}, because it means
  the \texttt{That1} and \texttt{These1} branches will be impossible to
  construct, and you are left with only the \texttt{This1} branch.
\item
  \textbf{Constraints}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{CS} \DataTypeTok{These1} \OtherTok{=} \DataTypeTok{Alt}
\KeywordTok{type} \DataTypeTok{CM} \DataTypeTok{These1} \OtherTok{=} \DataTypeTok{Alt}

\NormalTok{binterpret }\OperatorTok{@}\DataTypeTok{These1}
\OtherTok{    ::} \DataTypeTok{Alt}\NormalTok{ h}
    \OtherTok{=>}\NormalTok{ f }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
    \OtherTok{{-}>}\NormalTok{ g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}
    \OtherTok{{-}>} \DataTypeTok{These1}\NormalTok{ f g }\OperatorTok{\textasciitilde{}>}\NormalTok{ h}

\NormalTok{inL   }\OperatorTok{@}\DataTypeTok{These1}\OtherTok{ ::} \DataTypeTok{Alt}\NormalTok{ g }\OtherTok{=>}\NormalTok{ f     }\OperatorTok{\textasciitilde{}>} \DataTypeTok{Comp}\NormalTok{ f g}
\NormalTok{inR   }\OperatorTok{@}\DataTypeTok{These1}\OtherTok{ ::} \DataTypeTok{Alt}\NormalTok{ f }\OtherTok{=>}\NormalTok{ g     }\OperatorTok{\textasciitilde{}>} \DataTypeTok{Comp}\NormalTok{ f g}
\NormalTok{pureT }\OperatorTok{@}\DataTypeTok{These1}\OtherTok{ ::} \DataTypeTok{Alt}\NormalTok{ h }\OtherTok{=>} \DataTypeTok{Void1} \OperatorTok{\textasciitilde{}>}\NormalTok{ h}
\end{Highlighting}
\end{Shaded}

  You need at least \texttt{Alt} to be able to interpret out of a
  \texttt{These1}, because you need to be able to handle the case where you have
  \emph{both} \texttt{f} and \texttt{g}, and need to combine the result.
  However, you never need a full \texttt{Plus} because we always have at least
  one value to use.
\item
  \textbf{Induced Monoid}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{MF} \DataTypeTok{These1} \OtherTok{=} \DataTypeTok{Steps}
\end{Highlighting}
\end{Shaded}

  \texttt{Steps}, the induced monoidal functor combinator, is the result of an
  infinite application of `These1 to the same value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Steps}\NormalTok{ f }\OtherTok{=}\NormalTok{ f }\OtherTok{\textasciigrave{}These1\textasciigrave{}}\NormalTok{ f }\OtherTok{\textasciigrave{}These1\textasciigrave{}}\NormalTok{ f }\OtherTok{\textasciigrave{}These1\textasciigrave{}}\NormalTok{ f }\OtherTok{\textasciigrave{}These1\textasciigrave{}} \OperatorTok{...}\NormalTok{ etc}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

  It essentially represents an infinite \emph{sparse} array of \texttt{f\ a}s,
  where an \texttt{f\ a} might exist at many different positions, with gaps here
  and there. There is always at least \emph{one} \texttt{f\ a}.

  Like \texttt{Step}, it's not particularly useful, but it can be used in
  situations where you want a giant infinite sparse array of \texttt{f\ a}s,
  each at a given position, with many gaps between them.

  I've skipped over the the induced semigroupoidal functor, which is
  \texttt{ComposeT\ Flagged\ Steps}; it requires an extra boolean ``flag''
  because of some of the quirks of nonemptiness. I feel it is even less useful
  than \texttt{Steps}.
\end{itemize}

\hypertarget{leftf-rightf}{%
\subsubsection{LeftF / RightF}\label{leftf-rightf}}

\begin{itemize}
\item
  \textbf{Origin}:
  \emph{\href{https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html}{Data.HBifunctor}}
  (for \texttt{LeftF} and \texttt{RightF})
\item
  \textbf{Mixing Strategy}: ``Ignore the left'' / ``ignore the right''.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{LeftF}\NormalTok{  f g a }\OtherTok{=} \DataTypeTok{LeftF}\NormalTok{  \{}\OtherTok{ runLeftF  ::}\NormalTok{ f a \}}

\KeywordTok{data} \DataTypeTok{RightF}\NormalTok{ f g a }\OtherTok{=} \DataTypeTok{RightF}\NormalTok{ \{}\OtherTok{ runRightF ::}\NormalTok{ g a \}}
\end{Highlighting}
\end{Shaded}

  You can think of \texttt{LeftF} as ``\texttt{:+:} without the Right case,
  \texttt{R1}'', or \texttt{RightF} as ``\texttt{:+:} without the Left case,
  \texttt{L1}''. \texttt{RightF} can be considered a higher-order version of
  \emph{Tagged}, which ``tags'' a value with some type-level information.

  This can be useful if you want the second (or first) argument to be ignored,
  and only be used maybe at the type level.

  For example, \texttt{RightF\ IgnoreMe\ MyFunctor} is equivalent to just
  \texttt{MyFunctor}, but you might want to use \texttt{IgnoreMe} as a phantom
  type to help limit what values can be used for what functions.
\item
  \textbf{Identity}

  Unlike the previous functor combinators, these three are only
  \texttt{Semigroupoidal}, not \texttt{Monoidal}: this is because there is no
  functor \texttt{i} such that \texttt{LeftF\ i\ g} is equal to \texttt{g}, for
  all \texttt{g}, and no functor \texttt{i} such that \texttt{RightF\ f\ i} is
  equal to \texttt{f}, for all \texttt{f}.
\item
  \textbf{Constraints}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{CS} \DataTypeTok{LeftF}  \OtherTok{=} \DataTypeTok{Unconstrained}
\KeywordTok{type} \DataTypeTok{CS} \DataTypeTok{RightF} \OtherTok{=} \DataTypeTok{Unconstrained}
\end{Highlighting}
\end{Shaded}

  Interpreting out of either of these is unconstrained, and can be done in any
  context.
\item
  \textbf{Induced Semigroup}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{SF} \DataTypeTok{LeftF} \OtherTok{=} \DataTypeTok{Flagged}
\end{Highlighting}
\end{Shaded}

  For \texttt{LeftF}, the induced semigroup is \texttt{Flagged}, which is the
  \texttt{f\ a} tupled with a \texttt{Bool}. See the information on
  \texttt{Flagged} for more details. This can be useful as a type that marks if
  an \texttt{f} is made with \texttt{inject}/\texttt{pure} and is ``pure''
  (\texttt{False}), or ``tainted'' (\texttt{True}). The \emph{provider} of an
  \texttt{EnvT\ Any\ f} can specify ``pure or tainted'', and the
  \emph{interpreter} can make a decision based on that tag.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{SF} \DataTypeTok{RightF} \OtherTok{=} \DataTypeTok{Step}
\end{Highlighting}
\end{Shaded}

  For \texttt{RightF}, the induced semigroup is \texttt{Step}. See \texttt{Step}
  and the information on \texttt{:+:} for more details. This can be useful for
  having a value of \texttt{f\ a} at ``some point'', indexed by a
  \texttt{Natural}.
\end{itemize}

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
