\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={The Functor Combinatorpedia},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{The Functor Combinatorpedia}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/functor-combinatorpedia.html}{in
Code}}.}

Recently I've been very productive what I have been calling the ``Functor
Combinator'' design pattern. It is heavily influenced by ideas like
\href{http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf}{Data
types a la Carte} and
\href{http://oleg.fi/gists/posts/2018-02-21-single-free.html}{unified free
monoidal functors}, but the end goal is slightly different in spirit.

The goal is to represent schemas, DSL's, and computations (things like parsers,
things to execute, things to consume or produce data) by assembling
``self-evident'' basic primitives and subjecting them to many \emph{different}
successive transformations and combiners. The process of doing so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forces you to make explicit decisions about the structure of your computation
  type as an ADT.
\item
  Allows you to retain isolation of fundamental parts of your domain as separate
  types
\item
  Lets you manipulate the structure of your final computation type through
  \emph{normal Haskell techniques} like pattern matching. The structure is
  available throughout the entire process, so you can replace individual
  components and values within your structure.
\item
  Allows you to fully \emph{reflect} the structure of your final computation
  through pattern matching and folds, so you can inspect the structure and
  produce useful summaries.
\end{enumerate}

Like ``data types a la carte'' and free monad/applicative/alternative designs,
these techniques allow you to separate the assembly and inspection of your
programs from the ``running'' of them. However, the main difference is that here
we focus not just on products and sums, but many different varied and
multi-purpose combinators --- a bona fide ``zoo'' of combinators. So, this
focuses less on ``fixed-points'' like \texttt{Free}, \texttt{Ap}, \texttt{Alt},
and more on non-recursive simple building blocks\ldots where recursive
combinators like \texttt{Free} might be used along the way. The \emph{functor
itself} is the goal, \emph{not} its fixed point.

This post also serves as an overview of the
\emph{\href{https://hackage.haskell.org/package/functor-combinators}{functor-combinators}}
library, which mostly pulls together all of the functor combinators scattered
across the Haskell ecosystem and provides a unified interface for working with
them, which will help us talk about all of them with the same vocabulary.

\hypertarget{prologue-what-is-a-functor-combinator}{%
\section{Prologue: What is a functor
combinator?}\label{prologue-what-is-a-functor-combinator}}

A functor combinator takes ``functors'' (or other indexed types) and returns a
new functor, enhances or mixes them together in some way.

That is, they take things of kind \texttt{k\ -\textgreater{}\ Type} and
themselves return a \texttt{k\ -\textgreater{}\ Type}.

This lets us build complex functors out of simpler ``primitive'' ones.

For example, \texttt{ReaderT\ r} is a famous one that takes a functor \texttt{f}
and enhances it with ``access to an \texttt{r} environment'' functionality.

Another famous one is \texttt{Free}, which takes a functor \texttt{f} and
enhances it with ``sequential binding'' capabilities: it turns \texttt{f} into a
\texttt{Monad}.

Sometimes, we have binary functor combinators, like \texttt{:+:}, which takes
two functors \texttt{f} and \texttt{g} and returns a functor that is ``either''
\texttt{f} or \texttt{g}. Binary functor combinators ``mix together'' the
functionality of different functors in different ways.

\hypertarget{examples}{%
\subsection{Examples}\label{examples}}

If your final DSL/program/schema is some functor, then functor combinators allow
you to construct your final functor by combining simpler ``primitive'' functors,
and take advantage of common functionality.

For example, if you were making a data type/EDSL to describe a command line
parser, you might have two primitives: \texttt{data\ Arg\ a}, for positional
arguments parsing \texttt{a}, and \texttt{data\ Option\ a}, for
\texttt{-\/-flag} non-positional options parsing \texttt{a}. From there, you can
\emph{choose} what structure of command line arguments you want to be able to
express.

For instance, a structure that can support multiple arguments and optionally a
single \texttt{Option} would be:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{CommandArgs} \OtherTok{=} \DataTypeTok{Ap} \DataTypeTok{Arg} \OperatorTok{:*:} \DataTypeTok{Lift} \DataTypeTok{Option}
\end{Highlighting}
\end{Shaded}

And a structure that supports \emph{multiple commands} on top of that would be:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{CommandArgs} \OtherTok{=} \DataTypeTok{MapF} \DataTypeTok{String}\NormalTok{ (}\DataTypeTok{Ap} \DataTypeTok{Arg} \OperatorTok{:*:} \DataTypeTok{Lift} \DataTypeTok{Option}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can mix or match combinators to decide exactly what sort of structures you
allow in your DSL.

\hypertarget{common-functionality}{%
\subsection{Common Functionality}\label{common-functionality}}

Most of these functor combinators allow us to ``swap out'' the underlying
functor, retaining all of the ``enhanced'' structure. We abstract over all of
these using \texttt{hmap} for single-argument functor combinators
(``enhancers'') and \texttt{hbimap} for two-argument functor combinators
(``mixers'').

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{HFunctor}\NormalTok{ t }\KeywordTok{where}
    \CommentTok{-- | Swap out underlying functor for a single-argument functor combinator}
\NormalTok{    hmap}
\OtherTok{        ::}\NormalTok{ t f a }\OtherTok{->}\NormalTok{ t g a}

\KeywordTok{class} \DataTypeTok{HBifunctor}\NormalTok{ t }\KeywordTok{where}
    \CommentTok{-- | Swap out underlying functors for a two-argument functor combinator}
\NormalTok{    hbimap}
\OtherTok{        ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{->}\NormalTok{ h x)}
        \OtherTok{->}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ g x }\OtherTok{->}\NormalTok{ j x)}
        \OtherTok{->}\NormalTok{ t f g a}
        \OtherTok{->}\NormalTok{ t g j a}
\end{Highlighting}
\end{Shaded}

However, for this post, the concept of a ``natural transformation'' between
\texttt{f} and \texttt{g} --- a function of type
\texttt{forall\ x.\ f\ x\ -\textgreater{}\ g\ x}, is given a type synonym:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ f }\OperatorTok{~>}\NormalTok{ g }\OtherTok{=} \KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{->}\NormalTok{ g x}
\end{Highlighting}
\end{Shaded}

Then the type signatures of \texttt{hmap} and \texttt{hbimap} become:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{HFunctor}\NormalTok{ t }\KeywordTok{where}
\NormalTok{    hmap}
\OtherTok{        ::}\NormalTok{ t f }\OperatorTok{~>}\NormalTok{ t g}

\KeywordTok{class} \DataTypeTok{HBifunctor}\NormalTok{ t }\KeywordTok{where}
\NormalTok{    hbimap}
\OtherTok{        ::}\NormalTok{ f }\OperatorTok{~>}\NormalTok{ h}
        \OtherTok{->}\NormalTok{ g }\OperatorTok{~>}\NormalTok{ j}
        \OtherTok{->}\NormalTok{ t f g }\OperatorTok{~>}\NormalTok{ t h j}
\end{Highlighting}
\end{Shaded}

What does it mean exactly when we say that \texttt{hmap} and \texttt{hbimap}
``preserve the enhanced structure''? Well, for example, \texttt{ListF\ f\ a} is
essentially a list of \texttt{f\ a}s. \texttt{hmap} will swap out and replace
each \texttt{f\ a}, but it must \emph{preserve the relative order} between each
of the original \texttt{f\ a}s. And it must preserve the length of the list.
It's a complete ``in-place swap''. This is formalizing by requiring
\texttt{hmap\ id\ ==\ id} and \texttt{hbimap\ id\ id\ ==\ id}.

You can also always ``lift'' a functor value into its transformed type. We
abstract over this by using \texttt{inject} (for single-argument functors) and
\texttt{inL} and \texttt{inR} (for two-argument functors):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Inject}\NormalTok{ t }\KeywordTok{where}
    \CommentTok{-- | Lift `f` into `t f`}
\OtherTok{    inject ::}\NormalTok{ f }\OperatorTok{~>}\NormalTok{ t f}

\OtherTok{inL ::}\NormalTok{ (}\DataTypeTok{Monoidal}\NormalTok{ t, }\DataTypeTok{CM}\NormalTok{ t g)     }\CommentTok{-- more on the `CM t` later}
    \OtherTok{=>}\NormalTok{ f }\OperatorTok{~>}\NormalTok{ t f g}

\OtherTok{inR ::}\NormalTok{ (}\DataTypeTok{Monoidal}\NormalTok{ t, }\DataTypeTok{CM}\NormalTok{ t f)     }\CommentTok{-- more on the `CM t` later}
    \OtherTok{=>}\NormalTok{ g }\OperatorTok{~>}\NormalTok{ t f g}
\end{Highlighting}
\end{Shaded}

Finally, in order to \emph{use} any functor combinators, you have to
\emph{interpret} them into some target context. The choice of combinator imposes
some constraints on the target context. We abstract over this using
\texttt{interpret} and \texttt{binterpret}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Interpret}\NormalTok{ t }\KeywordTok{where}
    \KeywordTok{type} \DataTypeTok{C}\OtherTok{ t ::}\NormalTok{ (}\DataTypeTok{Type} \OtherTok{->} \DataTypeTok{Type}\NormalTok{) }\OtherTok{->} \DataTypeTok{Constraint}

    \CommentTok{-- | Interpret unary functor combinator}
\NormalTok{    interpret}
\OtherTok{        ::} \DataTypeTok{C}\NormalTok{ t g}
        \OtherTok{=>}\NormalTok{ f }\OperatorTok{~>}\NormalTok{ g             }\CommentTok{-- ^ interpreting function}
        \OtherTok{->}\NormalTok{ t f }\OperatorTok{~>}\NormalTok{ g}

\KeywordTok{instance} \DataTypeTok{Semigroupoidal}\NormalTok{ t }\KeywordTok{where}
    \CommentTok{-- | Interpret binary functor combinator}
\NormalTok{    binterpret}
\OtherTok{        ::}\NormalTok{ (}\DataTypeTok{Semigroupoidal}\NormalTok{ t, }\DataTypeTok{CS}\NormalTok{ t h)}
        \OtherTok{=>}\NormalTok{ f }\OperatorTok{~>}\NormalTok{ h             }\CommentTok{-- ^ interpreting function on f}
        \OtherTok{=>}\NormalTok{ g }\OperatorTok{~>}\NormalTok{ h             }\CommentTok{-- ^ interpreting function on g}
        \OtherTok{->}\NormalTok{ t f g }\OperatorTok{~>}\NormalTok{ h}
\end{Highlighting}
\end{Shaded}

Each functor combinator defines a constraint (\texttt{C} for unary functor
combinators, and \texttt{CS} and \texttt{CM} for binary functor combinators)
that allows you to ``exit'', or ``run'' the functor combinator.

For some concrete examples:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{C}\NormalTok{ (}\DataTypeTok{ReaderT}\NormalTok{ r) }\OtherTok{=} \DataTypeTok{MonadReader}\NormalTok{ r}

\NormalTok{interpret }\OperatorTok{@}\NormalTok{(}\DataTypeTok{MonadReader}\NormalTok{ r)}
\OtherTok{    ::} \DataTypeTok{MonadReader}\NormalTok{ r g}
    \OtherTok{=>}\NormalTok{ (f }\OperatorTok{~>}\NormalTok{ g)}
    \OtherTok{->} \DataTypeTok{ReaderT}\NormalTok{ r f a}
    \OtherTok{->}\NormalTok{ g a}

\KeywordTok{type} \DataTypeTok{C} \DataTypeTok{Free} \OtherTok{=} \DataTypeTok{Monad}

\NormalTok{interpret }\OperatorTok{@}\DataTypeTok{Free}
\OtherTok{    ::} \DataTypeTok{Monad}\NormalTok{ g}
    \OtherTok{=>}\NormalTok{ (f }\OperatorTok{~>}\NormalTok{ g)}
    \OtherTok{->} \DataTypeTok{Free}\NormalTok{ f a}
    \OtherTok{->}\NormalTok{ g a}

\KeywordTok{type} \DataTypeTok{CM}\NormalTok{ (}\OperatorTok{:+:}\NormalTok{) }\OtherTok{=} \DataTypeTok{Unconstrained}   \CommentTok{-- no constraints on exiting}

\NormalTok{binterpret }\OperatorTok{@}\NormalTok{(}\OperatorTok{:+:}\NormalTok{)}
\OtherTok{    ::}\NormalTok{ (f }\OperatorTok{~>}\NormalTok{ h)}
    \OtherTok{->}\NormalTok{ (g }\OperatorTok{~>}\NormalTok{ h)}
    \OtherTok{->}\NormalTok{ (f }\OperatorTok{:+:}\NormalTok{ g) a}
    \OtherTok{->}\NormalTok{ h a}
\end{Highlighting}
\end{Shaded}

We see that \texttt{interpret} lets you ``run'' a \texttt{ReaderT\ r\ f} into
any \texttt{MonadReader\ r\ g} and ``run'' a \texttt{Free} in any monad
\texttt{g}, and \texttt{binterpret} lets you ``run'' a function over both
branches of an \texttt{f\ :+:\ g} to produce an \texttt{h}.

From these, we can build a lot of useful utility functions (like
\texttt{retract}, \texttt{biretract}, \texttt{getI}, \texttt{biget}, etc.) for
convenience in actually working on them. These are provided in
\emph{\href{https://hackage.haskell.org/package/functor-combinators}{functor-combinators}}.

Without further ado, let's dive into the zoo of functor combinators!

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
