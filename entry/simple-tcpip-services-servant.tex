\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Dead-simple TCP/IP services using servant},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Dead-simple TCP/IP services using servant}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/simple-tcpip-services-servant.html}{in
Code}}.}

In my time I've written a lot of throwaway binary TCP/IP services (servers and
services you can interact with over an internet connection, through command line
interface or GUI). For me, this involves designing a protocol from scratch every
time with varying levels of hand-rolled authentication and error detection (Send
this byte for this command, this byte for this other command, etc.). Once I
design the protocol, I then have to write both the client and the server ---
something I usually do from scratch over the raw TCP streams.

This process was fun (and informative) the first few times I did it, but
spinning it up from scratch again every time discouraged me from doing it very
often. However, thankfully, with the
\emph{\href{https://hackage.haskell.org/package/servant}{servant}} haskell
library, writing a TCP server/client pair for a TCP service becomes dead-simple
--- the barrier for creating one fades away that designing/writing a service
becomes a tool that I reach for immediately in a lot of cases without second
thought.

\emph{servant} is usually advertised as a tool for writing web servers, web
applications, and REST APIs, but it's easily adapted to write non-web things as
well (especially with the help of
\emph{\href{https://hackage.haskell.org/package/servant-client}{servant-client}}
and \emph{\href{https://hackage.haskell.org/package/servant-cli}{servant-cli}}).
Let's dive in and write a simple TCP/IP service (a todo list manager) to see how
straightforward the process is!

\hypertarget{todo-api}{%
\section{Todo API}\label{todo-api}}

As an example, we'll work through building one of my favorite self-contained
mini-app projects, a \href{http://todomvc.com/}{Todo list manager a la
todo-mvc}. Our service will provide functionality for:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Viewing all tasks and their status
\item
  Adding a new task
\item
  Setting a task's completion status
\item
  Deleting a task
\item
  Pruning all completed tasks
\end{enumerate}

To facilitate doing this over an API, we'll assign each task a task ID when it
comes in, and so commands 3 and 4 will require a task ID.

To formally specify our API:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{list}: View all tasks by their ID, status, and description. Optionally
  be able to filter for only incomplete tasks.
\item
  \texttt{add}: Given a new task description, insert a new uncompleted task.
  Return the ID of the new task.
\item
  \texttt{set}: Given a task ID and an updated status, update the task's status.
\item
  \texttt{delete}: Given a task ID, delete the task.
\item
  \texttt{prune}: Remove all completed tasks. Returns all the task IDs that
  where deleted.
\end{enumerate}

We can state this using servant's type level DSL, using an \texttt{IntMap} to
represent the current tasks and an \texttt{IntSet} to represent a set of task
IDs.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/servant{-}services/Api.hs}

\OtherTok{\{{-}\# LANGUAGE DeriveGeneric \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE TypeInType    \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE TypeOperators \#{-}\}}

\KeywordTok{module} \DataTypeTok{Api} \KeywordTok{where}

\KeywordTok{import}           \DataTypeTok{Data.Aeson}
\KeywordTok{import}           \DataTypeTok{Data.IntMap}\NormalTok{ (}\DataTypeTok{IntMap}\NormalTok{)}
\KeywordTok{import}           \DataTypeTok{Data.IntSet}\NormalTok{ (}\DataTypeTok{IntSet}\NormalTok{)}
\KeywordTok{import}           \DataTypeTok{Data.Proxy}
\KeywordTok{import}           \DataTypeTok{Data.Text}\NormalTok{ (}\DataTypeTok{Text}\NormalTok{)}
\KeywordTok{import}           \DataTypeTok{GHC.Generics}
\KeywordTok{import}           \DataTypeTok{Servant.API}

\KeywordTok{data} \DataTypeTok{Task} \OtherTok{=} \DataTypeTok{Task}
\NormalTok{    \{}\OtherTok{ taskStatus ::} \DataTypeTok{Bool}
\NormalTok{    ,}\OtherTok{ taskDesc   ::} \DataTypeTok{Text}
\NormalTok{    \}}
  \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Show}\NormalTok{, }\DataTypeTok{Generic}\NormalTok{)}
\KeywordTok{instance} \DataTypeTok{ToJSON}   \DataTypeTok{Task}
\KeywordTok{instance} \DataTypeTok{FromJSON} \DataTypeTok{Task}

\KeywordTok{type} \DataTypeTok{TodoApi} \OtherTok{=} \StringTok{"list"}   \OperatorTok{:>} \DataTypeTok{QueryFlag} \StringTok{"filtered"}
                        \OperatorTok{:>} \DataTypeTok{Get}\NormalTok{  \textquotesingle{}[}\DataTypeTok{JSON}\NormalTok{] (}\DataTypeTok{IntMap} \DataTypeTok{Task}\NormalTok{)}
          \OperatorTok{:<|>} \StringTok{"add"}    \OperatorTok{:>} \DataTypeTok{QueryParam\textquotesingle{}}\NormalTok{ \textquotesingle{}[}\DataTypeTok{Required}\NormalTok{] }\StringTok{"desc"} \DataTypeTok{Text}
                        \OperatorTok{:>} \DataTypeTok{Post}\NormalTok{ \textquotesingle{}[}\DataTypeTok{JSON}\NormalTok{] }\DataTypeTok{Int}
          \OperatorTok{:<|>} \StringTok{"set"}    \OperatorTok{:>} \DataTypeTok{Capture} \StringTok{"id"} \DataTypeTok{Int}
                        \OperatorTok{:>} \DataTypeTok{QueryParam} \StringTok{"completed"} \DataTypeTok{Bool}
                        \OperatorTok{:>} \DataTypeTok{Post}\NormalTok{ \textquotesingle{}[}\DataTypeTok{JSON}\NormalTok{] ()}
          \OperatorTok{:<|>} \StringTok{"delete"} \OperatorTok{:>} \DataTypeTok{Capture} \StringTok{"id"} \DataTypeTok{Int}
                        \OperatorTok{:>} \DataTypeTok{Post}\NormalTok{ \textquotesingle{}[}\DataTypeTok{JSON}\NormalTok{] ()}
          \OperatorTok{:<|>} \StringTok{"prune"}  \OperatorTok{:>} \DataTypeTok{Post}\NormalTok{ \textquotesingle{}[}\DataTypeTok{JSON}\NormalTok{] }\DataTypeTok{IntSet}

\OtherTok{todoApi ::} \DataTypeTok{Proxy} \DataTypeTok{TodoApi}
\NormalTok{todoApi }\OtherTok{=} \DataTypeTok{Proxy}
\end{Highlighting}
\end{Shaded}

We have five routes, which more or less mirror exactly the five bullet points
listed above, with some minor implementation choices:

\begin{itemize}
\tightlist
\item
  For \texttt{list}, we take ``filtered or not filtered'' as a query flag, and
  return an \texttt{IntMap} of a \texttt{Task} data type (status, description)
  under their integer ID key.
\item
  For \texttt{add}, we take the task description as a query parameter, and
  return the new ID.
\item
  For \texttt{set}, we take the task ID as a capture (path component) and an
  optional boolean query parameter. If the parameter is not given, it will be
  taken as a toggle; otherwise, it will be taken as a setting of the completion
  status.
\item
  For \texttt{delete}, we also take the task ID as a capture.
\end{itemize}

``Query flag'', ``query parameter'', ``capture'' are all a part of the language
of HTTP and W3C. In our case, since we aren't ever directly programming against
the actual protocol-HTTP (it's only used under the hood) or pretending to write
an actual web-interfacing server, we don't really need to care too much to
distinguish them. However, it can be useful to pick meaningful choices if we
ever do want to expose this API as a web service.

\hypertarget{todo-service-server}{%
\section{Todo Service Server}\label{todo-service-server}}

The logic to implement a todo server is pretty straightforward, which is why we
chose it as an example project. It only really needs one state: the
\texttt{IntMap} of current tasks.

To write a servant server with
\emph{\href{https://hackage.haskell.org/package/servant-server}{servant-server}},
I usually like to just set up a skeleton with each route:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{serveTodoApi ::} \DataTypeTok{IORef}\NormalTok{ (}\DataTypeTok{IntMap} \DataTypeTok{Task}\NormalTok{) }\OtherTok{{-}>} \DataTypeTok{Server} \DataTypeTok{TodoApi}
\NormalTok{serveTodoApi taskRef }\OtherTok{=}\NormalTok{ serveList}
                  \OperatorTok{:<|>}\NormalTok{ serveAdd}
                  \OperatorTok{:<|>}\NormalTok{ serveSet}
                  \OperatorTok{:<|>}\NormalTok{ serveDelete}
                  \OperatorTok{:<|>}\NormalTok{ servePrune}
\end{Highlighting}
\end{Shaded}

The corresponding ghc error tells us everything we need:

\begin{verbatim}
server.hs:15:24: error:
    Variable not in scope: serveList :: Bool -> Handler (IntMap Task)
   |
15 | serveTodoApi taskRef = serveList
   |                        ^^^^^^^^^

server.hs:16:24: error:
    Variable not in scope: serveAdd :: Text -> Handler Int
   |
16 |                   :<|> serveAdd
   |                        ^^^^^^^^

server.hs:17:24: error:
    Variable not in scope: serveSet :: Int -> Maybe Bool -> Handler ()
   |
17 |                   :<|> serveSet
   |                        ^^^^^^^^

server.hs:18:24: error:
    Variable not in scope: serveDelete :: Int -> Handler ()
   |
18 |                   :<|> serveDelete
   |                        ^^^^^^^^^^^

server.hs:19:24: error:
    Variable not in scope: servePrune :: Handler IntSet
   |
19 |                   :<|> servePrune
   |                        ^^^^^^^^^^
\end{verbatim}

It tells us exactly the types of each handler we need.

Knowing that \texttt{Handler} is a \texttt{MonadIO}, we can now directly just
write every handler in terms of how it manipulates the \texttt{IntMap} in the
\texttt{IORef}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/servant{-}services/server.hs\#L14{-}L44}

\OtherTok{serveTodoApi ::} \DataTypeTok{IORef}\NormalTok{ (}\DataTypeTok{IntMap} \DataTypeTok{Task}\NormalTok{) }\OtherTok{{-}>} \DataTypeTok{Server} \DataTypeTok{TodoApi}
\NormalTok{serveTodoApi taskRef }\OtherTok{=}\NormalTok{ serveList}
                  \OperatorTok{:<|>}\NormalTok{ serveAdd}
                  \OperatorTok{:<|>}\NormalTok{ serveSet}
                  \OperatorTok{:<|>}\NormalTok{ serveDelete}
                  \OperatorTok{:<|>}\NormalTok{ servePrune}
  \KeywordTok{where}
\OtherTok{    serveList ::} \DataTypeTok{Bool} \OtherTok{{-}>} \DataTypeTok{Handler}\NormalTok{ (}\DataTypeTok{IntMap} \DataTypeTok{Task}\NormalTok{)}
\NormalTok{    serveList filt }\OtherTok{=}\NormalTok{ filtFunction }\OperatorTok{<$>}\NormalTok{ liftIO (readIORef taskRef)}
      \KeywordTok{where}
\NormalTok{        filtFunction}
          \OperatorTok{|}\NormalTok{ filt      }\OtherTok{=}\NormalTok{ IM.filter (}\FunctionTok{not} \OperatorTok{.}\NormalTok{ taskStatus)}
          \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{=} \FunctionTok{id}
\OtherTok{    serveAdd ::} \DataTypeTok{Text} \OtherTok{{-}>} \DataTypeTok{Handler} \DataTypeTok{Int}
\NormalTok{    serveAdd t }\OtherTok{=}\NormalTok{ liftIO }\OperatorTok{$}\NormalTok{ atomicModifyIORef\textquotesingle{} taskRef }\OperatorTok{$}\NormalTok{ \textbackslash{}ts }\OtherTok{{-}>}
      \KeywordTok{let}\NormalTok{ newKey }\OtherTok{=} \FunctionTok{maybe} \DecValTok{0}\NormalTok{ ((}\OperatorTok{+} \DecValTok{1}\NormalTok{) }\OperatorTok{.} \FunctionTok{fst}\NormalTok{) (IM.lookupMax ts)}
      \KeywordTok{in}\NormalTok{  ( IM.insert newKey (}\DataTypeTok{Task} \DataTypeTok{False}\NormalTok{ t) ts, newKey )}
\OtherTok{    serveSet ::} \DataTypeTok{Int} \OtherTok{{-}>} \DataTypeTok{Maybe} \DataTypeTok{Bool} \OtherTok{{-}>} \DataTypeTok{Handler}\NormalTok{ ()}
\NormalTok{    serveSet tid s }\OtherTok{=}\NormalTok{ liftIO }\OperatorTok{$}\NormalTok{ atomicModifyIORef\textquotesingle{} taskRef }\OperatorTok{$}\NormalTok{ \textbackslash{}ts }\OtherTok{{-}>}
\NormalTok{        ( IM.adjust adjuster tid ts, () )}
      \KeywordTok{where}
\NormalTok{        adjuster (}\DataTypeTok{Task}\NormalTok{ c d) }\OtherTok{=} \KeywordTok{case}\NormalTok{ s }\KeywordTok{of}
          \DataTypeTok{Nothing} \OtherTok{{-}>} \DataTypeTok{Task}\NormalTok{ (}\FunctionTok{not}\NormalTok{ c) d}
          \DataTypeTok{Just}\NormalTok{ c\textquotesingle{} }\OtherTok{{-}>} \DataTypeTok{Task}\NormalTok{ c\textquotesingle{}      d}
\OtherTok{    serveDelete ::} \DataTypeTok{Int} \OtherTok{{-}>} \DataTypeTok{Handler}\NormalTok{ ()}
\NormalTok{    serveDelete tid }\OtherTok{=}\NormalTok{ liftIO }\OperatorTok{$}\NormalTok{ atomicModifyIORef\textquotesingle{} taskRef }\OperatorTok{$}\NormalTok{ \textbackslash{}ts }\OtherTok{{-}>}
\NormalTok{      ( IM.delete tid ts, () )}
\OtherTok{    servePrune ::} \DataTypeTok{Handler} \DataTypeTok{IntSet}
\NormalTok{    servePrune }\OtherTok{=}\NormalTok{ liftIO }\OperatorTok{$}\NormalTok{ atomicModifyIORef\textquotesingle{} taskRef }\OperatorTok{$}\NormalTok{ \textbackslash{}ts }\OtherTok{{-}>}
      \KeywordTok{let}\NormalTok{ (compl,incompl) }\OtherTok{=}\NormalTok{ IM.partition taskStatus ts}
      \KeywordTok{in}\NormalTok{  (incompl, IM.keysSet compl)}
\end{Highlighting}
\end{Shaded}

And that's it!

To run our server, we can use
\emph{\href{https://hackage.haskell.org/package/warp}{warp}}'s \texttt{run} with
\emph{servant-server}'s \texttt{serve}, after initializing the \texttt{IORef}
that our server will use with an empty map:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/servant{-}services/server.hs\#L46{-}L51}

\OtherTok{main ::} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{main }\OtherTok{=} \KeywordTok{do}
\NormalTok{    taskRef }\OtherTok{<{-}}\NormalTok{ newIORef IM.empty}
    \FunctionTok{putStrLn} \StringTok{"Launching server..."}
\NormalTok{    run }\DecValTok{3434} \OperatorTok{$}
\NormalTok{      serve todoApi (serveTodoApi taskRef)}
\end{Highlighting}
\end{Shaded}

We now have a todo TCP/IP service running on port 3434!

\hypertarget{todo-service-client}{%
\section{Todo Service Client}\label{todo-service-client}}

Too easy

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
