<!DOCTYPE HTML>
<html><head><title>Introduction to Singletons (Part 4) · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Hi again! Welcome back; let’s jump right into part 4 of our journey through the singleton design pattern and the great singletons library! Please check out the first three parts of the series and make sure you are comfortable with them before reading on. I definitely also recommend trying out some or all of the exercises, since we are going to be building on the concepts in those posts in a pretty heavy way. Today we’re going to jump straight into functional programming at the type level!"><meta property="og:type" content="article"><meta property="og:title" content="Introduction to Singletons (Part 4)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introduction-to-singletons-4.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introduction-to-singletons-4.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Introduction to Singletons (Part 4)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/singletons-4.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introduction-to-singletons-4.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introduction-to-singletons-4.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Hi again! Welcome back; let’s jump right into part 4 of our journey through the <em>singleton design pattern</em> and the great <em><a href="http://hackage.haskell.org/package/singletons">singletons</a></em> library!</p>
<p>Please check out <a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html">the first three parts of the series</a> and make sure you are comfortable with them before reading on. I definitely also recommend trying out some or all of the exercises, since we are going to be building on the concepts in those posts in a pretty heavy way.</p>
<p>Today we’re going to jump straight into <em>functional programming</em> at the type level!</p>
<h2 id="review">Review</h2>
<p>Just as a quick review, this entire series we have been working with a <code>Door</code> type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  data DoorState = Opened | Closed | Locked</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    deriving (Show, Eq)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  |])</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">data</span> <span class="dt">Door</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="dt">UnsafeMkDoor</span><span class="ot"> ::</span> {<span class="ot"> doorMaterial ::</span> <span class="dt">String</span> } <span class="ot">-&gt;</span> <span class="dt">Door</span> s</a></code></pre></div>
<p>And we talked about using <code>Sing s</code>, or <code>SDoorState s</code>, to represent the state of the door (in its type) as a run-time value. We’ve been using a wrapper to existentially hide the door state type, but also stuffing in a singleton to let us recover the type information once we want it again:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">mkSomeDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">mkSomeDoor ds mat <span class="fu">=</span> withSomeSing ds <span class="fu">$</span> \dsSing <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="dt">MkSomeDoor</span> dsSing (<span class="dt">UnsafeMkDoor</span> mat)</a></code></pre></div>
<p>In Part 3 we talked about a <code>Pass</code> data type that we used to talk about whether or not we can walk through or knock on a door:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  data Pass = Obstruct | Allow</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    deriving (Show, Eq)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  |])</a></code></pre></div>
<p>And we defined type-level functions on it using <em>singletons</em> Template Haskell:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  statePass :: DoorState -&gt; Pass</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  statePass Opened = Allow</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  statePass Closed = Obstruct</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  statePass Locked = Obstruct</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  |])</a></code></pre></div>
<p>This essentially generates these three things:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">statePass ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Pass</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">statePass <span class="dt">Opened</span> <span class="fu">=</span> <span class="dt">Allow</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">statePass <span class="dt">Closed</span> <span class="fu">=</span> <span class="dt">Obstruct</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">statePass <span class="dt">Locked</span> <span class="fu">=</span> <span class="dt">Obstruct</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">type</span> family <span class="dt">StatePass</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>)<span class="ot"> ::</span> <span class="dt">Pass</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    <span class="dt">StatePass</span> &#39;<span class="dt">Opened</span> <span class="fu">=</span> &#39;<span class="dt">Allow</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    <span class="dt">StatePass</span> &#39;<span class="dt">Closed</span> <span class="fu">=</span> &#39;<span class="dt">Obstruct</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="dt">StatePass</span> &#39;<span class="dt">Locked</span> <span class="fu">=</span> &#39;<span class="dt">Obstruct</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="ot">sStatePass ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">StatePass</span> s)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">sStatePass <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">SAllow</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">SObstruct</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">SObstruct</span></a></code></pre></div>
<p>And we can use <code>StatePass</code> as a type-level function while using <code>sStatePass</code> to manipulate the singletons representing <code>s</code> and <code>StatePass s</code>.</p>
<p>We used this as a constraint to restrict how we can call our functions:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">knockP ::</span> (<span class="dt">StatePass</span> s <span class="fu">~</span> &#39;<span class="dt">Obstruct</span>) <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">knockP d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a></code></pre></div>
<p>But then we wondered…is there a way to not only <em>restrict</em> our functions, but to describe how the inputs and outputs are related to each other?</p>
<h2 id="inputs-and-outputs">Inputs and Outputs</h2>
<p>In the past we have settled with very simple relationships, like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">closeDoor ::</span> <span class="dt">Door</span> &#39;<span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">closeDoor (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> m</a></code></pre></div>
<p>This means that the relationship between the input and output is that the input is opened…and is then closed.</p>
<p>However, armed with promotion of type-level functions, writing more complex relationships becomes fairly straightforward!</p>
<p>We can write a function <code>mergeDoor</code> that “merges” two doors together, in sequence:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">mergeDoor ::</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> t <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="fu">????</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">mergeDoor d e <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">$</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; and &quot;</span> <span class="fu">++</span> doorMaterial e</a></code></pre></div>
<p>A merged door will have a material that is composite of the original materials. But, what will the new <code>DoorState</code> be? What goes in the <code>???</code> above?</p>
<p>Well, if we can write the function as a normal function in values…<em>singletons</em> lets us use it as a function on types. Let’s write that relationship. Let’s say merging takes on the higher “security” option — merging opened with locked is locked, merging closed with opened is closed, merging locked with closed is locked.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  mergeState :: DoorState -&gt; DoorState -&gt; DoorState</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  mergeState Opened d      = d</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  mergeState Closed Opened = Closed</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  mergeState Closed Closed = Closed</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  mergeState Closed Locked = Locked</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  mergeState Locked _      = Locked</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  |])</a>
<a class="sourceLine" id="cb9-9" data-line-number="9"></a>
<a class="sourceLine" id="cb9-10" data-line-number="10"><span class="co">-- Alternatively, taking advantage of the derived Ord instance:</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  mergeState :: DoorState -&gt; DoorState -&gt; DoorState</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  mergeState = max</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  |])</a></code></pre></div>
<p>This makes writing <code>mergeDoor</code>’s type fairly straightforward!</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">mergeDoor</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Door</span> s</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">Door</span> t</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">Door</span> (<span class="dt">MergeState</span> s t)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">mergeDoor d e <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">$</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; and &quot;</span> <span class="fu">++</span> doorMaterial e</a></code></pre></div>
<p>And, with the help of singletons, we can also write this for our doors where we don’t know the types until runtime:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">mergeSomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">mergSomeDoor (<span class="dt">MkSomeDoor</span> s d) (<span class="dt">MkSomeDoor</span> t e) <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="dt">MkSomeDoor</span> (sMergeState s t) (mergeDoor d e)</a></code></pre></div>
<p>To see why this typechecks properly, compare the types of <code>sMergeState</code> and <code>mergeDoor</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">sMergeState ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Sing</span> t <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">MergeState</span> s t)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">mergeDoor   ::</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> t <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">MergeState</span> s t)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">Sing</span> (<span class="dt">MergeState</span> s t) <span class="ot">-&gt;</span> <span class="dt">Door</span> (<span class="dt">MergeState</span> s t) <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a></code></pre></div>
<p>Because the results both create types <code>MergeState s t</code>, <code>MkSomeDoor</code> is happy to apply them to each other, and everything typechecks. However, if, say, we directly stuffed <code>s</code> or <code>t</code> into <code>MkSomeDoor</code>, things would fall apart and not typecheck.</p>
<p>And so now we have full expressiveness in determining input and output relationships! Once we unlock the power of type-level functions with <em>singletons</em>, writing type-level relationships become as simple as writing value-level ones. If you can write a value-level function, you can write a type-level function!</p>
<h3 id="kicking-it-up-a-notch">Kicking it up a notch</h3>
<p>Alright, so let’s see how far we can really take this!</p>
<p>Let’s make a data type that represents a <em>series of hallways</em>, each linked by a door. A hallway is either an empty stretch with no door, or two hallways linked by a door. We’ll structure it like a linked list, and store the list of all door states as a type-level list as a type parameter:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Hallway</span><span class="ot"> ::</span> [<span class="dt">DoorState</span>] <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    <span class="dt">HEnd</span><span class="ot">  ::</span> <span class="dt">Hallway</span> &#39;[]</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="co">-- ^ end of the hallway, a stretch with no doors</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="ot">    (:&lt;#) ::</span> <span class="dt">Door</span> s</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">          <span class="ot">-&gt;</span> <span class="dt">Hallway</span> ss</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">          <span class="ot">-&gt;</span> <span class="dt">Hallway</span> (s &#39;<span class="fu">:</span> ss)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    <span class="co">-- ^ A door connected to a hallway is a new</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    <span class="co">--   hallway, and we track the door&#39;s state in the list</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">    <span class="co">--   of hallway door states</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10"></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:&lt;#</span></a></code></pre></div>
<p>So we might have:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="kw">let</span> door1 <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Closed</span> <span class="st">&quot;Oak&quot;</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">ghci<span class="fu">&gt;</span> <span class="kw">let</span> door2 <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Opened</span> <span class="st">&quot;Spruce&quot;</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="kw">let</span> door3 <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Locked</span> <span class="st">&quot;Acacia&quot;</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t door1 <span class="fu">:&lt;#</span> door2 <span class="fu">:&lt;#</span> door3 <span class="fu">:&lt;#</span> <span class="dt">HEnd</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="dt">Hallway</span> &#39;[ &#39;<span class="dt">Closed</span>, &#39;<span class="dt">Opened</span>, &#39;<span class="dt">Locked</span> ]</a></code></pre></div>
<p>That is, a <code>Hallway '[ s, t, u ]</code> is a hallway consisting of a <code>Door s</code>, a <code>Door t</code>, and a <code>Door u</code>, constructed like a linked list in Haskell.</p>
<p>Now, let’s write a function to <em>collapse all doors in a hallway down to a single door</em>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">collapseHallway ::</span> <span class="dt">Hallway</span> ss <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="fu">?????</span></a></code></pre></div>
<p>Basically, we want to merge all of the doors one after the other, collapsing it until we have a single door state. Luckily, <code>MergeState</code> is both commutative and associative and has an identity, so this can be defined sensibly.</p>
<p>First, let’s think about the type we want. What will the result of merging <code>ss</code> be?</p>
<p>We can pattern match and collapse an entire list down item-by-item:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  mergeStates :: [DoorState] -&gt; DoorState</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  mergeStates []     = Opened               -- ^ the identity of mergeState</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  mergeStates (s:ss) = s `mergeState` mergeStates ss</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  |])</a></code></pre></div>
<p>Again, remember that this also defines the type family <code>MergeStateList</code> and the singleton function <code>sMergeStateList :: Sing ss -&gt; Sing (MergeStateList ss)</code>.</p>
<p>With this, we can write <code>collapseHallway</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">collapseHallway ::</span> <span class="dt">Hallway</span> ss <span class="ot">-&gt;</span> <span class="dt">Door</span> (<span class="dt">MergeStateList</span> ss)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">collapseHallway <span class="dt">HEnd</span>       <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="st">&quot;End of Hallway&quot;</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">collapseHallway (d <span class="fu">:&lt;#</span> ds) <span class="fu">=</span> d <span class="ot">`mergeDoor`</span> collapseHallway ds</a></code></pre></div>
<p>Now, because the structure of <code>collapseHallway</code> perfectly mirrors the structure of <code>mergeStates</code>, this all typechecks, and we’re done!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">ghci<span class="fu">&gt;</span> collapseHallway (door1 <span class="fu">:&lt;#</span> door2 <span class="fu">:&lt;#</span> door3 <span class="fu">:&lt;#</span> <span class="dt">HEnd</span>)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="dt">UnsafeMkDoor</span> <span class="st">&quot;Oak and Spruce and Acacia and End of Hallway&quot;</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="ot">    ::</span> <span class="dt">Door</span> &#39;<span class="dt">Locked</span></a></code></pre></div>
<p>Note one nice benefit – the door state of <code>collapseHallway (door1 :&lt;# door2 :&lt;# door3 :&lt;# HEnd)</code> is known at compile-time to be <code>Door 'Locked</code>, if the types of all of the component doors are also known!</p>
<h2 id="functional-programming">Functional Programming</h2>
<p>We went over that all a bit fast, but some of you might have noticed that the definition of <code>mergeStates</code> bears a really strong resemblance to a very common Haskell list processing pattern:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">mergeStates ::</span> [<span class="dt">DoorState</span>] <span class="ot">-&gt;</span> <span class="dt">DoorState</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">mergeStates []     <span class="fu">=</span> <span class="dt">Opened</span>               <span class="co">-- ^ the identity of mergeState</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">mergeStates (s<span class="fu">:</span>ss) <span class="fu">=</span> s <span class="ot">`mergeState`</span> mergeStates ss</a></code></pre></div>
<p>We replace all <code>[]</code> with <code>Opened</code>, and all <code>(:)</code> with <code>mergeState</code>. Yup — this is exactly a <code>foldr</code>!</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">mergeStates ::</span> [<span class="dt">DoorState</span>] <span class="ot">-&gt;</span> <span class="dt">DoorState</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">mergeState <span class="fu">=</span> foldr mergeState <span class="dt">Opened</span></a></code></pre></div>
<p>In Haskell, we are always encouraged to use higher-order functions whenever possible instead of explicit recursion, both because explicit recursion opens you up to a lot of potential bugs, and also because using established higher-order functions make your code more readable.</p>
<p>So, as Haskellers, let us hold ourselves to a higher standard and not be satisfied with a <code>MergeState</code> written using explicit recursion. Let us instead go <em>full fold</em>! ONWARD HO!</p>
<h3 id="the-problem">The Problem</h3>
<p>Initial attempts to write a higher-order type-level function as a type family, however, serve to temper our enthusiasm.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">MergeState</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>) (<span class="ot">t ::</span> <span class="dt">DoorState</span>)<span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    <span class="dt">MergeState</span> s t <span class="fu">=</span> <span class="dt">Max</span> s t</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="kw">type</span> family <span class="dt">Foldr</span> (<span class="ot">f ::</span> j <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> k) (<span class="ot">z ::</span> k) (<span class="ot">xs ::</span> [j])<span class="ot"> ::</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    <span class="dt">Foldr</span> f z &#39;[]       <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">    <span class="dt">Foldr</span> f z (x &#39;<span class="fu">:</span> xs) <span class="fu">=</span> f x (<span class="dt">Foldr</span> f z xs)</a></code></pre></div>
<p>So far so good right? So we should expect to be able to write <code>MergeStateList</code> using <code>Foldr</code>, <code>MergeState</code>, and <code>'Opened</code></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">type</span> <span class="dt">MergeStateList</span> ss <span class="fu">=</span> <span class="dt">Foldr</span> <span class="dt">MergeState</span> &#39;<span class="dt">Opened</span> ss</a></code></pre></div>
<p>Ah, but the compiler is here to tell you this isn’t allowed in Haskell:</p>
<pre><code>    • The type family ‘MergeState’ should have 2 arguments, but has been given none
    • In the equations for closed type family ‘MergeStateList’
      In the type family declaration for ‘MergeStateList’</code></pre>
<p>What happened? To figure out, we have to remember that pesky restriction on type synonyms and type families: they <em>cannot</em> be partially applied, and must always be fully applied. For the most part, only <em>type constructors</em> (like <code>Maybe</code>, <code>Either</code>, <code>IO</code>) and lifted DataKinds data constructors (like <code>'Just</code>, <code>'(:)</code>) in Haskell can ever be partially applied at the type level. We therefore can’t use <code>MergeState</code> as an argument to <code>Foldr</code>, because <code>MergeState</code> must always be fully applied.</p>
<p>Unfortunately for us, this makes our <code>Foldr</code> effectively useless. That’s because we’re always going to want to pass in type families (like <code>MergeState</code>), so there’s pretty much literally no way to ever actually call <code>Foldr</code> except with type constructors or lifted DataKinds data constructors.</p>
<p>So…back to the drawing board?</p>
<h2 id="defunctionalization">Defunctionalization</h2>
<p>I like to mentally think of the <em>singletons</em> library as having two parts: the first is linking lifted DataKinds types with run-time values to allow us to manipulate types at runtime as first-class values. The second is a system for effective <em>functional programming</em> at the type level.</p>
<p>To make a working <code>Foldr</code>, we’re going to have to jump into that second half: <em><a href="https://en.wikipedia.org/wiki/Defunctionalization">defunctionalization</a></em>.</p>
<p>Defunctionalization is a technique invented in the early 70’s to convert higher-order functions into first-order functions. The main idea is:</p>
<ul>
<li>Instead of working with <em>functions</em>, work with <em>symbols representing functions</em>.</li>
<li>Build your final functions and values by composing and combining these symbols.</li>
<li>At the end of it all, have a single <code>Apply</code> function interpret all of your symbols and produce the value you want.</li>
</ul>
<p>In <em>singletons</em> these symbols are implemented as “dummy” empty data constructors, and <code>Apply</code> is a type family.</p>
<p>To help us understand singleton’s defunctionalization system better, let’s build our own defunctionalization system from scratch.</p>
<p>First, a little trick to make things easier to read:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">TyFun</span> a b</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="kw">type</span> a <span class="fu">~&gt;</span> b <span class="fu">=</span> <span class="dt">TyFun</span> a b <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"></a>
<a class="sourceLine" id="cb24-4" data-line-number="4"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">~&gt;</span></a></code></pre></div>
<h3 id="our-first-symbols">Our First Symbols</h3>
<p>Now we can define a dummy data type like <code>Id</code>, which represents the identity function <code>id</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Id</span><span class="ot"> ::</span> a <span class="fu">~&gt;</span> a</a></code></pre></div>
<p>Don’t worry too much about <code>TyFun</code>, it’s all just a type-level tag that makes it convenient to write <code>Id :: a ~&gt; a</code>. The actual kind of <code>Id</code> is <code>Id :: TyFun a a -&gt; Type</code>; you can imagine <code>TyFun a a</code> as a phantom parameter that signifies that <code>Id</code> represents a function from <code>a</code> to <code>a</code>.</p>
<p>Now, <code>Id</code> is not a function…it’s a <em>dummy type constructor</em> that <em>represents</em> a function <code>a -&gt; a</code>. A type constructor of kind <code>a ~&gt; a</code> represents a <em>defunctionalization symbol</em> – a type constructor that represents a function from <code>a</code> to <code>a</code>.</p>
<p>To interpret it, we need to write our global interpreter function:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Apply</span> (<span class="ot">f ::</span> a <span class="fu">~&gt;</span> b) (<span class="ot">x ::</span> a)<span class="ot"> ::</span> b</a></code></pre></div>
<p>That’s the syntax for the definition of an <em>open</em> type family in Haskell: users are free to add their own instances, just like how type classes are normally open in Haskell.</p>
<p>Let’s tell <code>Apply</code> how to interpret <code>Id</code>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> <span class="dt">Id</span> x <span class="fu">=</span> x</a></code></pre></div>
<p>The above is the actual function definition, like writing <code>id x = x</code>. We can now <em>call</em> <code>Id</code> to get an actual type in return:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Apply</span> <span class="dt">Id</span> &#39;<span class="dt">True</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">&#39;<span class="dt">True</span></a></code></pre></div>
<p>Let’s define another one! We’ll implement <code>Not</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Not</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="fu">~&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> <span class="dt">Not</span> &#39;<span class="dt">False</span> <span class="fu">=</span> &#39;<span class="dt">True</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> <span class="dt">Not</span> &#39;<span class="dt">True</span>  <span class="fu">=</span> &#39;<span class="dt">False</span></a></code></pre></div>
<p>We can try it out:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Apply</span> <span class="dt">Not</span> &#39;<span class="dt">True</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">&#39;<span class="dt">False</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Apply</span> <span class="dt">Not</span> &#39;<span class="dt">False</span></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">&#39;<span class="dt">True</span></a></code></pre></div>
<p>It can be convenient to define an infix synonym for <code>Apply</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">type</span> f <span class="fu">@@</span> a <span class="fu">=</span> <span class="dt">Apply</span> f a</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"></a>
<a class="sourceLine" id="cb31-3" data-line-number="3"><span class="kw">infixl</span> <span class="dv">9</span> <span class="fu">@@</span></a></code></pre></div>
<p>Then we can wrote:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Not</span> <span class="fu">@@</span> &#39;<span class="dt">False</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">&#39;<span class="dt">True</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Id</span> <span class="fu">@@</span> &#39;<span class="dt">True</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">&#39;<span class="dt">True</span></a></code></pre></div>
<p>Remember, <code>Id</code> and <code>Not</code> are not actual functions — they’re just dummy data types (“defunctionalization symbols”), and we define the functions they represent through the global <code>Apply</code> type function.</p>
<h3 id="a-bit-of-principle">A Bit of Principle</h3>
<p>So we’ve got the basics of defunctionalization — instead of using functions directly, use dummy symbols that encode your functions that are interpreted using <code>Apply</code>. Let’s add a bit of principle to make this all a bit more scalable.</p>
<p>The singletons library adopts a few conventions for linking all of these together. Using the <code>Not</code> function as an example, if we wanted to lift the function:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">not<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">not <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">not <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">Flse</span></a></code></pre></div>
<p>We already know about the type family and singleton function this would produce:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Not</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">    <span class="dt">Not</span> &#39;<span class="dt">False</span> <span class="fu">=</span> &#39;<span class="dt">True</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    <span class="dt">Not</span> &#39;<span class="dt">True</span>  <span class="fu">=</span> &#39;<span class="dt">False</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4"></a>
<a class="sourceLine" id="cb34-5" data-line-number="5"><span class="ot">sNot ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">Not</span> x)</a>
<a class="sourceLine" id="cb34-6" data-line-number="6">sNot <span class="dt">SFalse</span> <span class="fu">=</span> <span class="dt">STrue</span></a>
<a class="sourceLine" id="cb34-7" data-line-number="7">sNot <span class="dt">STrue</span>  <span class="fu">=</span> <span class="dt">SFalse</span></a></code></pre></div>
<p>But the singletons library also produces the following <em>defunctionalization symbols</em>, according to a naming convention:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">NotSym0</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="fu">~&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> <span class="dt">NotSym0</span> x <span class="fu">=</span> <span class="dt">Not</span> x</a>
<a class="sourceLine" id="cb35-3" data-line-number="3"></a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="co">-- also generated for consistency</span></a>
<a class="sourceLine" id="cb35-5" data-line-number="5"><span class="kw">type</span> <span class="dt">NotSym1</span> x <span class="fu">=</span> <span class="dt">Not</span> x</a></code></pre></div>
<p><code>NotSym0</code> is the <em>defunctionalization symbol</em> associated with the <code>Not</code> type family, defined so that <code>NotSym0 @@ x = Not x</code>. Its purpose is to allow us to <em>pass in</em> <code>Not</code> as an <em>un-applied function</em>. The <code>Sym0</code> suffix is a naming convention, and the 0 stands for “expects 0 arguments”. Similarly for <code>NotSym1</code> – the 1 stands for “expects 1 argument”.</p>
<p>Let’s look at a slightly more complicated example – a two-argument function. Let’s define the boolean “and”:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">  and :: Bool -&gt; (Bool -&gt; Bool)</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">  and False _ = False</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">  and True  x = x</a>
<a class="sourceLine" id="cb36-5" data-line-number="5">  ])</a></code></pre></div>
<p>this will generate:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">And</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>) (<span class="ot">y ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2">    <span class="dt">And</span> &#39;<span class="dt">False</span> x <span class="fu">=</span> &#39;<span class="dt">False</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">    <span class="dt">And</span> &#39;<span class="dt">True</span>  x <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb37-4" data-line-number="4"></a>
<a class="sourceLine" id="cb37-5" data-line-number="5"><span class="ot">sAnd ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Sing</span> y <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">And</span> x y)</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">sAnd <span class="dt">SFalse</span> x <span class="fu">=</span> <span class="dt">SFalse</span></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">sAnd <span class="dt">STrue</span>  x <span class="fu">=</span> x</a></code></pre></div>
<p>And the defunctionalization symbols:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">data</span> <span class="dt">AndSym0</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="fu">~&gt;</span> (<span class="dt">Bool</span> <span class="fu">~&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> <span class="dt">AndSym0</span> x <span class="fu">=</span> <span class="dt">AndSym1</span> x</a>
<a class="sourceLine" id="cb38-3" data-line-number="3"></a>
<a class="sourceLine" id="cb38-4" data-line-number="4"><span class="kw">data</span> <span class="dt">AndSym1</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> (<span class="dt">Bool</span> <span class="fu">~&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb38-5" data-line-number="5"><span class="co">-- or</span></a>
<a class="sourceLine" id="cb38-6" data-line-number="6"><span class="kw">data</span> <span class="dt">AndSym1</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span> <span class="fu">~&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb38-7" data-line-number="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> (<span class="dt">AndSym1</span> x) y <span class="fu">=</span> <span class="dt">And</span> x y</a>
<a class="sourceLine" id="cb38-8" data-line-number="8"></a>
<a class="sourceLine" id="cb38-9" data-line-number="9"><span class="kw">type</span> <span class="dt">AndSym2</span> x y <span class="fu">=</span> <span class="dt">And</span> x y</a></code></pre></div>
<p><code>AndSym0</code> is a defunctionalization symbol representing a “fully unapplied” version of <code>And</code>. <code>AndSym1 x</code> is a defunctionalization symbol representing a “partially applied” version of <code>And</code> — partially applied to <code>x</code> (its kind is <code>AndSym1 :: Bool -&gt; (Bool ~&gt; Bool)</code>).</p>
<p>The application of <code>AndSym0</code> to <code>x</code> gives you <code>AndSym1 x</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">AndSym0</span> <span class="fu">@@</span> &#39;<span class="dt">False</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="dt">AndSym1</span> &#39;<span class="dt">False</span></a></code></pre></div>
<p>Remember its kind <code>AndSym0 :: Bool ~&gt; (Bool ~&gt; Bool)</code> (or just <code>AndSym0 :: Bool ~&gt; Bool ~&gt; Bool</code>): it takes a <code>Bool</code>, and returns a <code>Bool ~&gt; Bool</code> defunctionalization symbol.</p>
<p>The application of <code>AndSym1 x</code> to <code>y</code> gives you <code>And x y</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">AndSym1</span> &#39;<span class="dt">False</span> <span class="fu">@@</span> &#39;<span class="dt">True</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">&#39;<span class="dt">False</span></a>
<a class="sourceLine" id="cb40-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">AndSym1</span> &#39;<span class="dt">True</span>  <span class="fu">@@</span> &#39;<span class="dt">True</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4">&#39;<span class="dt">True</span></a></code></pre></div>
<p>A note to remember: <code>AndSym1 'True</code> is the defunctionalization symbol, and <em>not</em> <code>AndSym1</code> itself. <code>AndSym1</code> has kind <code>Bool -&gt; (Bool ~&gt; Bool)</code>, but <code>AndSym1 'True</code> has kind <code>Bool ~&gt; Bool</code> — the kind of a defunctionalization symbol.</p>
<p>One extra interesting defunctionalization symbol we can write: we turn lift any type constructor into a “free” defunctionalization symbol:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">data</span> <span class="dt">TyCon1</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="ot">        ::</span> (j <span class="ot">-&gt;</span> k)     <span class="co">-- ^ take a type constructor</span></a>
<a class="sourceLine" id="cb41-3" data-line-number="3">        <span class="ot">-&gt;</span> (j <span class="fu">~&gt;</span> k)     <span class="co">-- ^ return a defunctionalization symbol</span></a>
<a class="sourceLine" id="cb41-4" data-line-number="4"></a>
<a class="sourceLine" id="cb41-5" data-line-number="5"><span class="co">-- alternatively</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="kw">data</span> <span class="dt">TyCon1</span> (<span class="ot">t ::</span> j <span class="ot">-&gt;</span> k)<span class="ot"> ::</span> j <span class="fu">~&gt;</span> k</a>
<a class="sourceLine" id="cb41-7" data-line-number="7"></a>
<a class="sourceLine" id="cb41-8" data-line-number="8"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> (<span class="dt">TyCon1</span> t) a <span class="fu">=</span> t a</a></code></pre></div>
<p>Basically the <code>Apply</code> instance just applies the type constructor <code>t</code> to its input <code>a</code>.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">TyCon1</span> <span class="dt">Maybe</span> <span class="fu">@@</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb42-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">TyCon1</span> &#39;<span class="dt">Right</span> <span class="fu">@@</span> &#39;<span class="dt">False</span></a>
<a class="sourceLine" id="cb42-4" data-line-number="4">&#39;<span class="dt">Right</span> &#39;<span class="dt">False</span></a></code></pre></div>
<p>We can use this to give a normal <code>j -&gt; k</code> type constructor to a function that expects a <code>j ~&gt; k</code> defunctionalization symbol.</p>
<h2 id="bring-me-a-higher-order">Bring Me a Higher Order</h2>
<p>Okay, so now we have these tokens that represent “unapplied” versions of functions. So what?</p>
<p>Well, remember the problem with our implementation of <code>Foldr</code>? We couldn’t pass in a type family, since type families must be passed fully applied. So, instead of having <code>Foldr</code> expect a type family…we can make it expect a <em>defunctionalization symbol</em> instead! Remember, defunctionalization symbols represent the “unapplied” versions of type families, so they are exactly the tools we need!</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Foldr</span> (<span class="ot">f ::</span> j <span class="fu">~&gt;</span> k <span class="fu">~&gt;</span> k) (<span class="ot">z ::</span> k) (<span class="ot">xs ::</span> [j])<span class="ot"> ::</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2">    <span class="dt">Foldr</span> f z &#39;[]       <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb43-3" data-line-number="3">    <span class="dt">Foldr</span> f z (x &#39;<span class="fu">:</span> xs) <span class="fu">=</span> (f <span class="fu">@@</span> x) <span class="fu">@@</span> <span class="dt">Foldr</span> f z xs</a></code></pre></div>
<p>The difference is that instead of taking a type family or type constructor <code>f :: j -&gt; k -&gt; k</code>, we have it take the <em>defunctionalization symbol</em> <code>f :: j ~&gt; (k ~&gt; k)</code>.</p>
<p>Instead of taking a type family or type constructor, we take that dummy type constructor.</p>
<p>Now we just need to have our defunctionalization symbols for <code>MergeStateList</code>:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">MergeState</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>) (<span class="ot">t ::</span> <span class="dt">DoorState</span>)<span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">    <span class="dt">MergeState</span> s t <span class="fu">=</span> s</a>
<a class="sourceLine" id="cb44-3" data-line-number="3"></a>
<a class="sourceLine" id="cb44-4" data-line-number="4"><span class="kw">data</span> <span class="dt">MergeStateSym0</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="fu">~&gt;</span> <span class="dt">DoorState</span> <span class="fu">~&gt;</span> <span class="dt">DoorState</span></a>
<a class="sourceLine" id="cb44-5" data-line-number="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> <span class="dt">MergeStateSym0</span> s <span class="fu">=</span> <span class="dt">MergeStateSym1</span> s</a>
<a class="sourceLine" id="cb44-6" data-line-number="6"></a>
<a class="sourceLine" id="cb44-7" data-line-number="7"><span class="kw">data</span> <span class="dt">MergeStateSym1</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">DoorState</span> <span class="fu">~&gt;</span> <span class="dt">DoorState</span></a>
<a class="sourceLine" id="cb44-8" data-line-number="8"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> (<span class="dt">MergeStateSym1</span> s) t <span class="fu">=</span> <span class="dt">MergeState</span> s t</a>
<a class="sourceLine" id="cb44-9" data-line-number="9"></a>
<a class="sourceLine" id="cb44-10" data-line-number="10"><span class="kw">type</span> <span class="dt">MergeStateSym2</span> s t <span class="fu">=</span> <span class="dt">MergeState</span> s t</a></code></pre></div>
<p>And now we can write <code>MergeStateList</code>!</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">type</span> <span class="dt">MergeStateList</span> ss <span class="fu">=</span> <span class="dt">Foldr</span> <span class="dt">MergeStateSym0</span> &#39;<span class="dt">Opened</span> ss</a></code></pre></div>
<p>(If you “see” <code>MergeStateSym0</code>, you should <em>read</em> it was <code>MergeState</code>, but partially applied)</p>
<p>This compiles!</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">MergeStateList</span> &#39;[ &#39;<span class="dt">Closed</span>, &#39;<span class="dt">Opened</span>, &#39;<span class="dt">Locked</span> ]</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">&#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb46-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">MergeStateList</span> &#39;[ &#39;<span class="dt">Closed</span>, &#39;<span class="dt">Opened</span> ]</a>
<a class="sourceLine" id="cb46-4" data-line-number="4">&#39;<span class="dt">Closed</span></a></code></pre></div>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="ot">collapseHallway ::</span> <span class="dt">Hallway</span> ss <span class="ot">-&gt;</span> <span class="dt">Door</span> (<span class="dt">MergeStateList</span> ss)</a>
<a class="sourceLine" id="cb47-2" data-line-number="2">collapseHallway <span class="dt">HEnd</span>       <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="st">&quot;End of Hallway&quot;</span></a>
<a class="sourceLine" id="cb47-3" data-line-number="3">collapseHallway (d <span class="fu">:&lt;#</span> ds) <span class="fu">=</span> d <span class="ot">`mergeDoor`</span> collapseHallway ds</a></code></pre></div>
<h3 id="singletons-to-to-make-things-nicer">Singletons to to make things nicer</h3>
<p>Admittedly this is all a huge mess of boilerplate. The code we had to write more than tripled, and we also have an unsightly number of defunctionalization symbols and <code>Apply</code> instance boilerplate for every function.</p>
<p>Luckily, the <em>singletons</em> library is here to help. You can just write:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb48-2" data-line-number="2">  data DoorState = Opened | Closed | Locked</a>
<a class="sourceLine" id="cb48-3" data-line-number="3">    deriving (Show, Eq, Ord)</a>
<a class="sourceLine" id="cb48-4" data-line-number="4"></a>
<a class="sourceLine" id="cb48-5" data-line-number="5">  mergeState :: DoorState -&gt; DoorState -&gt; DoorState</a>
<a class="sourceLine" id="cb48-6" data-line-number="6">  mergeState = max</a>
<a class="sourceLine" id="cb48-7" data-line-number="7"></a>
<a class="sourceLine" id="cb48-8" data-line-number="8">  foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</a>
<a class="sourceLine" id="cb48-9" data-line-number="9">  foldr _ z []     = z</a>
<a class="sourceLine" id="cb48-10" data-line-number="10">  foldr f z (x:xs) = f x (foldr f z xs)</a>
<a class="sourceLine" id="cb48-11" data-line-number="11"></a>
<a class="sourceLine" id="cb48-12" data-line-number="12">  mergeStateList :: [DoorState] -&gt; DoorState</a>
<a class="sourceLine" id="cb48-13" data-line-number="13">  mergeStateList = foldr mergeState Opened</a>
<a class="sourceLine" id="cb48-14" data-line-number="14">  |])</a></code></pre></div>
<p>And all of these defunctionalization symbols are generated for you; <em>singletons</em> is also able to recognize that <code>foldr</code> is a higher-order function and translate its lifted version to take a defunctionalization symbol <code>a ~&gt; b ~&gt; b</code>.</p>
<p>It’s okay to stay “in the world of singletons” for the most part, and let singletons handle the composition of functions for you. However, it’s still important to know what the <em>singletons</em> library generates, because sometimes it’s still useful to manually create defunctionalization symbols and work with them.</p>
<h2 id="thoughts-on-symbols">Thoughts on Symbols</h2>
<p>Defunctionalization symbols may feel like a bit of a mess, and the naming convention is arguably less than aesthetically satisfying. But, as you work with them more and more, you start to appreciate them on a deeper level.</p>
<p>At the end of the day, you can compare defunctionalization as turning “functions” into just constructors you can <em>match</em> on, just like any other data or type consturctor. That’s because they <em>are</em> just type constructors!</p>
<p>In a sense, defining defunctionalization symbols is a lot like working with <em>pattern synonyms</em> of your functions, instead of directly passing the functions themselves. At the type family and type class level, you can “pattern match” on these functions.</p>
<p>For a comparison at the value level – you can’t pattern match on <code>(+)</code>, <code>(-)</code>, <code>(*)</code>, and <code>(/)</code>:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="co">-- Doesn&#39;t work like you think it does</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2"><span class="ot">invertOperation ::</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Dobule</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>) <span class="ot">-&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb49-3" data-line-number="3">invertOperation (<span class="fu">+</span>) <span class="fu">=</span> (<span class="fu">-</span>)</a>
<a class="sourceLine" id="cb49-4" data-line-number="4">invertOperation (<span class="fu">-</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb49-5" data-line-number="5">invertOperation (<span class="fu">*</span>) <span class="fu">=</span> (<span class="fu">/</span>)</a>
<a class="sourceLine" id="cb49-6" data-line-number="6">invertOperation (<span class="fu">/</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>You can’t quite match on the equality of functions to some list of patterns. But, what you <em>can</em> do is create constructors representing your functions, and match on those.</p>
<p>This essentially fixes the “type lambda problem” of type inference and typeclass resolution. You can’t match on arbitrary lambdas, but you <em>can</em> match on dummy constructors representing type functions.</p>
<p>And a bit of the magic here, also, is the fact that you don’t always need to make our own defunctionalization symbols from scratch — you can create them based on other ones in a compositional way.</p>
<p>For example, suppose we wanted to build defunctionalization symbols for <code>MergeStateList</code>. We can actually build them directly from defunctionalization symbols for <code>Foldr</code>!</p>
<p>Check out the defunctionalization symbols for <code>Foldr</code>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">data</span> <span class="dt">FoldrSym0</span><span class="ot"> ::</span> (j <span class="fu">~&gt;</span> k <span class="fu">~&gt;</span> k) <span class="fu">~&gt;</span> k <span class="fu">~&gt;</span> [j] <span class="fu">~&gt;</span> k</a>
<a class="sourceLine" id="cb50-2" data-line-number="2"></a>
<a class="sourceLine" id="cb50-3" data-line-number="3"><span class="kw">data</span> <span class="dt">FoldrSym1</span><span class="ot"> ::</span> (j <span class="fu">~&gt;</span> k <span class="fu">~&gt;</span> k) <span class="ot">-&gt;</span> k <span class="fu">~&gt;</span> [j] <span class="fu">~&gt;</span> k</a>
<a class="sourceLine" id="cb50-4" data-line-number="4"></a>
<a class="sourceLine" id="cb50-5" data-line-number="5"><span class="kw">data</span> <span class="dt">FoldrSym2</span><span class="ot"> ::</span> (j <span class="fu">~&gt;</span> k <span class="fu">~&gt;</span> k) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> [j] <span class="fu">~&gt;</span> k</a></code></pre></div>
<p>We can actually use these to <em>define</em> our <code>MergeStateList</code> defunctionalization symbols, since <em>defunctionalization symbols are first-class</em>:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="kw">type</span> <span class="dt">MergeStateListSym0</span> <span class="fu">=</span> <span class="dt">FoldrSym2</span> <span class="dt">MergeStateSym0</span> &#39;<span class="dt">Opened</span></a></code></pre></div>
<p>And you can just write <code>collapseHallway</code> as:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="ot">collapseHallway ::</span> <span class="dt">Hallway</span> ss <span class="ot">-&gt;</span> <span class="dt">Door</span> (<span class="dt">MergeStateListSym0</span> <span class="fu">@@</span> ss)</a>
<a class="sourceLine" id="cb52-2" data-line-number="2"><span class="co">-- or</span></a>
<a class="sourceLine" id="cb52-3" data-line-number="3"><span class="ot">collapseHallway ::</span> <span class="dt">Hallway</span> ss <span class="ot">-&gt;</span> <span class="dt">Door</span> (<span class="dt">FoldrSym2</span> <span class="dt">MergeStateSym0</span> &#39;<span class="dt">Opened</span> <span class="fu">@@</span> ss)</a></code></pre></div>
<p>You never have to actually define <code>MergeStateList</code> as a function or type family!</p>
<p>The whole time, we’re just building defunctionalization symbols in terms of other defunctionalization symbols. And, at the end, when we finally want to interpret the complex function we construct, we use <code>Apply</code>, or <code>@@</code>.</p>
<p>You can think of <code>FoldrSym1</code> and <code>FoldrSym2</code> as <em>defunctionalization symbol constructors</em> – they’re combinators that take in defunctionalization symbols (like <code>MergeStateSym0</code>) and <em>return new ones</em>.</p>
<h3 id="sigma">Sigma</h3>
<p>Let’s look at a nice tool that is made possible using defunctionalization symbols: <em>dependent pairs</em>. I talk a bit about dependent pairs (or dependent sums) in <a href="https://blog.jle.im/entry/introduction-to-singletons-2.html">part 2</a> of this series, and also in my [dependent types in Haskell][dth] series.</p>
<p>Essentially, a dependent pair is a tuple where the <em>type</em> of the second field depends on the <em>value</em> of the first one. This is basically what <code>SomeDoor</code> was:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2">    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Door</span> x <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a></code></pre></div>
<p>The <em>type</em> of the <code>Door x</code> depends on the <em>value</em> of the <code>Sing x</code>, which you can read as essentially storing the <code>x</code>.</p>
<p>We made <code>SomeDoor</code> pretty ad-hoc. But what if we wanted to make some other predicate? Well, we can make a <em>generic</em> dependent pair by <em>parameterizing it on he dependence</em> between the first and second field.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Sigma</span><span class="ot"> k ::</span> (k <span class="fu">~&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2"><span class="ot">    (:&amp;:) ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> (f <span class="fu">@@</span> x) <span class="ot">-&gt;</span> <span class="dt">Sigma</span> k f</a></code></pre></div>
<p>If you squint carefully, you can see that <code>Sigma k</code> is just <code>SomeDoor</code>, but <em>parameterized over <code>Door</code></em>. Instead of always holding <code>Door x</code>, we can have it parameterized on an arbitrary function <code>f</code> and have it hold an <code>f @@ x</code>.</p>
<p>We can actually define <code>SomeDoor</code> in terms of <code>Sigma</code>:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="kw">type</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> <span class="dt">Sigma</span> <span class="dt">DoorState</span> (<span class="dt">TyCon1</span> <span class="dt">Door</span>)</a></code></pre></div>
<p>(Remember <code>TyCon1</code> is the defunctionalization symbol constructor that turns any normal type constructor <code>j -&gt; k</code> into a defunctionalization symbol <code>j ~&gt; k</code>)</p>
<p>That’s because a <code>Sigma DoorState (TyCon1 Door)</code> contains a <code>Sing (x :: DoorState)</code> and a <code>TyCon1 Door @@ x</code>, or a <code>Door x</code>.</p>
<p>This is a simple relationship, but one can imagine a <code>Sigma</code> parameterized on an even more complex type-level function. We’ll explore more of these in the exercises!</p>
<h3 id="singletons-of-functions">Singletons of Functions</h3>
<p>One last thing to tie it all together – let’s write <code>collapseHallway</code> in a way that we don’t know the types of the doors.</p>
<p>Luckily, we now have a <code>SomeHallway</code> type for free:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="kw">type</span> <span class="dt">SomeHallway</span> <span class="fu">=</span> <span class="dt">Sigma</span> [<span class="dt">DoorState</span>] (<span class="dt">TyCon1</span> <span class="dt">Hallway</span>)</a></code></pre></div>
<p>The easy way would be to just use <code>sMergeStateList</code> that we defned:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="ot">collapseSomeHallway ::</span> <span class="dt">SomeHallway</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb57-2" data-line-number="2">collapseSomeHallway (ss <span class="fu">:&amp;:</span> d) <span class="fu">=</span> sMergeStateList ss</a>
<a class="sourceLine" id="cb57-3" data-line-number="3">                             <span class="fu">:&amp;:</span> collapseHallway d</a></code></pre></div>
<p>But what if we didn’t write <code>sMergeStateList</code>, and we constructed our defunctionalization symbols from scratch?</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1">collapseHallway</a>
<a class="sourceLine" id="cb58-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Hallway</span> ss</a>
<a class="sourceLine" id="cb58-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">Door</span> (<span class="dt">FoldrSym2</span> <span class="dt">MergeStateSym0</span> &#39;<span class="dt">Opened</span> <span class="fu">@@</span> ss)</a>
<a class="sourceLine" id="cb58-4" data-line-number="4"></a>
<a class="sourceLine" id="cb58-5" data-line-number="5"><span class="ot">collapseSomeHallway ::</span> <span class="dt">SomeHallway</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb58-6" data-line-number="6">collapseSomeHallway (ss <span class="fu">:&amp;:</span> d) <span class="fu">=</span> <span class="fu">???</span>    <span class="co">-- what goes here?</span></a>
<a class="sourceLine" id="cb58-7" data-line-number="7">                             <span class="fu">:&amp;:</span> collapseHallway d</a></code></pre></div>
<p>This will be our final defunctionalization lesson. How do we turn a singleton of <code>ss</code> into a singleton of <code>FoldrSym2 MergeStateSym0 'Opened @@ s</code> ?</p>
<p>First – we have <code>Foldr</code> at the value level, as <code>sFoldr</code>. We glossed over this earlier, but <em>singletons</em> generates the following function for us:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Foldr</span> (<span class="ot">f ::</span> j <span class="fu">~&gt;</span> k <span class="fu">~&gt;</span> k) (<span class="ot">z ::</span> k) (<span class="ot">xs ::</span> [j])<span class="ot"> ::</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2">    <span class="dt">Foldr</span> f z &#39;[]       <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb59-3" data-line-number="3">    <span class="dt">Foldr</span> f z (x &#39;<span class="fu">:</span> xs) <span class="fu">=</span> (f <span class="fu">@@</span> x) <span class="fu">@@</span> <span class="dt">Foldr</span> f z xs</a>
<a class="sourceLine" id="cb59-4" data-line-number="4"></a>
<a class="sourceLine" id="cb59-5" data-line-number="5">sFoldr</a>
<a class="sourceLine" id="cb59-6" data-line-number="6"><span class="ot">    ::</span> <span class="dt">Sing</span> (<span class="ot">f ::</span> j <span class="fu">~&gt;</span> k <span class="fu">~&gt;</span> k)</a>
<a class="sourceLine" id="cb59-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">z ::</span> k)</a>
<a class="sourceLine" id="cb59-8" data-line-number="8">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">xs ::</span> [j])</a>
<a class="sourceLine" id="cb59-9" data-line-number="9">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">Foldr</span> f z<span class="ot"> xs ::</span> k)</a>
<a class="sourceLine" id="cb59-10" data-line-number="10">sFoldr f z <span class="dt">SNil</span>           <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb59-11" data-line-number="11">sFoldr f z (x <span class="ot">`SCons`</span> xs) <span class="fu">=</span> (f <span class="fu">@@</span> x) <span class="fu">@@</span> sFoldr f z xs</a></code></pre></div>
<p>Where <code>(@@) :: Sing f -&gt; Sing x -&gt; Sing (f @@ x)</code> (or <code>applySing</code>) is the singleton/value-level counterpart of <code>Apply</code> or <code>(@@)</code>.</p>
<p>So we can write:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="ot">collapseSomeHallway ::</span> <span class="dt">SomeHallway</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb60-2" data-line-number="2">collapseSomeHallway (ss <span class="fu">:&amp;:</span> d) <span class="fu">=</span> sFoldr <span class="fu">????</span> <span class="dt">SOpened</span> ss</a>
<a class="sourceLine" id="cb60-3" data-line-number="3">                             <span class="fu">:&amp;:</span> collapseHallway d</a></code></pre></div>
<p>But how do we get a <code>Sing MergeStateSym0</code>?</p>
<p>We can use the <code>singFun</code> family of functions:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" data-line-number="1">singFun2 <span class="fu">@</span><span class="dt">MergeStateSym0</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">MergeStateSym0</span></a></code></pre></div>
<p>And finally, we get our answer:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="ot">collapseSomeHallway ::</span> <span class="dt">SomeHallway</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb62-2" data-line-number="2">collapseSomeHallway (ss <span class="fu">:&amp;:</span> d) <span class="fu">=</span> sFoldr (singFun2 <span class="fu">@</span><span class="dt">MergeStateSym0</span>) <span class="dt">SOpened</span> ss</a>
<a class="sourceLine" id="cb62-3" data-line-number="3">                             <span class="fu">:&amp;:</span> collapseHallway d</a></code></pre></div>
<h2 id="closing-up">Closing Up</h2></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Introduction to Singletons&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html" class="tag-a-series" title="+Introduction to Singletons"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html" class="tag-a-series">+Introduction to Singletons</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introduction-to-singletons-4.html';
    this.page.identifier = 'singletons-4';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>