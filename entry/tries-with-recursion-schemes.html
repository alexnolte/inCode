<!DOCTYPE HTML>
<html><head><title>Tries with Recursion Schemes · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Not too long ago, I was browsing the prequel memes subreddit — a community built around creative ways of remixing and re-contextualizing quotes from the cinematic corpus of the three Star Wars prequel movies — when I noticed that a fad was in progress constructing tries based on quotes as keys indexing stills from the movie corresponding to those quotes. This inspired me to try playing around with some tries myself, and it gave me an excuse to play around with recursion-schemes (one of my favorite Haskell libraries). If you haven’t heard about it yet, recursion-schemes (and the similar library data-fix) abstracts over common recursive functions written on recursive data types. It exploits the fact that a lot of recursive functions for different recursive data types all really follow the same pattern and gives us powerful tools for writing cleaner and safer code. Recursion schemes is a perfect example of those amazing accidents that happen throughout the Haskell ecosystem: an extremely “theoretically beautiful” abstraction that also happens to be extremely useful for writing industrially rigorous code. Tries are a common intermediate-level recursive data type, and recursion-schemes is a common intermediate-level library. So, as a fun intermediate-level Haskell project, let’s build a trie data type in Haskell based on recursion-schemes, to see what it has to offer! The resulting data type will definitely not be a “toy” — it’ll be something you can actually use to build meme diagrams of your own!"><meta property="og:type" content="article"><meta property="og:title" content="Tries with Recursion Schemes"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/tries-with-recursion-schemes.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/tries-with-recursion-schemes.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Tries with Recursion Schemes</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/trie.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/tries-with-recursion-schemes.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/tries-with-recursion-schemes.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category" title="Technical tutorials/walkthroughs on specific programming processes and problems
that I&#39;ve struggled through in the past.">Tutorials</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Not too long ago, I was browsing the <a href="https://www.reddit.com/r/PrequelMemes">prequel memes subreddit</a> — a community built around creative ways of remixing and re-contextualizing quotes from the cinematic corpus of the three Star Wars prequel movies — when I noticed that a fad was in progress <a href="https://www.reddit.com/r/PrequelMemes/comments/9w59t4/i_expanded_it/">constructing tries based on quotes as keys</a> indexing stills from the movie corresponding to those quotes.</p>
<p>This inspired me to try playing around with some tries myself, and it gave me an excuse to play around with <em><a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a></em> (one of my favorite Haskell libraries). If you haven’t heard about it yet, <em>recursion-schemes</em> (and the similar library <em><a href="https://hackage.haskell.org/package/data-fix">data-fix</a></em>) abstracts over common recursive functions written on recursive data types. It exploits the fact that a lot of recursive functions for different recursive data types all really follow the same pattern and gives us powerful tools for writing cleaner and safer code.</p>
<p>Recursion schemes is a perfect example of those amazing accidents that happen throughout the Haskell ecosystem: an extremely “theoretically beautiful” abstraction that also happens to be extremely useful for writing industrially rigorous code.</p>
<p>Tries are a common intermediate-level recursive data type, and recursion-schemes is a common intermediate-level library. So, as a fun intermediate-level Haskell project, let’s build a trie data type in Haskell based on recursion-schemes, to see what it has to offer! The resulting data type will definitely not be a “toy” — it’ll be something you can actually use to build meme diagrams of your own!</p>
<h2 id="trie">Trie</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Trie">trie</a> (prefix tree) is a classic example of a simple yet powerful data type most people encounter in school (I remember being introduced to it through a project implementing a boggle solver).</p>
<p>Wikipedia has a nice picture:</p>
<figure>
<img src="/img/entries/trie/wiki-trie.png" title="An example Trie" alt="Sample Trie from Wikipedia, indexing lists of Char to Ints" /><figcaption>Sample Trie from Wikipedia, indexing lists of Char to Ints</figcaption>
</figure>
<p>API-wise, it is very similar to an <em>associative map</em>, like the <code>Map</code> type from <em><a href="https://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html">containers</a></em>. It stores “keys” to “values”, and you can insert a value at a given key, lookup the value stored at a given key, or delete the value at a given key.</p>
<p>The main difference is in implementation: the keys are <em>strings of tokens</em>, and it is internally represented as a tree: if your keys are words, then the first level is the first letter, the second level is the letter, etc. In the example above, the trie stores the keys <code>to</code>, <code>tea</code>, <code>ted</code>, <code>ten</code>, <code>A</code>, <code>i</code>, <code>in</code>, and <code>inn</code>, to the values 7, 3, 4, 12, 15, 11, 5, and 9, respectively. Note that it is possible for one key to completely overlap another (like <code>in</code> storing 5, and <code>inn</code> storing 9). In the usual case, however, we have partial overlaps (like <code>tea</code>, storing 3, and <code>ted</code> storing 4), whose common prefix (<code>te</code>) has no value stored under it.</p>
<h2 id="haskell-tries">Haskell Tries</h2>
<p>We can represent this in Haskell by representing each layer as a <code>Map</code> of a token to the next “level” of the trie:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L30-L31</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Trie</span> k v <span class="fu">=</span> <span class="dt">MkT</span> (<span class="dt">Maybe</span> v) (<span class="dt">Map</span> k (<span class="dt">Trie</span> k v))</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>A <code>Trie k v</code> will have keys of type <code>[k]</code>, where <code>k</code> is the key token type, and values of type <code>v</code>. Each layer might have a value (<code>Maybe v</code>), and branches out to each new layer.</p>
<p>We could write the trie storing <code>(to, 9)</code>, <code>(ton, 3)</code>, and <code>(tax, 2)</code> as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L46-L59</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">testTrie ::</span> <span class="dt">Trie</span> <span class="dt">Char</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">testTrie <span class="fu">=</span> <span class="dt">MkT</span> <span class="dt">Nothing</span> <span class="fu">$</span> M.fromList [</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">      (<span class="ch">&#39;t&#39;</span>, <span class="dt">MkT</span> <span class="dt">Nothing</span> <span class="fu">$</span> M.fromList [</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">          (<span class="ch">&#39;o&#39;</span>, <span class="dt">MkT</span> (<span class="dt">Just</span> <span class="dv">9</span>) <span class="fu">$</span> M.fromList [</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">              ( <span class="ch">&#39;n&#39;</span>, <span class="dt">MkT</span> (<span class="dt">Just</span> <span class="dv">3</span>) M.empty )</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">            ]</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">          )</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">        , (<span class="ch">&#39;a&#39;</span>, <span class="dt">MkT</span> <span class="dt">Nothing</span> <span class="fu">$</span> M.fromList [</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">              ( <span class="ch">&#39;x&#39;</span>, <span class="dt">MkT</span> (<span class="dt">Just</span> <span class="dv">2</span>) M.empty )</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">            ]</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">          )</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">        ]</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">      )</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">    ]</a></code></pre></div>
<p>Note that this implementation isn’t particularly structurally sound, since it’s possible to represent invalid keys that have branches that lead to nothing. This mostly becomes troublesome when we implement <code>delete</code>, but we won’t be worrying about that for now. The nice thing about Haskell is that we can be as safe as we want or need, as a judgement call on a case-by-case basis. However, a “correct-by-construction” trie is in the next part of this series :)</p>
<h3 id="recursion-schemes-an-elegant-weapon">Recursion Schemes: An Elegant Weapon</h3>
<p>Now, <code>Trie</code> as written up there is an explicitly recursive data type. While this is common practice, it’s not a particularly ideal situation. The problem with explicitly recursive data types is that to work with them, you often rely on explicitly recursive functions.</p>
<p>Explicitly recursive functions are notoriously difficult to write, understand, and maintain. It’s extremely easy to accidentally write an infinite loop, and is often called “the GOTO of functional programming”.</p>
<p>So, there’s a trick we can use to “factor out” the recursion in our data type. The trick is to replace the recursive occurrence of <code>Trie a</code> (in the <code>Cons</code> constructor) with a “placeholder” variable:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L33-L34</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">data</span> <span class="dt">TrieF</span> k v x <span class="fu">=</span> <span class="dt">MkTF</span> (<span class="dt">Maybe</span> v) (<span class="dt">Map</span> k x)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p><code>TrieF</code> now represents, essentially, “one layer” of a <code>Trie</code>.</p>
<p>There are now two paths we can go down: we can re-implement <code>Trie</code> in terms of <code>TrieF</code> (something that most tutorials and introductions do, using something like <code>Trie k v = Fix (TrieF k v)</code>), or we can think of <code>TrieF</code> as a “non-recursive view” into <code>Trie</code>. It’s a way of <em>working</em> with <code>Trie a</code> <em>as if</em> it were a non-recursive data type. Specifically, in our case, it’s a non-recursive view of a “single layer” of a <code>Trie</code>.</p>
<p>We can do this because <em>recursion-schemes</em> gives combinators (called “recursion schemes”) to abstract over common explicit recursion patterns. The key to using <em>recursion-schemes</em> is to recognize which combinators abstracts over the type of recursion you’re using. You then give that combinator an algebra or a coalgebra (more on this later), and you’re done!</p>
<p>Learning how to use <em>recursion-schemes</em> effectively is basically picking the right recursion scheme that abstracts over the type of function you want to write for your data type. It’s all about becoming familiar with the “zoo” of (colorfully named) recursion schemes you can pick from, and identifying which one does the job in your situation.</p>
<p>That’s the high-level view — let’s dive into writing out the API of our <code>Trie</code>!</p>
<h3 id="linking-the-base">Linking the base</h3>
<p>One thing we need to do before we can start: we need to tell <em>recursion-schemes</em> to link <code>TrieF</code> with <code>Trie</code>. In the nomenclature of <em>recursion-schemes</em>, <code>TrieF</code> is known as the “base type”, and <code>Trie</code> is called “the fixed-point”.</p>
<p>Linking them requires some boilerplate, which is basically converting back and forth from <code>Trie</code> to <code>TrieF</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L36-L44</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Base</span> (<span class="dt">Trie</span> k v) <span class="fu">=</span> <span class="dt">TrieF</span> k v</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Recursive</span> (<span class="dt">Trie</span> k v) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">    project ::</span> <span class="dt">Trie</span> k v <span class="ot">-&gt;</span> <span class="dt">TrieF</span> k v (<span class="dt">Trie</span> k v)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    project (<span class="dt">MkT</span> v xs) <span class="fu">=</span> <span class="dt">MkTF</span> v xs</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Corecursive</span> (<span class="dt">Trie</span> k v) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="ot">    embed ::</span> <span class="dt">TrieF</span> k v (<span class="dt">Trie</span> k v) <span class="ot">-&gt;</span> <span class="dt">Trie</span> k v</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">    embed (<span class="dt">MkTF</span> v xs) <span class="fu">=</span> <span class="dt">MkT</span> v xs</a></code></pre></div>
<p>Basically we just link the constructors and fields of <code>MkT</code> and <code>MkTF</code> together.</p>
<p>As with all boilerplate, it is sometimes useful to clean it up a bit using Template Haskell. The <em>recursion-schemes</em> library offers such splice:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Trie</span> k v <span class="fu">=</span> <span class="dt">MkT</span> (<span class="dt">Maybe</span> v) (<span class="dt">Map</span> k (<span class="dt">Trie</span> k v))</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">makeBaseFunctor &#39;&#39;<span class="dt">Trie</span></a></code></pre></div>
<p>This will define <code>TrieF</code> with the <code>MkTF</code> constructor, the <code>Base</code> type family instance, and the <code>Recursive</code> and <code>Corecursive</code> instances (in possibly a more efficient way than the way we wrote by hand, too).</p>
<h2 id="exploring-the-zoo">Exploring the Zoo</h2>
<p>Time to explore the zoo a bit! This is where the fun begins.</p>
<p>Whenever you get a new recursive type and base functor, a good “first thing” to try out is testing out <code>cata</code> and <code>ana</code> (catamorphisms and anamorphisms), the basic “folder” and “unfolder”.</p>
<h3 id="hakuna-my-cata">Hakuna My Cata</h3>
<p>Catamorphisms are functions that “combine” or “fold” every layer of our recursive type into a single value. If we want to write a function of type <code>Trie k v -&gt; A</code>, we can reach first for a catamorphism.</p>
<p>Catamorphisms work by folding layer-by-layer, from the bottom up. We can write one by defining “what to do with each layer”. This description comes in the form of an “algebra” in terms of the base functor:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">myAlg ::</span> <span class="dt">TrieF</span> k v <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">A</span></a></code></pre></div>
<p>If we think of <code>TrieF k v a</code> as “one layer” of a <code>Trie k v</code>, then <code>TrieF k v A -&gt; A</code> describes how to fold up one layer of our <code>Trie k v</code> into our final result value (here, of type <code>A</code>). Remember that a <code>TrieF k v A</code> contains a <code>Maybe v</code> and a <code>Map k A</code>. The <code>A</code> (the values of the map) contains the result of folding up all of the original subtries along each key; it’s the “results so far”.</p>
<p>And then we can use <code>cata</code> to “fold” our value along the algebra:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">cata<span class="ot"> myAlg ::</span> <span class="dt">Trie</span> k v <span class="ot">-&gt;</span> <span class="dt">A</span></a></code></pre></div>
<p><code>cata</code> starts from the bottom-most layer, runs <code>myAlg</code> on that, then goes up a layer, running <code>myAlg</code> on the results, then goes up another layer, running <code>myAlg</code> on those results, etc., until it reaches the top layer and runs <code>myAlg</code> again to produce the final result.</p>
<p>For example, we’ll write a catamorphism that counts how many values/leaves we have in our Trie into an <code>Int</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">countAlg ::</span> <span class="dt">TrieF</span> k v <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>This is the basic structure of an algebra: our final result becomes the parameter of <code>TrieF k v</code>, and also the result of our algebra.</p>
<p>Remember that a <code>Trie k v</code> contains a <code>Maybe v</code> and a <code>Map k (Trie k v)</code>, and a <code>TrieF k v Int</code> contains a <code>Maybe v</code> and a <code>Map k Int</code>. The <code>Map</code>, here in <code>countAlg</code>, represents the count of the original subtries along each key.</p>
<p>Basically, our task is “How to find a count, given a map of sub-counts”.</p>
<p>With this in mind, we can write <code>countAlg</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L64-L69</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">countAlg ::</span> <span class="dt">TrieF</span> k v <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">countAlg (<span class="dt">MkTF</span> v subtrieCounts)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    <span class="fu">|</span> isJust v  <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> subtrieTotal</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="fu">|</span> otherwise <span class="fu">=</span> subtrieTotal</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    subtrieTotal <span class="fu">=</span> sum subtrieCounts</a></code></pre></div>
<p>If <code>v</code> is indeed a leaf (it’s <code>Just</code>), then it’s one plus the total counts of all of the subtees (remember, the <code>Map k Int</code> contains the counts of all of the original subtries, under each key). Otherwise, it’s just the total counts of all of the original subtries.</p>
<p>Our final <code>count</code> is, then:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L61-L62</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">count ::</span> <span class="dt">Trie</span> k v <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">count <span class="fu">=</span> cata countAlg</a></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">ghci<span class="fu">&gt;</span> count testTrie</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="dv">3</span></a></code></pre></div>
<p>We can do something similar by writing a summer, as well, to sum up all values inside a trie:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L71-L75</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">trieSumAlg ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">TrieF</span> k a a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">trieSumAlg (<span class="dt">MkTF</span> v subtrieSums) <span class="fu">=</span> fromMaybe <span class="dv">0</span> v <span class="fu">+</span> sum subtrieSums</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="ot">trieSum ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Trie</span> k a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">trieSum <span class="fu">=</span> cata trieSumAlg</a></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">ghci<span class="fu">&gt;</span> trieSum testTrie</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="dv">14</span></a></code></pre></div>
<p>In the algebra, the <code>subtrieSums :: Map k a</code> contains the sum of all of the subtries. The algebra therefore just adds up all of the subtrie sums with the value at that layer. “How to find a sum, given a map of sub-sums”.</p>
<h4 id="outside-in">Outside-In</h4>
<p>Catamorphisms are naturally “inside-out”, or “bottom-up”. However, some operations are more naturally “outside-in”, or “top-down”. One immediate example is <code>lookup :: [k] -&gt; Trie k v -&gt; Maybe v</code>, which is clearly “top-down”: it first descends down the first item in the <code>[k]</code>, then the second, then the third, etc. until you reach the end, and return the <code>Maybe v</code> at that layer.</p>
<p>In this case, it helps to invert control: instead of folding into a <code>Maybe v</code> directly, fold into a “looker upper”, a <code>[k] -&gt; Maybe v</code>. We generate a “lookup function” from the bottom-up, and then run that all in the end on the key we want to look up.</p>
<p>Our algebra will therefore have type:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">lookupperAlg</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Ord</span> k</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    <span class="ot">=&gt;</span> <span class="dt">TrieF</span> k v ([k] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> v)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    <span class="ot">-&gt;</span> ([k] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> v)</a></code></pre></div>
<p>A <code>TrieF k v ([k] -&gt; Maybe v)</code> contains a <code>Maybe v</code> and a <code>Map k ([k] -&gt; Maybe v)</code>, or a map of “lookuppers”. Indexed at each key is function of how to look up a given key in the original subtrie.</p>
<p>So, we are tasked with “how to implement a lookupper, given a map of sub-lookuppers”.</p>
<p>To do this, we can pattern match on the key we are looking up. If it’s <code>[]</code>, then we just return the current leaf (if it exists). Otherwise, if it’s <code>k:ks</code>, we can <em>run the lookupper of the subtrie at key <code>k</code></em>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L85-L100</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">lookupperAlg</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">Ord</span> k</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">TrieF</span> k v ([k] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> v)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    <span class="ot">-&gt;</span> ([k] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> v)</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">lookupperAlg (<span class="dt">MkTF</span> v lookuppers) <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    []   <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    k<span class="fu">:</span>ks <span class="ot">-&gt;</span> <span class="kw">case</span> M.lookup k lookuppers <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">      <span class="dt">Nothing</span>        <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">      <span class="dt">Just</span> lookupper <span class="ot">-&gt;</span> lookupper ks</a>
<a class="sourceLine" id="cb15-12" data-line-number="12"></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">lookup</a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="ot">    ::</span> <span class="dt">Ord</span> k</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">    <span class="ot">=&gt;</span> [k]</a>
<a class="sourceLine" id="cb15-16" data-line-number="16">    <span class="ot">-&gt;</span> <span class="dt">Trie</span> k v</a>
<a class="sourceLine" id="cb15-17" data-line-number="17">    <span class="ot">-&gt;</span> <span class="dt">Maybe</span> v</a>
<a class="sourceLine" id="cb15-18" data-line-number="18">lookup ks t <span class="fu">=</span> cata lookupperAlg t ks</a></code></pre></div>
<p>(written using the -XLambdaCase extension, allowing for <code>\case</code> syntax)</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">ghci<span class="fu">&gt;</span> lookup <span class="st">&quot;to&quot;</span> testTrie</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="dt">Just</span> <span class="dv">9</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">ghci<span class="fu">&gt;</span> lookup <span class="st">&quot;ton&quot;</span> testTrie</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="dt">Just</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">ghci<span class="fu">&gt;</span> lookup <span class="st">&quot;tone&quot;</span> testTrie</a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="dt">Nothing</span></a></code></pre></div>
<p>Note that because <code>Map</code>s have lazy values by default, we only ever actually generate “lookuppers” for subtries under keys that we eventually descend on; any other subtries will be ignored (and no lookuppers are ever generated for them).</p>
<p>In the end, this version has all of the same performance characteristics as the explicitly recursive one; we’re assembling a “lookupper” that stops as soon as it sees either a failed lookup (so it doesn’t cause any more evaluation later on), or stops when it reaches the end of its list.</p>
<h4 id="i-think-the-system-works">I Think the System Works</h4>
<p>We’ve now written a couple of non-recursive functions to “query” <code>Trie</code>. But what was the point, again? What do we gain over writing explicit versions to query Trie? Why couldn’t we just write:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L77-L79</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">trieSumExplicit ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Trie</span> k a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">trieSumExplicit (<span class="dt">MkT</span> v subtries) <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    fromMaybe <span class="dv">0</span> v <span class="fu">+</span> sum (fmap trieSumExplicit subtries)</a></code></pre></div>
<p>instead of</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L81-L83</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="ot">trieSumCata ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Trie</span> k a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">trieSumCata <span class="fu">=</span> cata <span class="fu">$</span> \(<span class="dt">MkTF</span> v subtrieSums) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    fromMaybe <span class="dv">0</span> v <span class="fu">+</span> sum subtrieSums</a></code></pre></div>
<p>One major reason, like I mentioned before, is to avoid using <em>explicit recursion</em>. It’s extremely easy when using explicit recursion to accidentally write an infinite loop, or to mess up your control flow somehow. It’s basically like using <code>GOTO</code> instead of <code>while</code> or <code>for</code> loops in imperative languages. <code>while</code> and <code>for</code> loops are meant to abstract over a common type of looping control flow, and provide a disciplined structure for them. They also are often much easier to read, because as soon as you see “while” or “for”, it gives you a hint at programmer intent in ways that an explicit GOTO might not.</p>
<p>Another major reason is to allow you to separate concerns. Writing <code>trieSumExplicit</code> forces you to think “how to fold this entire trie”. Writing <code>trieSumAlg</code> allows us to just focus on “how to fold <em>this immediate</em> layer”. You only need to ever focus on the immediate layer you are trying to sum — and never the entire trie. <code>cata</code> takes your “how to fold this immediate layer” function and turns it into a function that folds an entire trie, taking care of the recursive descent for you.</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>Before we move on, I just wanted to mention that <code>cata</code> is not a magic function. From the clues above, you might actually be able to implement it yourself. For our <code>Trie</code>, it’s:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L102-L103</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="ot">cata&#39; ::</span> (<span class="dt">TrieF</span> k v a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Trie</span> k v <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">cata&#39; alg <span class="fu">=</span> alg <span class="fu">.</span> fmap (cata&#39; alg) <span class="fu">.</span> project</a></code></pre></div>
<p>First we <code>project :: Trie k v -&gt; TrieF k v (Trie k v)</code>, to “de-recursive” our type. Then we fmap our entire <code>cata alg :: Trie k v -&gt; a</code>. Then we run the <code>alg :: TrieF k v a -&gt; a</code> on the result. Basically, it’s fmap-collapse-then-collapse.</p>
</div>
<h3 id="ana-montana">Ana Montana</h3>
<p><em>Anamorphisms</em>, the dual of catamorphisms, are functions that “generate” or “unfold” a value of a recursive type, layer-by-layer. If we want to write a function of type <code>A -&gt; Trie k v</code>, we can reach first for an anamorphism.</p>
<p>Anamorphisms work by unfolding “layer-by-layer”, from the outside-in (or top-down). We write one by defining “how to generate the next layer”. This description comes in the form of a “coalgebra” (pronounced like “co-algebra”, and not like coal energy “coal-gebra”), in terms of the base functor:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">myCoalg ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">TrieF</span> k v <span class="dt">A</span></a></code></pre></div>
<p>If we think of <code>TrieF k v a</code> as “one layer” of a <code>Trie k v</code>, then <code>A -&gt; TrieF k v A</code> describes how to generate a new nested layer of our <code>Trie k v</code> from our initial “seed” (here, of type <code>A</code>). It tells us how to generate the next immediate layer. Remember that a <code>TrieF k v A</code> contains a <code>Maybe v</code> and a <code>Map k A</code>. The <code>A</code> (the values of the map) are then used to seed the <em>new</em> subtries. The <code>A</code> is the “continue expanding with…” value.</p>
<p>And then we can use <code>ana</code> to “unfold” our value along the coalgebra:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">ana<span class="ot"> myCoalg ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Trie</span> k v</a></code></pre></div>
<p><code>ana</code> starts from the an initial seed <code>A</code>, runs <code>myCoalg</code> on that, and then goes down a layer, running <code>myCoalg</code> on each value in the map to create new layers, etc., forever and ever. In practice, it usually stops when we return a <code>TrieF</code> with an empty map, since there are no more seeds to expand down. However, it’s nice to remember we don’t have to special-case this behavior: it arises naturally from the structure of maps.</p>
<p>While I don’t have a concrete “universal” example (like how we had <code>count</code> and <code>sum</code> for `cata1), the general idea is that if you want to create a value by repeatedly “expanding leaves”, an anamorphism is a perfect fit.</p>
<p>An example here that fits will with the nature of a trie is to produce a “singleton trie”: a trie that has only a single value at a single trie.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L108-L112</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="ot">mkSingletonCoalg ::</span> v <span class="ot">-&gt;</span> ([k] <span class="ot">-&gt;</span> <span class="dt">TrieF</span> k v [k])</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">mkSingletonCoalg v <span class="fu">=</span> singletonCoalg</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">    singletonCoalg []     <span class="fu">=</span> <span class="dt">MkTF</span> (<span class="dt">Just</span> v) M.empty</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    singletonCoalg (k<span class="fu">:</span>ks) <span class="fu">=</span> <span class="dt">MkTF</span> <span class="dt">Nothing</span>  (M.singleton k ks)</a></code></pre></div>
<p>Given a <code>v</code> value, we’ll make a coalgebra <code>[k] -&gt; TrieF k v [k]</code>. Our “seed” will be the <code>[k]</code> key we want to insert, and we’ll generate our singleton key by making sub-maps with sub-keys.</p>
<p>Our coalgebra (“layer generating function”) goes like this:</p>
<ol type="1">
<li><p>If our key-to-insert is empty <code>[]</code>, then we’re here! We’re at <em>the layer</em> where we want to insert the value at, so <code>MkTF (Just v) M.empty</code>. Returning <code>M.empty</code> means that we don’t want to expand anymore, since there are no new seeds to expand into subtries.</p></li>
<li><p>If our key-to-insert is <em>not</em> empty, then we’re <em>not</em> here! We return <code>MkTF Nothing</code>…but we know we leave a singleton map <code>M.singleton k ks :: Map k [k]</code> leaving a single seed. When we run our coalgebra with <code>ana</code>, <code>ana</code> will go down and expand out that single seed (with our coalgebra) into an entire new sub-trie, with <code>ks</code> as its seed.</p></li>
</ol>
<p>So, we have <code>singleton</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L105-L106</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="ot">singleton ::</span> [k] <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">Trie</span> k v</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">singleton k v <span class="fu">=</span> ana (mkSingletonCoalg v) k</a></code></pre></div>
<p>We run the coalgebra on our initial seed (the key), and ana will run <code>singletonCoalg</code> repeatedly, expanding out all of the seeds we deposit, forever and ever (or at least until there are no more values of the seed type left, which happens if we return an empty map).</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">ghci<span class="fu">&gt;</span> singleton <span class="st">&quot;hi&quot;</span> <span class="dv">7</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="dt">MkT</span> <span class="dt">Nothing</span> <span class="fu">$</span> M.fromList [</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    (<span class="ch">&#39;h&#39;</span>, <span class="dt">MkT</span> <span class="dt">Nothing</span> <span class="fu">$</span> M.fromList [</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">        (<span class="ch">&#39;i&#39;</span>, <span class="dt">MkT</span> (<span class="dt">Just</span> <span class="dv">7</span>) M.empty )</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">      ]</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">    )</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  ]</a></code></pre></div>
<h3 id="trie-from-map">Trie from Map</h3>
<p>Now that we’ve got the basics, let’s look at a more interesting anamorphism, where we leave multiple “seeds” along many different keys in the map, to generate many different subtries from our root.</p>
<p>Let’s write a function to generate a <code>Trie k v</code> from a <code>Map [k] v</code>: Given a map of keys (as token strings), generate a prefix trie containing every key-value pair in the map.</p>
<p>This might sound complicated, but let’s remember the philosophy and approach of writing an anamorphism: “How do I generate <em>one layer</em>”?</p>
<p>Our <code>fromMapCoalg</code> will take a <code>Map [k] v</code> and generate <code>TrieF k v (Map [k] v)</code>: <em>one single layer</em> of our new Trie (in particular, the <em>top layer</em>). And the values in each of the resultant maps will be later then watered and expanded into their own fully mature subtries.</p>
<p>So, how do we generate the <em>top layer</em> of a prefix trie from a map? Well, remember, to make a <code>TrieF k v (Map [k] v)</code>, we need a <code>Maybe v</code> (the value at this layer) and a <code>Map k (Map [k] v)</code> (the map of seeds that will each expand into full subtries).</p>
<ul>
<li>If the map contains <code>[]</code> (the empty string), then there <em>is a value</em> at this layer. We will return <code>Just</code>.</li>
<li>In the <code>Map k (Map [k] v)</code>, the value at key <code>k</code> will contain all of the key-value pairs in the original map that <em>start with k</em>, not including the <code>k</code>.</li>
</ul>
<p>For a concrete example, if we start with <code>M.fromList [(&quot;to&quot;, 9), (&quot;ton&quot;, 3), (&quot;tax&quot;, 2)]</code>, then we want <code>fromMapCoalg</code> to produce:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">fromMap (M.fromList [(<span class="st">&quot;to&quot;</span>, <span class="dv">9</span>), (<span class="st">&quot;ton&quot;</span>, <span class="dv">3</span>), (<span class="st">&quot;tax&quot;</span>, <span class="dv">2</span>)])</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">MkTF</span> <span class="dt">Nothing</span> (</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">          M.fromList [</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">            (<span class="ch">&#39;t&#39;</span>, M.fromList [</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">                (<span class="st">&quot;o&quot;</span> , <span class="dv">9</span>)</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">              , (<span class="st">&quot;on&quot;</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">              , (<span class="st">&quot;ax&quot;</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">              ]</a>
<a class="sourceLine" id="cb25-9" data-line-number="9">            )</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">          ]</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">        )</a></code></pre></div>
<p>The value is <code>Nothing</code> because we don’t have the empty string, and the map at <code>t</code> contains all of the original key-value pairs that began with <code>t</code>.</p>
<p>Now that we have the concept, we can implement it using <code>Data.Map</code> combinators like <code>M.lookup</code>, <code>M.mapMaybeWithKey</code>, and <code>M.unionsWith M.union</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L114-L128</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">fromMapCoalg</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">Ord</span> k</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">Map</span> [k] v</a>
<a class="sourceLine" id="cb26-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">TrieF</span> k v (<span class="dt">Map</span> [k] v)</a>
<a class="sourceLine" id="cb26-7" data-line-number="7">fromMapCoalg mp <span class="fu">=</span> <span class="dt">MkTF</span> (M.lookup [] mp)</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">                       (M.fromListWith M.union (M.foldMapWithKey descend mp))</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">    descend []     _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">    descend (k<span class="fu">:</span>ks) v <span class="fu">=</span> [(k, M.singleton ks v)]</a>
<a class="sourceLine" id="cb26-12" data-line-number="12"></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">fromMap</a>
<a class="sourceLine" id="cb26-14" data-line-number="14"><span class="ot">    ::</span> <span class="dt">Ord</span> k</a>
<a class="sourceLine" id="cb26-15" data-line-number="15">    <span class="ot">=&gt;</span> <span class="dt">Map</span> [k] v</a>
<a class="sourceLine" id="cb26-16" data-line-number="16">    <span class="ot">-&gt;</span> <span class="dt">Trie</span> k v</a>
<a class="sourceLine" id="cb26-17" data-line-number="17">fromMap <span class="fu">=</span> ana fromMapCoalg</a></code></pre></div>
<p>And just like that, we have a way to turn a <code>Map [k]</code> into a <code>Trie k</code>…all just from describing how to make <em>the top-most layer</em>. <code>ana</code> extrapolates the rest!</p>
<p>Again, we can ask what the point of this is: why couldn’t we just write it directly recursively?</p>
<p>The answers again are the same: first, to avoid potential bugs from explicit recursion. Second, to separate concerns: instead of thinking about how to generate an entire trie, we only need to be think about how to generate a single layer. <code>ana</code> reads our mind here, and extrapolates out the entire trie.</p>
<div class="note">
<p><strong>Aside</strong></p>
<p>Again, let’s take some time to reassure ourselves that <code>ana</code> is not a magic function. You might have been able to guess how it’s implemented: it runs the coalgebra, and then fmaps re-expansion recursively.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L130-L131</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="ot">ana&#39; ::</span> (a <span class="ot">-&gt;</span> <span class="dt">TrieF</span> k v a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> k v</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">ana&#39; coalg <span class="fu">=</span> embed <span class="fu">.</span> fmap (ana&#39; coalg) <span class="fu">.</span> coalg</a></code></pre></div>
<p>First, we run the <code>coalg :: a -&gt; TrieF k v a</code>, then we fmap our entire <code>ana coalg :: a -&gt; Trie k v</code>, then we <code>embed :: TrieF k v (Trie k v) -&gt; Trie k v</code> back into our recursive type.</p>
</div>
<h2 id="down-to-business">Down to Business</h2>
<p>So those are some examples to get our feet wet; now it’s time to build our prequel meme trie!</p>
<p>We’re going to try to re-create this reference trie: (<a href="/img/entries/trie/reference-trie.png">full size here</a>)</p>
<figure>
<img src="/img/entries/trie/reference-trie.png" title="Reference trie" alt="Reference trie (credit to u/Uninventive_Username)" /><figcaption>Reference trie (credit to <a href="https://www.reddit.com/r/PrequelMemes/comments/9w59t4/i_expanded_it/">u/Uninventive_Username</a>)</figcaption>
</figure>
<p>To render our tree, we’re going to be using the <em><a href="https://hackage.haskell.org/package/graphviz">graphviz</a></em> library, which generates a <em><a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">DOT file</a></em> which the <a href="https://www.graphviz.org/">graphviz application</a> can render. The <em>graphviz</em> library directly renders a value of the graph data type from <em><a href="https://hackage.haskell.org/package/fgl">fgl</a></em>, the functional graph library that is the de-facto fleshed-out graph manipulation library of the Haskell ecosystem.</p>
<p>So, the roadmap seems straightforward:</p>
<ol type="1">
<li>Load our prequel memes into a <code>Map String PrequelMeme</code>, a map of quotes to their associated macro images</li>
<li>Use <code>ana</code> to turn a <code>Map String PrequelMeme</code> into a <code>Trie Char PrequelMeme</code></li>
<li>Use <code>cata</code> to turn a <code>Trie Char PrequelMeme</code> into a graph of nodes linked by letters, with prequel meme leaves</li>
<li>Use the <em>graphviz</em> library to turn that graph into a DOT file, to be rendered by the external graphviz application.</li>
</ol>
<p>1 and 4 are mainly fumbling around with IO and interfacing with libraries, so 2 and 3 are the interesting steps in our case. We actually already wrote 2 (in the previous section — surprise!), so that just leaves 3 to investigate.</p>
<h3 id="generating-the-graph">Generating the Graph</h3>
<p><em>fgl</em> provides a two (interchangeable) graph types; for the sake of this article, we’re going to be using <code>Gr</code> from the <em>Data.Graph.Inductive.PatriciaTree</em> module.</p>
<p>The type <code>Gr a b</code> represents a graph of vertices with labels of type <code>a</code>, and edges with labels of type <code>b</code>. In our case, for a <code>Trie k v</code>, we’ll have a graph with nodes of type <code>Maybe v</code> (the leaves, if they exist) and edges of type <code>k</code> (the token linking one node to the next).</p>
<p>Our end goal, then, is to write a function <code>Trie k v -&gt; Gr (Maybe v) k</code>. Knowing this, we can jump directly into writing an algebra:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">trieGraphAlg</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">TrieF</span> k v (<span class="dt">Gr</span> (<span class="dt">Maybe</span> v) k)</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">Gr</span> (<span class="dt">Maybe</span> v) k</a></code></pre></div>
<p>and then using <code>cata trieGraphAlg :: Trie k v -&gt; Gr (Maybe v) k</code>.</p>
<p>This isn’t a bad way to go about it, and you won’t have <em>too</em> many problems. However, this might be a good learning opportunity to try writing “monadic” catamorphisms.</p>
<p>That’s because to create a graph using <em>fgl</em>, you need to manage Node ID’s, which are represented as <code>Int</code>s. To add a node, you need to generate a fresh Node ID. <em>fgl</em> has some nice tools for managing this, but we can have some fun by taking care of it ourselves using the so-called “state monad”, <code>State Int</code>.</p>
<p>Hylomorphisms We can use <code>State Int</code> as a way to generate “fresh” node ID’s on-demand, with the action <code>fresh</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L149-L150</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="ot">fresh ::</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">fresh <span class="fu">=</span> state <span class="fu">$</span> \i <span class="ot">-&gt;</span> (i, i<span class="fu">+</span><span class="dv">1</span>)</a></code></pre></div>
<p><code>fresh</code> will return the current counter state to produce a new node ID, and then increment the counter so that the next invocation will return a new node ID.</p>
<p>In this light, we can frame our big picture as writing a <code>Trie k v -&gt; State Int (Gr (Maybe v) k)</code>: turn a <code>Trie k v</code> into a state action to generate a graph.</p>
<p>To write this, we lay out our algebra:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1">trieGraphAlg</a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">TrieF</span> k v (<span class="dt">State</span> <span class="dt">Int</span> (<span class="dt">Gr</span> (<span class="dt">Maybe</span> v) k))</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Int</span> (<span class="dt">Gr</span> (<span class="dt">Maybe</span> v) k)</a></code></pre></div>
<p>We have to write a function “how to make a state action creating a graph, given a map of state actions creating sub-graphs”.</p>
<p>One interesting thing to note is that we have a lot to gain from using “first-class effects”: <code>State Int (Gr (Maybe v) k)</code> is just a normal, inert Haskell value that we can manipulate and sequence however we want. State is not only explicit, but the sequencing of actions (as first-class values) is also explicit.</p>
<p>We can write this using <em>fgl</em> combinators:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L157-L169</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">trieGraphAlg</a>
<a class="sourceLine" id="cb31-4" data-line-number="4"><span class="ot">    ::</span> forall k v<span class="fu">.</span> ()</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">TrieF</span> k v (<span class="dt">State</span> <span class="dt">Int</span> (<span class="dt">Gr</span> (<span class="dt">Maybe</span> v) k))</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Int</span> (<span class="dt">Gr</span> (<span class="dt">Maybe</span> v) k)</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">trieGraphAlg (<span class="dt">MkTF</span> v xs) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    n         <span class="ot">&lt;-</span> fresh</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">    subgraphs <span class="ot">&lt;-</span> sequence xs</a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    <span class="kw">let</span><span class="ot"> subroots ::</span> [(k, <span class="dt">Int</span>)]</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">        subroots <span class="fu">=</span> M.toList <span class="fu">.</span> fmap (fst <span class="fu">.</span> G.nodeRange) <span class="fu">$</span> subgraphs</a>
<a class="sourceLine" id="cb31-12" data-line-number="12">    pure <span class="fu">$</span> G.insEdges ((\(k,i) <span class="ot">-&gt;</span> (n,i,k)) <span class="fu">&lt;$&gt;</span> subroots)   <span class="co">-- insert root-to-subroots</span></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">         <span class="fu">.</span> G.insNode (n, v)                     <span class="co">-- insert new root</span></a>
<a class="sourceLine" id="cb31-14" data-line-number="14">         <span class="fu">.</span> M.foldr (G.ufold (<span class="fu">G.&amp;</span>)) G.empty      <span class="co">-- merge all subgraphs</span></a>
<a class="sourceLine" id="cb31-15" data-line-number="15">         <span class="fu">$</span> subgraphs</a></code></pre></div>
<ol type="1">
<li><p>First, generate a fresh node label</p></li>
<li><p>Then, sequence all of the state actions inside the map of sub-graph generators. Remember, a <code>TrieF k v (State Int (Gr (Maybe v) k))</code> contains a <code>Maybe v</code> and a <code>Map k (State Int (Gr (Maybe v) k))</code>. The map contains State actions to create the sub-graphs, and we use:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">sequence</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Map</span> k (<span class="dt">State</span> <span class="dt">Int</span> (<span class="dt">Gr</span> (<span class="dt">Maybe</span> v) k))</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Int</span> (<span class="dt">Map</span> k (<span class="dt">Gr</span> (<span class="dt">Maybe</span> v) k))</a></code></pre></div>
<p>To turn a map of subgraph-producing actions into an action producing a map of subgraphs.</p></li>
<li><p>Next, it’s useful to collect all of the subroots, <code>subroots :: [(k, Int)]</code>. These are all of the node id’s of the roots of each of the subtrees, paired with the token leading to that subtree.</p></li>
<li><p>Now to generate our result:</p>
<ol type="a">
<li>First we merge all subgraphs (using <code>G.ufold (G.&amp;)</code> to merge together two graphs)</li>
<li>Then, we insert the new root, with our fresh node ID and the new <code>Maybe v</code> label.</li>
<li>Then, we insert all of the edges connecting our new root to the root of all our subgraphs (in <code>subroots</code>).</li>
</ol></li>
</ol>
<p>We can then write our graph generating function using this algebra, and then running the resulting <code>State Int (Gr (Maybe v) k)</code> action:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L152-L155</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2"></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">trieGraph</a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">Trie</span> k v</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">Gr</span> (<span class="dt">Maybe</span> v) k</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">trieGraph <span class="fu">=</span> flip evalState <span class="dv">0</span> <span class="fu">.</span> cata trieGraphAlg</a></code></pre></div>
<p>Finally, we can write our <code>mapToGraph</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">mapToGraph</a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Ord</span> k</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    <span class="ot">=&gt;</span> <span class="dt">Map</span> [k] v</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">Gr</span> (<span class="dt">Maybe</span> v) k</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">mapToGraph <span class="fu">=</span> flip evalState <span class="dv">0</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6">           <span class="fu">.</span> cata trieGraphAlg</a>
<a class="sourceLine" id="cb34-7" data-line-number="7">           <span class="fu">.</span> ana fromGraphCoalg</a></code></pre></div>
<h3 id="hylomorphisms">Hylomorphisms</h3>
<p>Actually, writing things out as <code>mapToGraph</code> gives us some interesting insight: our function takes a <code>Map [k] v</code>, and returns a <code>Gr (Maybe v) k</code>. Notice that <code>Trie k v</code> isn’t anywhere in the type signature. This means that, to, the external user, <code>Trie</code>’s role is completely “internal”.</p>
<p>In other words, <code>Trie</code> “doesn’t matter” at all. We really want a <code>Map [k] v -&gt; Graph (Maybe v) k</code>. We’re using <code>Trie</code> as an <em>intermediate data structure</em>. We are exploiting its structure to do write our full function, and we don’t care about it outside of that. We build it up with <code>ana</code> and then immediately tear it down with <code>cata</code>, and it is completely invisible to the outside world.</p>
<p>One neat thing about <em>recursion-schemes</em> is that it lets us capture this “the actual fixed-point is only intermediate and is not directly consequential to the outside world” pattern. The logic goes like this:</p>
<ul>
<li>We don’t care about <code>Trie</code> itself as a result our input. We only care about it because we exploit its internal structure.</li>
<li><code>TrieF</code> already expresses the internal structure of <code>Trie</code></li>
<li>Therefore, if we only want to take advantage of the structure (and not use <code>Trie</code> as a direct input or output), we can use <code>TrieF</code> <em>only</em>, completely bypassing <code>Trie</code>.</li>
</ul>
<p>This <em>should</em> make sense, because the only reason we use <code>Trie</code> is for its internal structure. But <code>TrieF</code> already captures the internal structure so we really only need to ever worry about <code>TrieF</code>. We don’t actually care about the recursive data type — we never did!</p>
<p>So, <em>recursion-schemes</em> offers the <em>hylomorphism</em>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1">hylo</a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">TrieF</span> k v b <span class="ot">-&gt;</span> b)   <span class="co">-- ^ an algebra</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3">    <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">TrieF</span> k v a)   <span class="co">-- ^ a coalgebra</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4">    <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">    <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>If we see the coalgebra <code>a -&gt; TrieF k v a</code> as a “building” function, and the algebra <code>TrieF k v b -&gt; b</code> as a “consuming” function, then <code>hylo</code> will <em>build, then immediately consume</em>. It’ll build with the coalgebra on <code>TrieF</code>, then immediately consume with the algebra on <code>TrieF</code>. No <code>Trie</code> is ever generated, because it’s never necessary: we’re literally just building and immediately consuming <code>TrieF</code> values.</p>
<p>We could even implement <code>hylo</code> ourselves, to illustrate the “build and immediately consume” property:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L177-L184</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2"></a>
<a class="sourceLine" id="cb36-3" data-line-number="3">hylo&#39;</a>
<a class="sourceLine" id="cb36-4" data-line-number="4"><span class="ot">    ::</span> (<span class="dt">TrieF</span> k v b <span class="ot">-&gt;</span> b)   <span class="co">-- ^ an algebra</span></a>
<a class="sourceLine" id="cb36-5" data-line-number="5">    <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">TrieF</span> k v a)   <span class="co">-- ^ a coalgebra</span></a>
<a class="sourceLine" id="cb36-6" data-line-number="6">    <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb36-7" data-line-number="7">    <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb36-8" data-line-number="8">hylo&#39; consume build <span class="fu">=</span> consume</a>
<a class="sourceLine" id="cb36-9" data-line-number="9">                    <span class="fu">.</span> fmap (hylo&#39; consume build)</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">                    <span class="fu">.</span> build</a></code></pre></div>
<p>Note that the implementation of <code>hylo</code> works for any <code>Functor</code> instance: we build and consume along any <code>Functor</code>, taking advantage of the specific functor’s structure.</p>
<p>To me, implementing a function in terms of <code>hylo</code> (or its cousin <code>chrono</code>, the chronomorphism) represents the ultimate “victory” in using <em>recursion-schemes</em> to refactor out your recursive functions. That’s because it helps us realize that we never really <em>cared</em> about having a recursive data type. <code>Trie</code> was never the actual thing we wanted: we just wanted the layer-by-layer structure. This whole time, we just cared about the structure of <code>TrieF</code> (and its structure), <em>not</em> <code>Trie</code>. Being able to use <code>hylo</code> lets us see that the original recursive data type was nothing more than a distraction. Through it, we see the light.</p>
<h3 id="the-full-package">The Full Package</h3>
<p>Now time to wrap things up. I made a text file storing all of the prequel quotes in the original reference trie, along with images stored on my drive:</p>
<pre><code>-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/quotes.txt

I DON&#39;T THINK SO,img/idts.jpg
I DON&#39;T THINK THE SYSTEM WORKS,img/idttsw.jpg
I HAVE BEEN LOOKING FORWARD TO THIS,img/iblftt.jpg
I HAVE A BAD FEELING ABOUT THIS,img/ihabfat.jpg
IT&#39;S TREASON THEN,img/itt.jpg
IT&#39;S OUTRAGEOUS IT&#39;S UNFAIR,img/tioiu.jpg</code></pre>
<p>We can write a quick parser and aggregator into a <code>Map [Char] Label</code>, where <code>Label</code> is from the <em>graphviz</em> library, a renderable object to display on the final image.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L186-L192</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"></a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="ot">memeMap ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">HTML.Label</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4">memeMap <span class="fu">=</span> M.fromList <span class="fu">.</span> map (uncurry processLine <span class="fu">.</span> span (<span class="fu">/=</span> <span class="ch">&#39;,&#39;</span>)) <span class="fu">.</span> lines</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-6" data-line-number="6">    processLine qt (drop <span class="dv">1</span><span class="ot">-&gt;</span>img) <span class="fu">=</span> (filter (not <span class="fu">.</span> isSpace) qt, <span class="dt">HTML.Table</span> (<span class="dt">HTML.HTable</span> <span class="dt">Nothing</span> [] [r1,r2]))</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-8" data-line-number="8">        r1 <span class="fu">=</span> <span class="dt">HTML.Cells</span> [<span class="dt">HTML.LabelCell</span> [] (<span class="dt">HTML.Text</span> [<span class="dt">HTML.Str</span> (T.pack qt)])]</a>
<a class="sourceLine" id="cb38-9" data-line-number="9">        r2 <span class="fu">=</span> <span class="dt">HTML.Cells</span> [<span class="dt">HTML.ImgCell</span>   [] (<span class="dt">HTML.Img</span> [<span class="dt">HTML.Src</span> img])]</a></code></pre></div>
<p>A small utility function to clean up our final graph; it deletes nodes that only have one child and compacts them into the node above. It’s just to “compress” together strings of nodes that don’t have any forks.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L212-L223</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2"></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">compactify</a>
<a class="sourceLine" id="cb39-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">Gr</span> (<span class="dt">Maybe</span> v) k</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">Gr</span> (<span class="dt">Maybe</span> v) [k]</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">compactify g0 <span class="fu">=</span> foldl&#39; go (G.emap (<span class="fu">:</span>[]) g0) (G.labNodes g0)</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-8" data-line-number="8">    go g (i, v) <span class="fu">=</span> <span class="kw">case</span> (G.inn g i, G.out g i) <span class="kw">of</span></a>
<a class="sourceLine" id="cb39-9" data-line-number="9">      ([(j, _, lj)], [(_, k, lk)])</a>
<a class="sourceLine" id="cb39-10" data-line-number="10">        <span class="fu">|</span> isNothing v <span class="ot">-&gt;</span> G.insEdge (j, k, lj <span class="fu">++</span> lk)</a>
<a class="sourceLine" id="cb39-11" data-line-number="11">                       <span class="fu">.</span> G.delNode i</a>
<a class="sourceLine" id="cb39-12" data-line-number="12">                       <span class="fu">.</span> G.delEdges [(j,i),(i,k)]</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">                       <span class="fu">$</span> g</a>
<a class="sourceLine" id="cb39-14" data-line-number="14">      _               <span class="ot">-&gt;</span> g</a></code></pre></div>
<p>We can directly output a compacted graph from <code>graphAlg</code>, but for the sake of this post it’s a bit cleaner to separate out these concerns.</p>
<p>We’ll write a function to turn a <code>Gr (Maybe v) [Char]</code> into a dot file, using <em>graphviz</em> to do most of the work:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L194-L205</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2"></a>
<a class="sourceLine" id="cb40-3" data-line-number="3">graphDot</a>
<a class="sourceLine" id="cb40-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">GV.Labellable</span> v</a>
<a class="sourceLine" id="cb40-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">Gr</span> (<span class="dt">Maybe</span> v) <span class="dt">String</span></a>
<a class="sourceLine" id="cb40-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">T.Text</span></a>
<a class="sourceLine" id="cb40-7" data-line-number="7">graphDot <span class="fu">=</span> GV.printIt <span class="fu">.</span> GV.graphToDot params</a>
<a class="sourceLine" id="cb40-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-9" data-line-number="9">    params <span class="fu">=</span> GV.nonClusteredParams</a>
<a class="sourceLine" id="cb40-10" data-line-number="10">      { fmtNode <span class="fu">=</span> \(_,  l) <span class="ot">-&gt;</span> <span class="kw">case</span> l <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-11" data-line-number="11">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> [GV.shape <span class="dt">GV.PointShape</span>]</a>
<a class="sourceLine" id="cb40-12" data-line-number="12">          <span class="dt">Just</span> l&#39; <span class="ot">-&gt;</span> [GV.toLabel l&#39;, GV.shape <span class="dt">GV.PlainText</span>]</a>
<a class="sourceLine" id="cb40-13" data-line-number="13">      , fmtEdge <span class="fu">=</span> \(_,_,l) <span class="ot">-&gt;</span> [GV.toLabel (concat [<span class="st">&quot;[&quot;</span>, l, <span class="st">&quot;]&quot;</span>])]</a>
<a class="sourceLine" id="cb40-14" data-line-number="14">      }</a></code></pre></div>
<p>And finally, to wrap it all together, the entire pipeline:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L207-L210</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2"></a>
<a class="sourceLine" id="cb41-3" data-line-number="3">memeDot</a>
<a class="sourceLine" id="cb41-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb41-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">T.Text</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6">memeDot <span class="fu">=</span> graphDot <span class="fu">.</span> compactify <span class="fu">.</span> mapToGraph <span class="fu">.</span> memeMap</a></code></pre></div>
<p>Giving us our final result: (<a href="/img/entries/trie/meme-trie.png">full size here</a>)</p>
<figure>
<img src="/img/entries/trie/meme-trie.png" title="Our final result" alt="Our rendered dotfile, using graphviz" /><figcaption>Our rendered dotfile, using graphviz</figcaption>
</figure>
<p>There are definitely some things we can tweak with respect to formatting and position and font sizes and label layouts, but I think this is fairly faithful!</p></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Beginner/Intermediate Haskell Projects&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+beginner-intermediate-haskell-projects.html" class="tag-a-series" title="+Beginner/Intermediate Haskell Projects"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category">@TUTORIALS</a></li><li><a href="https://blog.jle.im/entries/series/+beginner-intermediate-haskell-projects.html" class="tag-a-series">+Beginner/Intermediate Haskell Projects</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/tries-with-recursion-schemes.html';
    this.page.identifier = 'trie';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>