\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Introduction to Singletons (Part 4)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Introduction to Singletons (Part 4)}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/introduction-to-singletons-4.html}{in
Code}}.}

Hi again! Welcome back; let's jump right into part 4 of our journey through the
\emph{singleton design pattern} and the great
\emph{\href{http://hackage.haskell.org/package/singletons}{singletons}} library!

Please check out
\href{https://blog.jle.im/entries/series/+introduction-to-singletons.html}{the
first three parts of the series} and make sure you are comfortable with them
before reading on. I definitely also recommend trying out some or all of the
exercises, since we are going to be building on the concepts in those posts in a
pretty heavy way.

Today we're going to jump straight into \emph{functional programming} at the
type level!

\hypertarget{review}{%
\section{Review}\label{review}}

Just as a quick review, this entire series we have been working with a
\texttt{Door} type:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  data DoorState = Opened | Closed | Locked}
\NormalTok{    deriving (Show, Eq)}
\NormalTok{  |])}

\KeywordTok{data} \DataTypeTok{Door}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::}\NormalTok{ \{}\OtherTok{ doorMaterial ::} \DataTypeTok{String}\NormalTok{ \} }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}
\end{Highlighting}
\end{Shaded}

And we talked about using \texttt{Sing\ s}, or \texttt{SDoorState\ s}, to
represent the state of the door (in its type) as a run-time value. We've been
using a wrapper to existentially hide the door state type, but also stuffing in
a singleton to let us recover the type information once we want it again:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}

\OtherTok{mkSomeDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{mkSomeDoor ds mat }\FunctionTok{=}\NormalTok{ withSomeSing ds }\FunctionTok{$}\NormalTok{ \textbackslash{}dsSing }\OtherTok{->}
    \DataTypeTok{MkSomeDoor}\NormalTok{ dsSing (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ mat)}
\end{Highlighting}
\end{Shaded}

In Part 3 we talked about a \texttt{Pass} data type that we used to talk about
whether or not we can walk through or knock on a door:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  data Pass = Obstruct | Allow}
\NormalTok{    deriving (Show, Eq)}
\NormalTok{  |])}
\end{Highlighting}
\end{Shaded}

And we defined type-level functions on it using \emph{singletons} Template
Haskell:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  statePass :: DoorState -> Pass}
\NormalTok{  statePass Opened = Allow}
\NormalTok{  statePass Closed = Obstruct}
\NormalTok{  statePass Locked = Obstruct}
\NormalTok{  |])}
\end{Highlighting}
\end{Shaded}

This essentially generates these three things:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{statePass ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Pass}
\NormalTok{statePass }\DataTypeTok{Opened} \FunctionTok{=} \DataTypeTok{Allow}
\NormalTok{statePass }\DataTypeTok{Closed} \FunctionTok{=} \DataTypeTok{Obstruct}
\NormalTok{statePass }\DataTypeTok{Locked} \FunctionTok{=} \DataTypeTok{Obstruct}

\KeywordTok{type}\NormalTok{ family }\DataTypeTok{StatePass}\NormalTok{ (}\OtherTok{s ::} \DataTypeTok{DoorState}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Pass} \KeywordTok{where}
    \DataTypeTok{StatePass}\NormalTok{ '}\DataTypeTok{Opened} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Allow}
    \DataTypeTok{StatePass}\NormalTok{ '}\DataTypeTok{Closed} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Obstruct}
    \DataTypeTok{StatePass}\NormalTok{ '}\DataTypeTok{Locked} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Obstruct}

\OtherTok{sStatePass ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\DataTypeTok{StatePass}\NormalTok{ s)}
\NormalTok{sStatePass }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->} \DataTypeTok{SAllow}
    \DataTypeTok{SClosed} \OtherTok{->} \DataTypeTok{SObstruct}
    \DataTypeTok{SLocked} \OtherTok{->} \DataTypeTok{SObstruct}
\end{Highlighting}
\end{Shaded}

And we can use \texttt{StatePass} as a type-level function while using
\texttt{sStatePass} to manipulate the singletons representing \texttt{s} and
\texttt{StatePass\ s}.

We used this as a constraint to restrict how we can call our functions:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knockP ::}\NormalTok{ (}\DataTypeTok{StatePass}\NormalTok{ s }\FunctionTok{~}\NormalTok{ '}\DataTypeTok{Obstruct}\NormalTok{) }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knockP d }\FunctionTok{=}\NormalTok{ putStrLn }\FunctionTok{$} \StringTok{"Knock knock on "} \FunctionTok{++}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" door!"}
\end{Highlighting}
\end{Shaded}

But then we wondered\ldots{}is there a way to not only \emph{restrict} our
functions, but to describe how the inputs and outputs are related to each other?

\hypertarget{inputs-and-outputs}{%
\section{Inputs and Outputs}\label{inputs-and-outputs}}

In the past we have settled with very simple relationships, like:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{closeDoor ::} \DataTypeTok{Door}\NormalTok{ '}\DataTypeTok{Opened} \OtherTok{->} \DataTypeTok{Door}\NormalTok{ '}\DataTypeTok{Closed}
\NormalTok{closeDoor (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor}\NormalTok{ m}
\end{Highlighting}
\end{Shaded}

This means that the relationship between the input and output is that the input
is opened\ldots{}and is then closed.

However, armed with promotion of type-level functions, writing more complex
relationships becomes fairly straightforward!

We can write a function \texttt{mergeDoor} that ``merges'' two doors together,
in sequence:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mergeDoor ::} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ t }\OtherTok{->} \DataTypeTok{Door} \FunctionTok{????}
\NormalTok{mergeDoor d e }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{$}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" and "} \FunctionTok{++}\NormalTok{ doorMaterial e}
\end{Highlighting}
\end{Shaded}

A merged door will have a material that is composite of the original materials.
But, what will the new \texttt{DoorState} be? What goes in the \texttt{???}
above?

Well, if we can write the function as a normal function in
values\ldots{}\emph{singletons} lets us use it as a function on types. Let's
write that relationship. Let's say merging takes on the higher ``security''
option --- merging opened with locked is locked, merging closed with opened is
closed, merging locked with closed is locked.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  mergeState :: DoorState -> DoorState -> DoorState}
\NormalTok{  mergeState Opened d      = d}
\NormalTok{  mergeState Closed Opened = Closed}
\NormalTok{  mergeState Closed Closed = Closed}
\NormalTok{  mergeState Closed Locked = Locked}
\NormalTok{  mergeState Locked _      = Locked}
\NormalTok{  |])}

\CommentTok{-- Alternatively, taking advantage of the derived Ord instance:}
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  mergeState :: DoorState -> DoorState -> DoorState}
\NormalTok{  mergeState = max}
\NormalTok{  |])}
\end{Highlighting}
\end{Shaded}

This makes writing \texttt{mergeDoor}'s type fairly straightforward!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mergeDoor}
\OtherTok{    ::} \DataTypeTok{Door}\NormalTok{ s}
    \OtherTok{->} \DataTypeTok{Door}\NormalTok{ t}
    \OtherTok{->} \DataTypeTok{Door}\NormalTok{ (}\DataTypeTok{MergeState}\NormalTok{ s t)}
\NormalTok{mergeDoor d e }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{$}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" and "} \FunctionTok{++}\NormalTok{ doorMaterial e}
\end{Highlighting}
\end{Shaded}

And, with the help of singletons, we can also write this for our doors where we
don't know the types until runtime:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mergeSomeDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{mergSomeDoor (}\DataTypeTok{MkSomeDoor}\NormalTok{ s d) (}\DataTypeTok{MkSomeDoor}\NormalTok{ t e) }\FunctionTok{=}
    \DataTypeTok{MkSomeDoor}\NormalTok{ (sMergeState s t) (mergeDoor d e)}
\end{Highlighting}
\end{Shaded}

To see why this typechecks properly, compare the types of \texttt{sMergeState}
and \texttt{mergeDoor}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{sMergeState ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ t }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\DataTypeTok{MergeState}\NormalTok{ s t)}
\OtherTok{mergeDoor   ::} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ t }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\DataTypeTok{MergeState}\NormalTok{ s t)}

\DataTypeTok{MkSomeDoor}\OtherTok{  ::} \DataTypeTok{Sing}\NormalTok{ (}\DataTypeTok{MergeState}\NormalTok{ s t) }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ (}\DataTypeTok{MergeState}\NormalTok{ s t) }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

Because the results both create types \texttt{MergeState\ s\ t},
\texttt{MkSomeDoor} is happy to apply them to each other, and everything
typechecks. However, if, say, we directly stuffed \texttt{s} or \texttt{t} into
\texttt{MkSomeDoor}, things would fall apart and not typecheck.

And so now we have full expressiveness in determining input and output
relationships! Once we unlock the power of type-level functions with
\emph{singletons}, writing type-level relationships become as simple as writing
value-level ones. If you can write a value-level function, you can write a
type-level function!

\hypertarget{kicking-it-up-a-notch}{%
\subsection{Kicking it up a notch}\label{kicking-it-up-a-notch}}

Alright, so let's see how far we can really take this!

Let's make a data type that represents a \emph{series of hallways}, each linked
by a door. A hallway is either an empty stretch with no door, or two hallways
linked by a door. We'll structure it like a linked list, and store the list of
all door states as a type-level list as a type parameter:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Hallway}\OtherTok{ ::}\NormalTok{ [}\DataTypeTok{DoorState}\NormalTok{] }\OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{HEnd}\OtherTok{  ::} \DataTypeTok{Hallway}\NormalTok{ '[]}
    \CommentTok{-- ^ end of the hallway, a stretch with no doors}
\OtherTok{    (:<#) ::} \DataTypeTok{Door}\NormalTok{ s}
          \OtherTok{->} \DataTypeTok{Hallway}\NormalTok{ ss}
          \OtherTok{->} \DataTypeTok{Hallway}\NormalTok{ (s '}\FunctionTok{:}\NormalTok{ ss)}
    \CommentTok{-- ^ A door connected to a hallway is a new}
    \CommentTok{--   hallway, and we track the door's state in the list}
    \CommentTok{--   of hallway door states}

\KeywordTok{infixr} \DecValTok{5} \FunctionTok{:<#}
\end{Highlighting}
\end{Shaded}

So we might have:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ door1 }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Closed} \StringTok{"Oak"}
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ door2 }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Opened} \StringTok{"Spruce"}
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ door3 }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Locked} \StringTok{"Acacia"}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t door1 }\FunctionTok{:<#}\NormalTok{ door2 }\FunctionTok{:<#}\NormalTok{ door3 }\FunctionTok{:<#} \DataTypeTok{HEnd}
\DataTypeTok{Hallway}\NormalTok{ '[ '}\DataTypeTok{Closed}\NormalTok{, '}\DataTypeTok{Opened}\NormalTok{, '}\DataTypeTok{Locked}\NormalTok{ ]}
\end{Highlighting}
\end{Shaded}

That is, a \texttt{Hallway\ \textquotesingle{}{[}\ s,\ t,\ u\ {]}} is a hallway
consisting of a \texttt{Door\ s}, a \texttt{Door\ t}, and a \texttt{Door\ u},
constructed like a linked list in Haskell.

Now, let's write a function to \emph{collapse all doors in a hallway down to a
single door}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{collapseHallway ::} \DataTypeTok{Hallway}\NormalTok{ ss }\OtherTok{->} \DataTypeTok{Door} \FunctionTok{?????}
\end{Highlighting}
\end{Shaded}

Basically, we want to merge all of the doors one after the other, collapsing it
until we have a single door state. Luckily, \texttt{MergeState} is both
commutative and associative and has an identity, so this can be defined
sensibly.

First, let's think about the type we want. What will the result of merging
\texttt{ss} be?

We can pattern match and collapse an entire list down item-by-item:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  mergeStates :: [DoorState] -> DoorState}
\NormalTok{  mergeStates []     = Opened               -- ^ the identity of mergeState}
\NormalTok{  mergeStates (s:ss) = s `mergeState` mergeStates ss}
\NormalTok{  |])}
\end{Highlighting}
\end{Shaded}

Again, remember that this also defines the type family \texttt{MergeStateList}
and the singleton function
\texttt{sMergeStateList\ ::\ Sing\ ss\ -\textgreater{}\ Sing\ (MergeStateList\ ss)}.

With this, we can write \texttt{collapseHallway}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{collapseHallway ::} \DataTypeTok{Hallway}\NormalTok{ ss }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ (}\DataTypeTok{MergeStateList}\NormalTok{ ss)}
\NormalTok{collapseHallway }\DataTypeTok{HEnd}       \FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \StringTok{"End of Hallway"}
\NormalTok{collapseHallway (d }\FunctionTok{:<#}\NormalTok{ ds) }\FunctionTok{=}\NormalTok{ d }\OtherTok{`mergeDoor`}\NormalTok{ collapseHallway ds}
\end{Highlighting}
\end{Shaded}

Now, because the structure of \texttt{collapseHallway} perfectly mirrors the
structure of \texttt{mergeStates}, this all typechecks, and we're done!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ collapseHallway (door1 }\FunctionTok{:<#}\NormalTok{ door2 }\FunctionTok{:<#}\NormalTok{ door3 }\FunctionTok{:<#} \DataTypeTok{HEnd}\NormalTok{)}
\DataTypeTok{UnsafeMkDoor} \StringTok{"Oak and Spruce and Acacia and End of Hallway"}
\OtherTok{    ::} \DataTypeTok{Door}\NormalTok{ '}\DataTypeTok{Locked}
\end{Highlighting}
\end{Shaded}

Note one nice benefit -- the door state of
\texttt{collapseHallway\ (door1\ :\textless{}\#\ door2\ :\textless{}\#\ door3\ :\textless{}\#\ HEnd)}
is known at compile-time to be \texttt{Door\ \textquotesingle{}Locked}, if the
types of all of the component doors are also known!

\hypertarget{functional-programming}{%
\section{Functional Programming}\label{functional-programming}}

We went over that all a bit fast, but some of you might have noticed that the
definition of \texttt{mergeStates} bears a really strong resemblance to a very
common Haskell list processing pattern:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mergeStates ::}\NormalTok{ [}\DataTypeTok{DoorState}\NormalTok{] }\OtherTok{->} \DataTypeTok{DoorState}
\NormalTok{mergeStates []     }\FunctionTok{=} \DataTypeTok{Opened}               \CommentTok{-- ^ the identity of mergeState}
\NormalTok{mergeStates (s}\FunctionTok{:}\NormalTok{ss) }\FunctionTok{=}\NormalTok{ s }\OtherTok{`mergeState`}\NormalTok{ mergeStates ss}
\end{Highlighting}
\end{Shaded}

We replace all \texttt{{[}{]}} with \texttt{Opened}, and all \texttt{(:)} with
\texttt{mergeState}. Yup --- this is exactly a \texttt{foldr}!

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mergeStates ::}\NormalTok{ [}\DataTypeTok{DoorState}\NormalTok{] }\OtherTok{->} \DataTypeTok{DoorState}
\NormalTok{mergeState }\FunctionTok{=}\NormalTok{ foldr mergeState }\DataTypeTok{Opened}
\end{Highlighting}
\end{Shaded}

In Haskell, we are always encouraged to use higher-order functions whenever
possible instead of explicit recursion, both because explicit recursion opens
you up to a lot of potential bugs, and also because using established
higher-order functions make your code more readable.

So, as Haskellers, let us hold ourselves to a higher standard and not be
satisfied with a \texttt{MergeState} written using explicit recursion. Let us
instead go \emph{full fold}! ONWARD HO!

\hypertarget{the-problem}{%
\subsection{The Problem}\label{the-problem}}

Initial attempts to write a higher-order type-level function as a type family,
however, serve to temper our enthusiasm.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ family }\DataTypeTok{MergeState}\NormalTok{ (}\OtherTok{s ::} \DataTypeTok{DoorState}\NormalTok{) (}\OtherTok{t ::} \DataTypeTok{DoorState}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{DoorState} \KeywordTok{where}
    \DataTypeTok{MergeState}\NormalTok{ s t }\FunctionTok{=} \DataTypeTok{Max}\NormalTok{ s t}

\KeywordTok{type}\NormalTok{ family }\DataTypeTok{Foldr}\NormalTok{ (}\OtherTok{f ::}\NormalTok{ j }\OtherTok{->}\NormalTok{ k }\OtherTok{->}\NormalTok{ k) (}\OtherTok{z ::}\NormalTok{ k) (}\OtherTok{xs ::}\NormalTok{ [j])}\OtherTok{ ::}\NormalTok{ k }\KeywordTok{where}
    \DataTypeTok{Foldr}\NormalTok{ f z '[]       }\FunctionTok{=}\NormalTok{ z}
    \DataTypeTok{Foldr}\NormalTok{ f z (x '}\FunctionTok{:}\NormalTok{ xs) }\FunctionTok{=}\NormalTok{ f x (}\DataTypeTok{Foldr}\NormalTok{ f z xs)}
\end{Highlighting}
\end{Shaded}

So far so good right? So we should expect to be able to write
\texttt{MergeStateList} using \texttt{Foldr}, \texttt{MergeState}, and
\texttt{\textquotesingle{}Opened}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ family }\DataTypeTok{MergeStateList}\NormalTok{ (}\OtherTok{ss ::}\NormalTok{ [}\DataTypeTok{DoorState}\NormalTok{])}\OtherTok{ ::} \DataTypeTok{DoorState} \KeywordTok{where}
    \DataTypeTok{MergeStateList}\NormalTok{ ss }\FunctionTok{=} \DataTypeTok{Foldr} \DataTypeTok{MergeState}\NormalTok{ '}\DataTypeTok{Opened}\NormalTok{ ss}
\end{Highlighting}
\end{Shaded}

Ah, but the compiler is here to tell you this isn't allowed in Haskell:

\begin{verbatim}
    â€¢ The type family â€˜MergeStateâ€™ should have 2 arguments, but has been given none
    â€¢ In the equations for closed type family â€˜MergeStateListâ€™
      In the type family declaration for â€˜MergeStateListâ€™
\end{verbatim}

What happened? To figure out, we have to remember that pesky restriction on type
synonyms and type families: they \emph{cannot} be partially applied, and must
always be fully applied. For the most part, only \emph{type constructors} (like
\texttt{Maybe}, \texttt{Either}, \texttt{IO}) and lifted DataKinds data
constructors (like \texttt{\textquotesingle{}Just},
\texttt{\textquotesingle{}(:)}) in Haskell can ever be partially applied at the
type level. We therefore can't use \texttt{MergeState} as an argument to
\texttt{Foldr}, because \texttt{MergeState} must always be fully applied.

Unfortunately for us, this makes our \texttt{Foldr} effectively useless. That's
because we're always going to want to pass in type families (like
\texttt{MergeState}), so there's pretty much literally no way to ever actually
call \texttt{Foldr} except with type constructors or lifted DataKinds data
constructors.

So\ldots{}back to the drawing board?

\hypertarget{defunctionalization}{%
\section{Defunctionalization}\label{defunctionalization}}

I like to mentally think of the \emph{singletons} library as having two parts:
the first is linking lifted DataKinds types with run-time values to allow us to
manipulate types at runtime as first-class values. The second is a system for
effective \emph{functional programming} at the type level.

To make a working \texttt{Foldr}, we're going to have to jump into that second
half:
\emph{\href{https://en.wikipedia.org/wiki/Defunctionalization}{defunctionalization}}.

Defunctionalization is a technique invented in the early 70's to convert
higher-order functions into first-order functions. The main idea is:

\begin{itemize}
\tightlist
\item
  Instead of working with \emph{functions}, work with \emph{symbols representing
  functions}.
\item
  Build your final functions and values by composing and combining these
  symbols.
\item
  At the end of it all, have a single \texttt{Apply} function interpret all of
  your symbols and produce the value you want.
\end{itemize}

In \emph{singletons} these symbols are implemented as ``dummy'' empty data
constructors, and \texttt{Apply} is a type family.

To help us understand singleton's defunctionalization system better, let's build
our own defunctionalization system from scratch.

First, a little trick to make things easier to read:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{TyFun}\NormalTok{ a b}
\KeywordTok{type}\NormalTok{ a }\FunctionTok{~>}\NormalTok{ b }\FunctionTok{=} \DataTypeTok{TyFun}\NormalTok{ a b }\OtherTok{->} \DataTypeTok{Type}

\KeywordTok{infixr} \DecValTok{0} \FunctionTok{~>}
\end{Highlighting}
\end{Shaded}

\hypertarget{our-first-symbols}{%
\subsection{Our First Symbols}\label{our-first-symbols}}

Now we can define a dummy data type like \texttt{Id}, which represents the
identity function \texttt{id}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Id}\OtherTok{ ::}\NormalTok{ a }\FunctionTok{~>}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

Don't worry too much about \texttt{TyFun}, it's all just a type-level tag that
makes it convenient to write
\texttt{Id\ ::\ a\ \textasciitilde{}\textgreater{}\ a}. The actual kind of
\texttt{Id} is \texttt{Id\ ::\ TyFun\ a\ a\ -\textgreater{}\ Type}; you can
imagine \texttt{TyFun\ a\ a} as a phantom parameter that signifies that
\texttt{Id} represents a function from \texttt{a} to \texttt{a}.

Now, \texttt{Id} is not a function\ldots{}it's a \emph{dummy type constructor}
that \emph{represents} a function \texttt{a\ -\textgreater{}\ a}. A type
constructor of kind \texttt{a\ \textasciitilde{}\textgreater{}\ a} represents a
\emph{defunctionalization symbol} -- a type constructor that represents a
function from \texttt{a} to \texttt{a}.

To interpret it, we need to write our global interpreter function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ family }\DataTypeTok{Apply}\NormalTok{ (}\OtherTok{f ::}\NormalTok{ a }\FunctionTok{~>}\NormalTok{ b) (}\OtherTok{x ::}\NormalTok{ a)}\OtherTok{ ::}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

That's the syntax for the definition of an \emph{open} type family in Haskell:
users are free to add their own instances, just like how type classes are
normally open in Haskell.

Let's tell \texttt{Apply} how to interpret \texttt{Id}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ insatnce }\DataTypeTok{Apply} \DataTypeTok{Id}\NormalTok{ x }\FunctionTok{=}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

The above is the actual function definition, like writing \texttt{id\ x\ =\ x}.
We can now \emph{call} \texttt{Id} to get an actual type in return:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ kind}\FunctionTok{!} \DataTypeTok{Apply} \DataTypeTok{Id}\NormalTok{ '}\DataTypeTok{True}
\NormalTok{'}\DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

Let's define another one! We'll implement \texttt{Not}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Not}\OtherTok{ ::} \DataTypeTok{Bool} \FunctionTok{~>} \DataTypeTok{Bool}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Apply} \DataTypeTok{Not}\NormalTok{ '}\DataTypeTok{False} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{True}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Apply} \DataTypeTok{Not}\NormalTok{ '}\DataTypeTok{True}  \FunctionTok{=}\NormalTok{ '}\DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

We can try it out:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{kind}\FunctionTok{!} \DataTypeTok{Apply} \DataTypeTok{Not}\NormalTok{ '}\DataTypeTok{True}
\NormalTok{'}\DataTypeTok{False}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{kind}\FunctionTok{!} \DataTypeTok{Apply} \DataTypeTok{Not}\NormalTok{ '}\DataTypeTok{False}
\NormalTok{'}\DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

It can be convenient to define an infix synonym for \texttt{Apply}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ f }\FunctionTok{@@}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{Apply}\NormalTok{ f a}

\KeywordTok{infixl} \DecValTok{9} \FunctionTok{@@}
\end{Highlighting}
\end{Shaded}

Then we can wrote:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{kind}\FunctionTok{!} \DataTypeTok{Not} \FunctionTok{@@}\NormalTok{ '}\DataTypeTok{False}
\NormalTok{'}\DataTypeTok{True}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{kind}\FunctionTok{!} \DataTypeTok{Id} \FunctionTok{@@}\NormalTok{ '}\DataTypeTok{True}
\NormalTok{'}\DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

Remember, \texttt{Id} and \texttt{Not} are not actual functions --- they're just
dummy data types (``defunctionalization symbols''), and we define the functions
they represent through the global \texttt{Apply} type function.

\hypertarget{a-bit-of-principle}{%
\subsection{A Bit of Principle}\label{a-bit-of-principle}}

So we've got the basics of defunctionalization --- instead of using functions
directly, use dummy symbols that encode your functions that are interpreted
using \texttt{Apply}. Let's add a bit of principle to make this all a bit more
scalable.

The singletons library adopts a few conventions for linking all of these
together. Using the \texttt{Not} function as an example, if we wanted to lift
the function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{not}\OtherTok{ ::} \DataTypeTok{Bool} \OtherTok{->} \DataTypeTok{Bool}
\NormalTok{not }\DataTypeTok{False} \FunctionTok{=} \DataTypeTok{True}
\NormalTok{not }\DataTypeTok{True}  \FunctionTok{=} \DataTypeTok{Flse}
\end{Highlighting}
\end{Shaded}

We already know about the type family and singleton function this would produce:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ family }\DataTypeTok{Not}\NormalTok{ (}\OtherTok{x ::} \DataTypeTok{Bool}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Bool} \KeywordTok{where}
    \DataTypeTok{Not}\NormalTok{ '}\DataTypeTok{False} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{True}
    \DataTypeTok{Not}\NormalTok{ '}\DataTypeTok{True}  \FunctionTok{=}\NormalTok{ '}\DataTypeTok{False}

\OtherTok{sNot ::} \DataTypeTok{Sing}\NormalTok{ x }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\DataTypeTok{Not}\NormalTok{ x)}
\NormalTok{sNot }\DataTypeTok{SFalse} \FunctionTok{=} \DataTypeTok{STrue}
\NormalTok{sNot }\DataTypeTok{STrue}  \FunctionTok{=} \DataTypeTok{SFalse}
\end{Highlighting}
\end{Shaded}

But the singletons library also produces the following \emph{defunctionalization
symbols}, according to a naming convention:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{NotSym0}\OtherTok{ ::} \DataTypeTok{Bool} \FunctionTok{~>} \DataTypeTok{Bool}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Apply} \DataTypeTok{NotSym0}\NormalTok{ x }\FunctionTok{=} \DataTypeTok{Not}\NormalTok{ x}

\CommentTok{-- also generated for consistency}
\KeywordTok{type} \DataTypeTok{NotSym1}\NormalTok{ x }\FunctionTok{=} \DataTypeTok{Not}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

\texttt{NotSym0} is the \emph{defunctionalization symbol} associated with the
\texttt{Not} type family, defined so that \texttt{NotSym0\ @@\ x\ =\ Not\ x}.
Its purpose is to allow us to \emph{pass in} \texttt{Not} as an \emph{un-applied
function}. The \texttt{Sym0} suffix is a naming convention, and the 0 stands for
``expects 0 arguments''. Similarly for \texttt{NotSym1} -- the 1 stands for
``expects 1 argument''.

Let's look at a slightly more complicated example -- a two-argument function.
Let's define the boolean ``and'':

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  and :: Bool -> (Bool -> Bool)}
\NormalTok{  and False _ = False}
\NormalTok{  and True  x = x}
\NormalTok{  ])}
\end{Highlighting}
\end{Shaded}

this will generate:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ family }\DataTypeTok{And}\NormalTok{ (}\OtherTok{x ::} \DataTypeTok{Bool}\NormalTok{) (}\OtherTok{y ::} \DataTypeTok{Bool}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Bool} \KeywordTok{where}
    \DataTypeTok{And}\NormalTok{ '}\DataTypeTok{False}\NormalTok{ x }\FunctionTok{=}\NormalTok{ '}\DataTypeTok{False}
    \DataTypeTok{And}\NormalTok{ '}\DataTypeTok{True}\NormalTok{  x }\FunctionTok{=}\NormalTok{ x}

\OtherTok{sAnd ::} \DataTypeTok{Sing}\NormalTok{ x }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ y }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\DataTypeTok{And}\NormalTok{ x y)}
\NormalTok{sAnd }\DataTypeTok{SFalse}\NormalTok{ x }\FunctionTok{=} \DataTypeTok{SFalse}
\NormalTok{sAnd }\DataTypeTok{STrue}\NormalTok{  x }\FunctionTok{=}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

And the defunctionalization symbols:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{AndSym0}\OtherTok{ ::} \DataTypeTok{Bool} \FunctionTok{~>}\NormalTok{ (}\DataTypeTok{Bool} \FunctionTok{~>} \DataTypeTok{Bool}\NormalTok{)}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Apply} \DataTypeTok{AndSym0}\NormalTok{ x }\FunctionTok{=} \DataTypeTok{AndSym1}\NormalTok{ x}

\KeywordTok{data} \DataTypeTok{AndSym1}\NormalTok{ (}\OtherTok{x ::} \DataTypeTok{Bool}\NormalTok{)}\OtherTok{ ::}\NormalTok{ (}\DataTypeTok{Bool} \FunctionTok{~>} \DataTypeTok{Bool}\NormalTok{)}
\CommentTok{-- or}
\KeywordTok{data} \DataTypeTok{AndSym1}\OtherTok{ ::} \DataTypeTok{Bool} \OtherTok{->}\NormalTok{ (}\DataTypeTok{Bool} \FunctionTok{~>} \DataTypeTok{Bool}\NormalTok{)}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Apply}\NormalTok{ (}\DataTypeTok{AndSym1}\NormalTok{ x) y }\FunctionTok{=} \DataTypeTok{And}\NormalTok{ x y}

\KeywordTok{type} \DataTypeTok{AndSym2}\NormalTok{ x y }\FunctionTok{=} \DataTypeTok{And}\NormalTok{ x y}
\end{Highlighting}
\end{Shaded}

\texttt{AndSym0} is a defunctionalization symbol representing a ``fully
unapplied'' version of \texttt{And}. \texttt{AndSym1\ x} is a
defunctionalization symbol representing a ``partially applied'' version of
\texttt{And} --- partially applied to \texttt{x} (its kind is
\texttt{AndSym1\ ::\ Bool\ -\textgreater{}\ (Bool\ \textasciitilde{}\textgreater{}\ Bool)}).

The application of \texttt{AndSym0} to \texttt{x} gives you \texttt{AndSym1\ x}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{kind}\FunctionTok{!} \DataTypeTok{AndSym0} \FunctionTok{@@}\NormalTok{ '}\DataTypeTok{False}
\DataTypeTok{AndSym1}\NormalTok{ '}\DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

Remember its kind
\texttt{AndSym0\ ::\ Bool\ \textasciitilde{}\textgreater{}\ (Bool\ \textasciitilde{}\textgreater{}\ Bool)}
(or just
\texttt{AndSym0\ ::\ Bool\ \textasciitilde{}\textgreater{}\ Bool\ \textasciitilde{}\textgreater{}\ Bool}):
it takes a \texttt{Bool}, and returns a
\texttt{Bool\ \textasciitilde{}\textgreater{}\ Bool} defunctionalization symbol.

The application of \texttt{AndSym1\ x} to \texttt{y} gives you
\texttt{And\ x\ y}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{kind}\FunctionTok{!} \DataTypeTok{AndSym1}\NormalTok{ '}\DataTypeTok{False} \FunctionTok{@@}\NormalTok{ '}\DataTypeTok{True}
\NormalTok{'}\DataTypeTok{False}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{kind}\FunctionTok{!} \DataTypeTok{AndSym1}\NormalTok{ '}\DataTypeTok{True}  \FunctionTok{@@}\NormalTok{ '}\DataTypeTok{True}
\NormalTok{'}\DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

A note to remember: \texttt{AndSym1\ \textquotesingle{}True} is the
defunctionalization symbol, and \emph{not} \texttt{AndSym1} itself.
\texttt{AndSym1} has kind
\texttt{Bool\ -\textgreater{}\ (Bool\ \textasciitilde{}\textgreater{}\ Bool)},
but \texttt{AndSym1\ \textquotesingle{}True} has kind
\texttt{Bool\ \textasciitilde{}\textgreater{}\ Bool} --- the kind of a
defunctionalization symbol.

\hypertarget{bring-me-a-higher-order}{%
\section{Bring Me a Higher Order}\label{bring-me-a-higher-order}}

Okay, so now we have these tokens that represent ``unapplied'' versions of
functions. So what?

Well, remember the problem with our implementation of \texttt{Foldr}? We
couldn't pass in a type family, since type families must be passed fully
applied. So, instead of having \texttt{Foldr} expect a type family\ldots{}we can
make it expect a \emph{defunctionalization symbol} instead! Remember,
defunctionalization symbols represent the ``unapplied'' versions of type
families, so they are exactly the tools we need!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ family }\DataTypeTok{Foldr}\NormalTok{ (}\OtherTok{f ::}\NormalTok{ j }\FunctionTok{~>}\NormalTok{ k }\FunctionTok{~>}\NormalTok{ k) (}\OtherTok{z ::}\NormalTok{ k) (}\OtherTok{xs ::}\NormalTok{ [j])}\OtherTok{ ::}\NormalTok{ k }\KeywordTok{where}
    \DataTypeTok{Foldr}\NormalTok{ f z '[]       }\FunctionTok{=}\NormalTok{ z}
    \DataTypeTok{Foldr}\NormalTok{ f z (x '}\FunctionTok{:}\NormalTok{ xs) }\FunctionTok{=}\NormalTok{ (f }\FunctionTok{@@}\NormalTok{ x) }\FunctionTok{@@} \DataTypeTok{Foldr}\NormalTok{ f z xs}
\end{Highlighting}
\end{Shaded}

The difference is that instead of taking a type family or type constructor
\texttt{f\ ::\ j\ -\textgreater{}\ k\ -\textgreater{}\ k}, we have it take the
\emph{defunctionalization symbol}
\texttt{f\ ::\ j\ \textasciitilde{}\textgreater{}\ (k\ \textasciitilde{}\textgreater{}\ k)}.

Instead of taking a type family or type constructor, we take that dummy type
constructor.

Now we just need to have our defunctionalization symbols for
\texttt{MergeStateList}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ family }\DataTypeTok{MergeState}\NormalTok{ (}\OtherTok{s ::} \DataTypeTok{DoorState}\NormalTok{) (}\OtherTok{t ::} \DataTypeTok{DoorState}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{DoorState} \KeywordTok{where}
    \DataTypeTok{MergeState}\NormalTok{ s t }\FunctionTok{=}\NormalTok{ s}

\KeywordTok{data} \DataTypeTok{MergeStateSym0}\OtherTok{ ::} \DataTypeTok{DoorState} \FunctionTok{~>} \DataTypeTok{DoorState} \FunctionTok{~>} \DataTypeTok{DoorState}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Apply} \DataTypeTok{MergeStateSym0}\NormalTok{ s }\FunctionTok{=} \DataTypeTok{MergeStateSym1}\NormalTok{ s}

\KeywordTok{data} \DataTypeTok{MergeStateSym1}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{DoorState} \FunctionTok{~>} \DataTypeTok{DoorState}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Apply}\NormalTok{ (}\DataTypeTok{MergeStateSym1}\NormalTok{ s) t }\FunctionTok{=} \DataTypeTok{MergeState}\NormalTok{ s t}

\KeywordTok{type} \DataTypeTok{MergeStateSym2}\NormalTok{ s t }\FunctionTok{=} \DataTypeTok{MergeState}\NormalTok{ s t}
\end{Highlighting}
\end{Shaded}

And now we can write \texttt{MergeStateList}!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ family }\DataTypeTok{MergeStateList}\NormalTok{ (}\OtherTok{ss ::}\NormalTok{ [}\DataTypeTok{DoorState}\NormalTok{])}\OtherTok{ ::} \DataTypeTok{DoorState} \KeywordTok{where}
    \DataTypeTok{MergeStateList}\NormalTok{ ss }\FunctionTok{=} \DataTypeTok{Foldr} \DataTypeTok{MergeStateSym0}\NormalTok{ '}\DataTypeTok{Opened}\NormalTok{ ss}
\end{Highlighting}
\end{Shaded}

This compiles!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{kind}\FunctionTok{!} \DataTypeTok{MergeStateList}\NormalTok{ '[ '}\DataTypeTok{Closed}\NormalTok{, '}\DataTypeTok{Opened}\NormalTok{, '}\DataTypeTok{Locked}\NormalTok{ ]}
\NormalTok{'}\DataTypeTok{Closed}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{kind}\FunctionTok{!} \DataTypeTok{MergeStateList}\NormalTok{ '[ '}\DataTypeTok{Closed}\NormalTok{, '}\DataTypeTok{Opened}\NormalTok{ ]}
\NormalTok{'}\DataTypeTok{Closed}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{collapseHallway ::} \DataTypeTok{Hallway}\NormalTok{ ss }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ (}\DataTypeTok{MergeStateList}\NormalTok{ ss)}
\NormalTok{collapseHallway }\DataTypeTok{HEnd}       \FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \StringTok{"End of Hallway"}
\NormalTok{collapseHallway (d }\FunctionTok{:<#}\NormalTok{ ds) }\FunctionTok{=}\NormalTok{ d }\OtherTok{`mergeDoor`}\NormalTok{ collapseHallway ds}
\end{Highlighting}
\end{Shaded}

\hypertarget{singletons-to-the-rescue}{%
\subsection{Singletons to the Rescue}\label{singletons-to-the-rescue}}

Admittedly this is all a huge mess of boilerplate. The code we had to write more
than tripled, and we also have an unsightly number of defunctionalization
symbols and \texttt{Apply} instance boilerplate for every function.

Luckily, the \emph{singletons} library is here to help. You can just write:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  data DoorState = Opened | Closed | Locked}
\NormalTok{    deriving (Show, Eq, Ord)}

\NormalTok{  mergeState :: DoorState -> DoorState -> DoorState}
\NormalTok{  mergeState = max}

\NormalTok{  foldr :: (a -> b -> b) -> b -> [a] -> b}
\NormalTok{  foldr _ z []     = z}
\NormalTok{  foldr f z (x:xs) = f x (foldr f z xs)}

\NormalTok{  mergeStateList :: [DoorState] -> DoorState}
\NormalTok{  mergeStateList = foldr mergeState Opened}
\NormalTok{  |])}
\end{Highlighting}
\end{Shaded}

And all of these defunctionalization symbols are generated for you;
\emph{singletons} is also able to recognize that \texttt{foldr} is a
higher-order function and translate its lifted version to take a
defunctionalization symbol
\texttt{a\ \textasciitilde{}\textgreater{}\ b\ \textasciitilde{}\textgreater{}\ b}.

It's okay to stay ``in the world of singletons'' for the most part, and let
singletons handle the composition of functions for you. However, it's still
important to know what the \emph{singletons} library generates, because
sometimes it's still useful to manually create defunctionalization symbols and
work with them.

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
