<!DOCTYPE HTML>
<html><head><title>Introducing the backprop library · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="backprop: hackage / github I’m excited to announce the first official release of the backprop library (currently at version 0.1.3.0 on hackage)! backprop is a library that allows you write functions on your heterogeneous values like you would normally and takes them and (with reverse-mode automatic differentiation) automatically generate functions computing their gradients. backprop differs from the related ad by working with functions using and transforming different types, instead of only one monomorphic scalar type. This has been something I’ve been working on for a while (trying to find a good API for heterogeneous automatic differentiation), and I’m happy to finally find something that I feel good about, with the help of a lens-based API. As a quick demonstration, this post will walk through the creation of a simple neural network implementation (inspired by the Tensorflow Tutorial for beginners) to learn handwritten digit recognition for the MNIST data set. To help tell the story, we’re going to be implementing it “normally”, using the hmatrix library API, and then re-write the same thing using backprop and hmatrix-backprop (a drop-in replacement for hmatrix)."><meta property="og:type" content="article"><meta property="og:title" content="Introducing the backprop library"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introducing-the-backprop-library.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introducing-the-backprop-library.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Introducing the backprop library</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2018-02-12T10:27:44Z" pubdate="" class="pubdate">Monday February 12, 2018</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/backprop-intro.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introducing-the-backprop-library.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introducing-the-backprop-library.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p><strong>backprop</strong>: <a href="http://hackage.haskell.org/package/backprop">hackage</a> / <a href="https://github.com/mstksg/backprop">github</a></p>
<p>I’m excited to announce the first official release of the <em><a href="http://hackage.haskell.org/package/backprop">backprop</a></em> library (currently at version 0.1.3.0 on hackage)! <em>backprop</em> is a library that allows you write functions on your heterogeneous values like you would normally and takes them and (with reverse-mode automatic differentiation) automatically generate functions computing their gradients. <em>backprop</em> differs from the related <em><a href="http://hackage.haskell.org/package/ad">ad</a></em> by working with functions using and transforming different types, instead of only one monomorphic scalar type.</p>
<p>This has been something I’ve been working on for a while (trying to find a good API for <em>heterogeneous</em> automatic differentiation), and I’m happy to finally find something that I feel good about, with the help of a <em><a href="http://hackage.haskell.org/package/lens">lens</a></em>-based API.</p>
<p>As a quick demonstration, this post will walk through the creation of a simple neural network implementation (inspired by the <a href="https://www.tensorflow.org/versions/r1.2/get_started/mnist/beginners">Tensorflow Tutorial</a> for beginners) to learn handwritten digit recognition for the MNIST data set. To help tell the story, we’re going to be implementing it “normally”, using the <em><a href="http://hackage.haskell.org/package/hmatrix">hmatrix</a></em> library API, and then re-write the same thing using <em><a href="http://hackage.haskell.org/package/backprop">backprop</a></em> and <em><a href="http://hackage.haskell.org/package/hmatrix-backprop">hmatrix-backprop</a></em> (a drop-in replacement for <em>hmatrix</em>).</p>
<h2 id="the-basics">The Basics</h2>
<p>For this network, we’re not going to be doing anything super fancy. Our “neural network” will just be simple series of matrix multiplications, vector additions, and activation functions. We’re going to make a neural network with a single hidden layer using normal Haskell data types, parameterized by two weight matrices and two bias vectors.</p>
<p>The purpose of the MNIST challenge is to take a vector of pixel data (28x28, so 784 elements total) and classify it as one of ten digits (0 through 9). To do this, we’re going to be building and training a model that takes in a 784-vector of pixel data and produces a 10-item <a href="https://en.wikipedia.org/wiki/One-hot">one-hot</a> vector of categorical predictions (which is supposed to be 0 everywhere, except for 1 in the category we predict the input picture to be in).</p>
<h3 id="types">Types</h3>
<p>For our types, our imports are pretty simple:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-normal.hs#L10-L11</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span>           <span class="dt">Control.Lens</span> <span class="kw">hiding</span>          ((&lt;.&gt;))</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span>           <span class="dt">Numeric.LinearAlgebra.Static</span></a></code></pre></div>
<p>Our <code>Net</code> type will just be a simple collection of all of the matrices and vectors we want to optimize:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-normal.hs#L18-L24</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">data</span> <span class="dt">Net</span> <span class="ot">=</span> <span class="dt">N</span> {<span class="ot"> _weights1 ::</span> <span class="dt">L</span> <span class="dv">250</span> <span class="dv">784</span></a>
<a class="sourceLine" id="cb2-4" title="4">             ,<span class="ot"> _bias1    ::</span> <span class="dt">R</span> <span class="dv">250</span></a>
<a class="sourceLine" id="cb2-5" title="5">             ,<span class="ot"> _weights2 ::</span> <span class="dt">L</span> <span class="dv">10</span> <span class="dv">250</span></a>
<a class="sourceLine" id="cb2-6" title="6">             ,<span class="ot"> _bias2    ::</span> <span class="dt">R</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb2-7" title="7">             }</a>
<a class="sourceLine" id="cb2-8" title="8">  <span class="kw">deriving</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb2-9" title="9">makeLenses &#39;<span class="dt">&#39;Net</span></a></code></pre></div>
<p>We’re using the matrix types from <a href="https://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Static.html"><code>Numeric.LinearAlgebra.Static</code></a>. An <code>L 250 784</code> is a <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?250%20%5Ctimes%20784" alt="250 \times 784" title="250 \times 784" /> matrix – or, as we are using it, a linear transformation <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5E%7B784%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D%5E%7B250%7D" alt="\mathbb{R}^{784} \rightarrow \mathbb{R}^{250}" title="\mathbb{R}^{784} \rightarrow \mathbb{R}^{250}" />. An <code>R 250</code> is a 250-vector, etc.</p>
<p>Via the <em>lens</em> library, four lenses are generated:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">weights1 ::</span> <span class="dt">Lens&#39;</span> <span class="dt">Net</span> (<span class="dt">L</span> <span class="dv">250</span> <span class="dv">784</span>)</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">bias1    ::</span> <span class="dt">Lens&#39;</span> <span class="dt">Net</span> (<span class="dt">R</span> <span class="dv">250</span>)</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">weights2 ::</span> <span class="dt">Lens&#39;</span> <span class="dt">Net</span> (<span class="dt">L</span> <span class="dv">10</span>  <span class="dv">250</span>)</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">bias2    ::</span> <span class="dt">Lens&#39;</span> <span class="dt">Net</span> (<span class="dt">R</span> <span class="dv">10</span>)</a></code></pre></div>
<p>These lenses give us ways to access components of our data type:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">myNet             ::</span> <span class="dt">Net</span></a>
<a class="sourceLine" id="cb4-2" title="2">myNet <span class="op">^.</span><span class="ot"> weights1 ::</span> <span class="dt">L</span> <span class="dv">250</span> <span class="dv">784</span>  <span class="co">-- access the weights1 field in myNet</span></a>
<a class="sourceLine" id="cb4-3" title="3">myNet <span class="op">^.</span><span class="ot"> bias2    ::</span> <span class="dt">R</span>  <span class="dv">10</span>      <span class="co">-- access the bias2 field in myNet</span></a></code></pre></div>
<p>I’m also going to define <code>Num</code> and <code>Fractional</code> instances for our network, which makes it really easy to write code to “update” our network (we can just add and scale our networks with each other). To do this, I’m going to be using <em><a href="http://hackage.haskell.org/package/one-liner-instances">one-liner-instances</a></em> to make a <code>Num</code> instance automatically using GHC Generics:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-normal.hs#L61-L73</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Net</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" title="4">    (<span class="op">+</span>)         <span class="ot">=</span> gPlus</a>
<a class="sourceLine" id="cb5-5" title="5">    (<span class="op">-</span>)         <span class="ot">=</span> gMinus</a>
<a class="sourceLine" id="cb5-6" title="6">    (<span class="op">*</span>)         <span class="ot">=</span> gTimes</a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="fu">negate</span>      <span class="ot">=</span> gNegate</a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="fu">abs</span>         <span class="ot">=</span> gAbs</a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="fu">signum</span>      <span class="ot">=</span> gSignum</a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="fu">fromInteger</span> <span class="ot">=</span> gFromInteger</a>
<a class="sourceLine" id="cb5-11" title="11"></a>
<a class="sourceLine" id="cb5-12" title="12"><span class="kw">instance</span> <span class="dt">Fractional</span> <span class="dt">Net</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-13" title="13">    (<span class="op">/</span>)          <span class="ot">=</span> gDivide</a>
<a class="sourceLine" id="cb5-14" title="14">    <span class="fu">recip</span>        <span class="ot">=</span> gRecip</a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="fu">fromRational</span> <span class="ot">=</span> gFromRational</a></code></pre></div>
<h2 id="without-backprop">Without Backprop</h2>
<h3 id="running">Running</h3>
<p>First, let’s look at the picture if we just try to compute the error function for our network directly.</p>
<p>Running our network is pretty textbook:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-normal.hs#L42-L49</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3">runNet</a>
<a class="sourceLine" id="cb6-4" title="4"><span class="ot">    ::</span> <span class="dt">Net</span></a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">R</span> <span class="dv">784</span></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">R</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb6-7" title="7">runNet n x <span class="ot">=</span> z</a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" title="9">    y <span class="ot">=</span> logistic <span class="op">$</span> (n <span class="op">^.</span> weights1) <span class="op">#&gt;</span> x <span class="op">+</span> (n <span class="op">^.</span> bias1)</a>
<a class="sourceLine" id="cb6-10" title="10">    z <span class="ot">=</span> softMax  <span class="op">$</span> (n <span class="op">^.</span> weights2) <span class="op">#&gt;</span> y <span class="op">+</span> (n <span class="op">^.</span> bias2)</a></code></pre></div>
<p><code>runNet</code> takes a network and produces the <code>R 784 -&gt; R 10</code> function it encodes.</p>
<p><code>#&gt; :: L m n -&gt; R n -&gt; R m</code> is the matrix-vector multiplication operator from <em>hmatrix</em> (its <a href="https://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Static.html">static</a> module); we can also just use <code>+</code> (from <code>Num</code>) to add vectors together.</p>
<p>We use the <a href="https://en.wikipedia.org/wiki/Logistic_function">logistic function</a> as our internal activation function and <a href="https://en.wikipedia.org/wiki/Softmax_function">softmax</a> to normalize our outputs:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-normal.hs#L26-L34</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ot">logistic ::</span> <span class="dt">Floating</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb7-4" title="4">logistic x <span class="ot">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> <span class="fu">exp</span> (<span class="op">-</span>x))</a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">softMax</a>
<a class="sourceLine" id="cb7-7" title="7"><span class="ot">    ::</span> <span class="dt">R</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="ot">-&gt;</span> <span class="dt">R</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb7-9" title="9">softMax x <span class="ot">=</span> expx <span class="op">/</span> konst (norm_1 expx)</a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-11" title="11">    expx <span class="ot">=</span> <span class="fu">exp</span> x</a></code></pre></div>
<p>We can define the logistic function using only <code>Num</code> operations, which operate component-wise for <em>hmatrix</em> types. <code>softMax</code> requires us to <code>norm_1</code> (to get the absolute sum of all items in a vector) from <em>hmatrix</em>, and also <code>konst</code> (to generate a vector of a single item repeated). Still, though, pretty much a straightforward implementation of the mathematical definitions.</p>
<h3 id="error-function">Error Function</h3>
<p>This neural network now makes predictions. However, in order to <em>train</em> a network, we actually need a scalar <em>error function</em> that we want to minimize. This is a function on the network that, given an input and its expected output, computes how “bad” the currently network is. It computes the error between the output of the network and the expected output, as a single number.</p>
<p>To do this, we will be using the <a href="https://en.wikipedia.org/wiki/Cross_entropy">cross entropy</a> between the target output and the network output. This is a standard error function for classification problems; smaller cross-entropies indicate “better” predictions.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-normal.hs#L36-L56</span></a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3">crossEntropy</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="ot">    ::</span> <span class="dt">R</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">R</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb8-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb8-7" title="7">crossEntropy targ res <span class="ot">=</span> <span class="op">-</span>(<span class="fu">log</span> res <span class="op">&lt;.&gt;</span> targ)</a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9">netErr</a>
<a class="sourceLine" id="cb8-10" title="10"><span class="ot">    ::</span> <span class="dt">R</span> <span class="dv">784</span></a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="ot">-&gt;</span> <span class="dt">R</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb8-12" title="12">    <span class="ot">-&gt;</span> <span class="dt">Net</span></a>
<a class="sourceLine" id="cb8-13" title="13">    <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb8-14" title="14">netErr x targ n <span class="ot">=</span> crossEntropy targ (runNet n x)</a></code></pre></div>
<p>Computing the cross entropy involves using <code>&lt;.&gt;</code> (the dot product) from <em>hmatrix</em>, but other than that we can just use <code>log</code> (from <code>Floating</code>) and negation (from <code>Num</code>).</p>
<h3 id="training">Training</h3>
<p>At this point, we are supposed to find a way to compute the <em>gradient</em> of our error function. It’s a function that computes the <em>direction of greatest change</em> of all of the components in our network, with respect to our error function.</p>
<p>The gradient will take our <code>Net -&gt; Double</code> error function and, given a current network, and produce a “gradient” <code>Net</code> whose components contain the derivative of each component with respect to the error. It tells us how to “nudge” each component to increase the error function. <em>Training</em> a neural network involves moving in the opposite direction of the gradient, which causes the error to go <em>down</em>.</p>
<p>However, given <code>netErr</code>’s definition, it is not obvious how to compute our gradient function. Doing so involves some careful multi-variable vector calculus and linear algebra based on our knowledge of the operations we used. For simple situations we often do it by hand, but for more complicated situations, this becomes impractical. That’s where <em>automatic differentiation</em> comes into play.</p>
<p>We’ve gone as far as we can go now, so let’s drop into the world of <em>backprop</em> and see what it can offer us!</p>
<h2 id="with-backprop">With Backprop</h2>
<p>Let’s see what happens if we compute our error function using <em>backprop</em>, instead!</p>
<p>We’ll switch out our imports very slightly:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-backprop.hs#L14-L16</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">import</span>           <span class="dt">Control.Lens</span> <span class="kw">hiding</span>                   ((&lt;.&gt;))</a>
<a class="sourceLine" id="cb9-4" title="4"><span class="kw">import</span>           <span class="dt">Numeric.Backprop</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">import</span>           <span class="dt">Numeric.LinearAlgebra.Static.Backprop</span></a></code></pre></div>
<p>First, we add <code>Numeric.Backprop</code>, the module where the magic happens.</p>
<p>Second, we switch from <code>Numeric.LinearAlgebra.Static</code> to <a href="https://hackage.haskell.org/package/hmatrix-backprop/docs/Numeric-LinearAlgebra-Static-Backprop.html"><code>Numeric.LinearAlgebra.Static.Backprop</code></a> (from <em><a href="http://hackage.haskell.org/package/hmatrix-backprop">hmatrix-backprop</a></em>), which exports the exact same<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> API as <code>Numeric.LinearAlgebra.Static</code>, except with numeric operations that are “lifted” to work with <em>backprop</em>. It’s meant to act as a drop-in replacement, and, because of this, most of our actual code will be more or less identical.</p>
<h3 id="running-1">Running</h3>
<p>Writing functions that can be used with <em>backprop</em> involves tweaking the types slightly – instead of working directly with values of type <code>a</code>, we work with <code>BVar</code>s (backpropagatable variables) <em>containing</em> <code>a</code>s: a <code>BVar s a</code>.</p>
<p>For example, let’s look a version <code>softMax</code> that works with <em>backprop</em>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-backprop.hs#L56-L62</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3">softMax</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="ot">    ::</span> <span class="dt">Reifies</span> s <span class="dt">W</span></a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="ot">=&gt;</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb10-7" title="7">softMax x <span class="ot">=</span> expx <span class="op">/</span> konst (norm_1V expx)</a>
<a class="sourceLine" id="cb10-8" title="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-9" title="9">    expx <span class="ot">=</span> <span class="fu">exp</span> x</a></code></pre></div>
<p>Instead of <code>R 10 -&gt; R 10</code>, its type signature is now <code>BVar s (R 10) -&gt; BVar s (R 10)</code>. Instead of working directly with <code>R 10</code>s (10-vectors), we work with <code>BVar s (R 10)</code>s (<code>BVar</code>s containing 10-vectors).</p>
<p><code>Numeric.LinearAlgebra.Static.Backprop</code> re-exports <code>konst</code> and <code>norm_1</code> (as <code>norm_1V</code> — <code>norm_1</code> for vectors only) lifted to work with <code>BVar</code>s:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="co">-- normal</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">konst   ::</span>        <span class="dt">Double</span> <span class="ot">-&gt;</span>         <span class="dt">R</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="co">-- backprop</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="ot">konst   ::</span> <span class="dt">BVar</span> s <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb11-5" title="5"></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="co">-- normal</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="ot">norm_1  ::</span>         <span class="dt">R</span> <span class="dv">10</span>  <span class="ot">-&gt;</span>        <span class="dt">Double</span></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="co">-- backprop</span></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="ot">norm_1V ::</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">10</span>) <span class="ot">-&gt;</span> <span class="dt">BVar</span> s <span class="dt">Double</span></a></code></pre></div>
<p><code>BVar</code>s also have <code>Num</code>, <code>Fractional</code>, and <code>Floating</code> instances, so <code>exp</code> and <code>/</code> already work out-of-the-box.</p>
<p>With only a minimal and mechanical change in our code, <code>softMax</code> is now automatically differentiable!</p>
<p>One neat trick — because of <code>BVar</code>’s numeric instances, we can actually re-use our original implementation of <code>logistic</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-backprop.hs#L53-L54</span></a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="ot">logistic ::</span> <span class="dt">Floating</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb12-4" title="4">logistic x <span class="ot">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> <span class="fu">exp</span> (<span class="op">-</span>x))</a></code></pre></div>
<p>To <em>run</em> our network, things look pretty similar:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-backprop.hs#L71-L79</span></a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3">runNet</a>
<a class="sourceLine" id="cb13-4" title="4"><span class="ot">    ::</span> <span class="dt">Reifies</span> s <span class="dt">W</span></a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="ot">=&gt;</span> <span class="dt">BVar</span> s <span class="dt">Net</span></a>
<a class="sourceLine" id="cb13-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">784</span>)</a>
<a class="sourceLine" id="cb13-7" title="7">    <span class="ot">-&gt;</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb13-8" title="8">runNet n x <span class="ot">=</span> z</a>
<a class="sourceLine" id="cb13-9" title="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-10" title="10">    y <span class="ot">=</span> logistic <span class="op">$</span> (n <span class="op">^^.</span> weights1) <span class="op">#&gt;</span> x <span class="op">+</span> (n <span class="op">^^.</span> bias1)</a>
<a class="sourceLine" id="cb13-11" title="11">    z <span class="ot">=</span> softMax  <span class="op">$</span> (n <span class="op">^^.</span> weights2) <span class="op">#&gt;</span> y <span class="op">+</span> (n <span class="op">^^.</span> bias2)</a></code></pre></div>
<p>Again, pretty much the same, except with the lifted type signature. One notable difference, however, is how we <em>access</em> the weights and biases. Instead of using <code>^.</code> for lens access, we can use <code>^^.</code>, for lens access into a <code>BVar</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">myNetVar                ::</span> <span class="dt">BVar</span> s <span class="dt">Net</span>          <span class="co">-- a Net inside a BVar</span></a>
<a class="sourceLine" id="cb14-2" title="2">myNetVar <span class="op">^^.</span><span class="ot"> weights1   ::</span> <span class="dt">BVar</span> s (<span class="dt">L</span> <span class="dv">250</span> <span class="dv">784</span>)  <span class="co">-- access the weights1 field in myNetVar</span></a>
<a class="sourceLine" id="cb14-3" title="3">myNetVar <span class="op">^^.</span><span class="ot"> bias2      ::</span> <span class="dt">BVar</span> s (<span class="dt">R</span>  <span class="dv">10</span>    )  <span class="co">-- access the bias2 field in myNetVar</span></a></code></pre></div>
<p>Some insight may be gleamed from a comparison of their type signatures:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">(^.)  ::</span>        a <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> a b <span class="ot">-&gt;</span>        b</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="ot">(^^.) ::</span> <span class="dt">BVar</span> s a <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> a b <span class="ot">-&gt;</span> <span class="dt">BVar</span> s b</a></code></pre></div>
<p><code>^.</code> is access to a value using a lens, and <code>^^.</code> is access to a value inside a <code>BVar</code> using a lens.</p>
<p>Using lenses like this gives us essentially frictionless usage of <code>BVar</code>s, allowing us to access items inside data types in a natural way. We can also <em>set</em> items using <code>.~~</code> (to parallel <code>.~</code>), access constructors in sum types using <code>^^?</code> (which can be used to implement pattern matching) and get matches for <em>multiple</em> targets using <code>^^..</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">(^..)  ::</span>        a <span class="ot">-&gt;</span> <span class="dt">Traversal&#39;</span> a b <span class="ot">-&gt;</span> [       b]</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="ot">(^^..) ::</span> <span class="dt">BVar</span> s a <span class="ot">-&gt;</span> <span class="dt">Traversal&#39;</span> a b <span class="ot">-&gt;</span> [<span class="dt">BVar</span> s b]</a></code></pre></div>
<p>Because of these, our translation from our normal <code>runNet</code> to our <em>backprop</em> <code>runNet</code> is more or less completely mechanical.</p>
<h3 id="error-function-1">Error Function</h3>
<p>At this point, the implementation of our updated error function should not be too surprising:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-backprop.hs#L64-L87</span></a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3">crossEntropy</a>
<a class="sourceLine" id="cb17-4" title="4"><span class="ot">    ::</span> <span class="dt">Reifies</span> s <span class="dt">W</span></a>
<a class="sourceLine" id="cb17-5" title="5">    <span class="ot">=&gt;</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb17-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb17-7" title="7">    <span class="ot">-&gt;</span> <span class="dt">BVar</span> s <span class="dt">Double</span></a>
<a class="sourceLine" id="cb17-8" title="8">crossEntropy targ res <span class="ot">=</span> <span class="op">-</span>(<span class="fu">log</span> res <span class="op">&lt;.&gt;</span> targ)</a>
<a class="sourceLine" id="cb17-9" title="9"></a>
<a class="sourceLine" id="cb17-10" title="10">netErr</a>
<a class="sourceLine" id="cb17-11" title="11"><span class="ot">    ::</span> <span class="dt">Reifies</span> s <span class="dt">W</span></a>
<a class="sourceLine" id="cb17-12" title="12">    <span class="ot">=&gt;</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">784</span>)</a>
<a class="sourceLine" id="cb17-13" title="13">    <span class="ot">-&gt;</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb17-14" title="14">    <span class="ot">-&gt;</span> <span class="dt">BVar</span> s <span class="dt">Net</span></a>
<a class="sourceLine" id="cb17-15" title="15">    <span class="ot">-&gt;</span> <span class="dt">BVar</span> s <span class="dt">Double</span></a>
<a class="sourceLine" id="cb17-16" title="16">netErr x targ n <span class="ot">=</span> crossEntropy targ (runNet n x)</a></code></pre></div>
<p>Both of these implementations are are 100% lexicographically identical to our original ones – the only difference is that <code>&lt;.&gt;</code> comes from <code>Numeric.LinearAlgebra.Static.Backprop</code>. Other than that, we can simply re-use <code>log</code> and negation.</p>
<h3 id="training-1">Training</h3>
<p>Time to gradient descend!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-backprop.hs#L89-L93</span></a>
<a class="sourceLine" id="cb18-2" title="2"></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="ot">stepNet ::</span> <span class="dt">R</span> <span class="dv">784</span> <span class="ot">-&gt;</span> <span class="dt">R</span> <span class="dv">10</span> <span class="ot">-&gt;</span> <span class="dt">Net</span> <span class="ot">-&gt;</span> <span class="dt">Net</span></a>
<a class="sourceLine" id="cb18-4" title="4">stepNet x targ net0 <span class="ot">=</span> net0 <span class="op">-</span> <span class="fl">0.02</span> <span class="op">*</span> gr</a>
<a class="sourceLine" id="cb18-5" title="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-6" title="6"><span class="ot">    gr ::</span> <span class="dt">Net</span></a>
<a class="sourceLine" id="cb18-7" title="7">    gr <span class="ot">=</span> gradBP (netErr (constVar x) (constVar targ)) net0</a></code></pre></div>
<p>And…that’s it!</p>
<p>To break this down:</p>
<ol type="1">
<li><p>To train our network, we move in the opposite direction of our gradient. That means <code>net0 - 0.02 * gr</code> – we subtract the gradient (scaled by 0.02, a learning rate, to ensure we don’t overshoot our goal) from our network.</p>
<p>Recall that we implemented scaling and subtraction of <code>Net</code>s when we wrote its <code>Num</code> and <code>Fractional</code> instances earlier.</p></li>
<li><p>To compute our gradient, we use <code>gradBP</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="ot">gradBP ::</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Reifies</span> s <span class="dt">W</span> <span class="ot">=&gt;</span> <span class="dt">BVar</span> s a <span class="ot">-&gt;</span> <span class="dt">BVar</span> s b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>If we ignore the RankN type/<code>Reifies</code> syntax noise, this can be read as:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="ot">gradBP ::</span> (<span class="dt">BVar</span> s a <span class="ot">-&gt;</span> <span class="dt">BVar</span> s b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>Which says “give a function from a <code>BVar</code> of <code>a</code> to a <code>BVar</code> of <code>b</code>, get the gradient function, from <code>a</code> to its gradient”</p>
<p>This can be contrasted with <code>evalBP</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">evalBP ::</span> (<span class="dt">BVar</span> s a <span class="ot">-&gt;</span> <span class="dt">BVar</span> s b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>Which “runs” the actual <code>a -&gt; b</code> function that the <code>BVar s a -&gt; BVar s b</code> encodes.</p></li>
<li><p>We want to use <code>gradBP</code> with our <code>Net -&gt; Double</code> error function (or, more accurately, our <code>BVar s Net -&gt; BVar s Double</code> function). That’s exactly what <code>netErr</code> gives us.</p>
<p>We use <code>constVar</code> to lift <code>x</code> and <code>targ</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="ot">constVar ::</span> a <span class="ot">-&gt;</span> <span class="dt">BVar</span> s a</a></code></pre></div>
<p><code>constVar</code> simply lifts a value into a <code>BVar</code>, knowing that we don’t care about its gradient.</p>
<p>This means that we have:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1">netErr (constVar x) (constVar targ)<span class="ot"> ::</span> <span class="dt">BVar</span> s <span class="dt">Net</span> <span class="ot">-&gt;</span> <span class="dt">BVar</span> s <span class="dt">Double</span></a></code></pre></div>
<p>We can pass this function to <code>gradBP</code> to get the gradient of the network <code>Net</code> with respect to the <code>Double</code> error.</p></li>
</ol>
<p>That’s really the entire gradient computation and descent code!</p>
<p>Kind of anti-climactic, isn’t it?</p>
<h2 id="taking-it-for-a-spin">Taking it for a spin</h2>
<p>In the <a href="https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-backprop.hs">source code</a> I’ve included some basic code for loading the mnist data set and training the network, with some basic evaluations.</p>
<p>If you download it <a href="https://github.com/mstksg/inCode/tree/master/code-samples/backprop/intro-backprop.hs">here</a>, you can compile it using a stack’s self-compiling script feature (if <em><a href="https://docs.haskellstack.org/en/stable/README/">stack</a></em> is installed on your computer):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb24-1" title="1">$ <span class="ex">./intro-backprop.hs</span>    <span class="co"># compiles itself, managing dependencies automatically</span></a></code></pre></div>
<p>The above command will cause the program to compile itself, installing the necessary GHC (if needed) and also the automatically download the dependencies from hackage. <em>backprop</em> manages the automatic differentiation, and <em>stack</em> manages the automatic dependency management :)</p>
<p>If you are following along at home, you can download the <a href="http://yann.lecun.com/exdb/mnist/">mnist data set files</a> and uncompress them into a folder, and run it all with:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb25-1" title="1">$ <span class="ex">./intro-backprop</span> PATH_TO_DATA</a>
<a class="sourceLine" id="cb25-2" title="2"><span class="ex">Loaded</span> data.</a>
<a class="sourceLine" id="cb25-3" title="3">[<span class="ex">Epoch</span> 1]</a>
<a class="sourceLine" id="cb25-4" title="4"><span class="kw">(</span><span class="ex">Batch</span> 1<span class="kw">)</span></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="ex">Trained</span> on 5000 points.</a>
<a class="sourceLine" id="cb25-6" title="6"><span class="ex">Training</span> error:   13.26%</a>
<a class="sourceLine" id="cb25-7" title="7"><span class="ex">Validation</span> error: 13.44%</a>
<a class="sourceLine" id="cb25-8" title="8"><span class="kw">(</span><span class="ex">Batch</span> 2<span class="kw">)</span></a>
<a class="sourceLine" id="cb25-9" title="9"><span class="ex">Trained</span> on 5000 points.</a>
<a class="sourceLine" id="cb25-10" title="10"><span class="ex">Training</span> error:   9.74%</a>
<a class="sourceLine" id="cb25-11" title="11"><span class="ex">Validation</span> error: 11.08%</a>
<a class="sourceLine" id="cb25-12" title="12"><span class="kw">(</span><span class="ex">Batch</span> 3<span class="kw">)</span></a>
<a class="sourceLine" id="cb25-13" title="13"><span class="ex">Trained</span> on 5000 points.</a>
<a class="sourceLine" id="cb25-14" title="14"><span class="ex">Training</span> error:   6.84%</a>
<a class="sourceLine" id="cb25-15" title="15"><span class="ex">Validation</span> error: 8.71%</a>
<a class="sourceLine" id="cb25-16" title="16"><span class="kw">(</span><span class="ex">Batch</span> 4<span class="kw">)</span></a>
<a class="sourceLine" id="cb25-17" title="17"><span class="ex">Trained</span> on 5000 points.</a>
<a class="sourceLine" id="cb25-18" title="18"><span class="ex">Training</span> error:   6.84%</a>
<a class="sourceLine" id="cb25-19" title="19"><span class="ex">Validation</span> error: 8.53%</a>
<a class="sourceLine" id="cb25-20" title="20"><span class="kw">(</span><span class="ex">Batch</span> 5<span class="kw">)</span></a>
<a class="sourceLine" id="cb25-21" title="21"><span class="ex">Trained</span> on 5000 points.</a>
<a class="sourceLine" id="cb25-22" title="22"><span class="ex">Training</span> error:   5.80%</a>
<a class="sourceLine" id="cb25-23" title="23"><span class="ex">Validation</span> error: 7.55%</a>
<a class="sourceLine" id="cb25-24" title="24"><span class="kw">(</span><span class="ex">Batch</span> 6<span class="kw">)</span></a>
<a class="sourceLine" id="cb25-25" title="25"><span class="ex">Trained</span> on 5000 points.</a>
<a class="sourceLine" id="cb25-26" title="26"><span class="ex">Training</span> error:   5.20%</a>
<a class="sourceLine" id="cb25-27" title="27"><span class="ex">Validation</span> error: 6.77%</a>
<a class="sourceLine" id="cb25-28" title="28"><span class="kw">(</span><span class="ex">Batch</span> 7<span class="kw">)</span></a>
<a class="sourceLine" id="cb25-29" title="29"><span class="ex">Trained</span> on 5000 points.</a>
<a class="sourceLine" id="cb25-30" title="30"><span class="ex">Training</span> error:   4.44%</a>
<a class="sourceLine" id="cb25-31" title="31"><span class="ex">Validation</span> error: 5.85%</a></code></pre></div>
<p>After about 35000 training points, we get down to 94% accuracy on our test set. Neat!</p>
<h2 id="a-more-nuanced-look">A More Nuanced Look</h2>
<p>That’s the high level overview – now let’s look a bit at the details that might be helpful before you go strike it out on your own.</p>
<p>The main API revolves around writing a <code>BVar s a -&gt; BVar s b</code> function (representing an <code>a -&gt; b</code> one), and then using one of the three runners:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="co">-- Return the result and gradient</span></a>
<a class="sourceLine" id="cb26-2" title="2"><span class="ot">backprop ::</span> (<span class="dt">Num</span> a, <span class="dt">Num</span> b)</a>
<a class="sourceLine" id="cb26-3" title="3">         <span class="ot">=&gt;</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Reifies</span> s <span class="dt">W</span> <span class="ot">=&gt;</span> <span class="dt">BVar</span> s a <span class="ot">-&gt;</span> <span class="dt">BVar</span> s b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, b)</a>
<a class="sourceLine" id="cb26-4" title="4"></a>
<a class="sourceLine" id="cb26-5" title="5"><span class="co">-- Return the result</span></a>
<a class="sourceLine" id="cb26-6" title="6"><span class="ot">evalBP   ::</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Reifies</span> s <span class="dt">W</span> <span class="ot">=&gt;</span> <span class="dt">BVar</span> s a <span class="ot">-&gt;</span> <span class="dt">BVar</span> s b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb26-7" title="7"></a>
<a class="sourceLine" id="cb26-8" title="8"><span class="co">-- Return the gradient</span></a>
<a class="sourceLine" id="cb26-9" title="9"><span class="ot">gradBP   ::</span> (<span class="dt">Num</span> a, <span class="dt">Num</span> b)</a>
<a class="sourceLine" id="cb26-10" title="10">         <span class="ot">=&gt;</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Reifies</span> s <span class="dt">W</span> <span class="ot">=&gt;</span> <span class="dt">BVar</span> s a <span class="ot">-&gt;</span> <span class="dt">BVar</span> s b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p><code>evalBP</code> comes with virtually zero performance overhead (about 4%) over writing your functions directly, so there’s pretty much no harm in writing your entire application or library in <code>BVar</code>-based code.</p>
<p><code>gradBP</code>, however, carries measurable performance overhead over writing your gradient code “manually”, but this heavily depends on exactly how complex the code you are backpropagating is. The overhead comes from two potential sources: the building of the function call graph, and also potentially from the mechanical automatic differentiation process generating different operations than what you might write by hand. See the <a href="https://github.com/mstksg/backprop#readme">README</a> for a deeper analysis.</p>
<p>You might have also noticed the RankN type signature (the <code>forall s. ...</code>) that I glossed over earlier. This is here because <em>backprop</em> uses the RankN type trick (from <code>Control.Monad.ST</code> and the <em><a href="http://hackage.haskell.org/package/ad">ad</a></em> library) for two purposes:</p>
<ol type="1">
<li>The prevent leakage of variables from the function. You can’t use <code>evalBP</code> to get a <code>BVar</code> out in the end, just like you can’t use <code>runST</code> to get an <code>STRef</code> out in the end. The type system prevents these variables from leaking out of the backprop/ST world.</li>
<li>The <code>Reifies s W</code> constraint allows <em>backprop</em> to build a <a href="https://dl.acm.org/citation.cfm?doid=355586.364791">Wengert Tape</a> of your computation, which it uses internally to perform the reverse-mode automatic differentiation (The <code>W</code> stands for Wengert).</li>
</ol>
<h3 id="discussion-on-num">Discussion on Num</h3>
<p>Note that at the moment, <code>backprop</code>, <code>gradBP</code>, <code>(^^.)</code>, and most <code>BVar</code>-based operations all require a <code>Num</code> instance on the things being backpropagated. This is an API decision that is a compromise between different options, and the <a href="https://github.com/mstksg/backprop#readme">README</a> has a deeper discussion on this.</p>
<p>For the most part, writing a <code>Num</code> instance for your types is some easy and quick boilerplate if your type derives Generic (and we can use <em><a href="http://hackage.haskell.org/package/one-liner-instances">one-liner-instances</a></em>), like we saw above with the <code>Num</code> instance for <code>Net</code>.</p>
<p>One potential drawback is that requiring a <code>Num</code> instance means you can’t directly backpropagate tuples. This can be an issue because of how pervasive tuples are used for currying/uncurrying, and also because automatically generated prisms use tuples for constructors with multiple fields.</p>
<p>To mitigate this issue, the library exports some convenient tuples-with-Num-instances in <code>Numeric.Backprop.Tuple</code>. If you are writing an application, you can consider also using the orphan instances in <em><a href="https://hackage.haskell.org/package/NumInstances">NumInstances</a></em>.</p>
<h3 id="lifting-your-own-functions">Lifting your own functions</h3>
<p>Of course, all of this would be useless unless you had a way to manipulate <code>BVar</code>s. The library does provide lens-based accessors/setters. It also provides <code>Num</code>, <code>Fractional</code>, and <code>Floating</code> instances for <code>BVar</code>s so you can manipulate a <code>BVar s a</code> just like an <code>a</code> using its numeric instances. We leveraged this heavily by using <code>+</code>, <code>negate</code>, <code>log</code>, <code>/</code>, etc., and even going as far as re-using our entire <code>logistic</code> implementation because it only relied on numeric operations.</p>
<p>However, for our domain-specific operations (like matrix multiplication, norms, and dot products), we needed to somehow lift those operations into <em>backprop</em>-land, to work with <code>BVar</code>s.</p>
<p>This isn’t something that end-users of the library should be expected to do – ideally, this would be done by library maintainers and authors, so that users can use their types and operations with <em>backprop</em>. However, writing them is not magical – it just requires providing the result and the gradient with respect to a final total derivative. For example, let’s look at the implementation of the lifted <code>&lt;.&gt;</code>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Numeric.LinearAlgebra.Static</span> <span class="kw">as</span> <span class="dt">H</span></a>
<a class="sourceLine" id="cb27-2" title="2"></a>
<a class="sourceLine" id="cb27-3" title="3">(<span class="op">&lt;.&gt;</span>)</a>
<a class="sourceLine" id="cb27-4" title="4"><span class="ot">    ::</span> <span class="dt">Reifies</span> s <span class="dt">W</span></a>
<a class="sourceLine" id="cb27-5" title="5">    <span class="ot">=&gt;</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb27-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">BVar</span> s (<span class="dt">R</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb27-7" title="7">    <span class="ot">-&gt;</span> <span class="dt">BVar</span> s <span class="dt">Double</span></a>
<a class="sourceLine" id="cb27-8" title="8">(<span class="op">&lt;.&gt;</span>) <span class="ot">=</span> liftOp2 <span class="op">.</span> op2 <span class="op">$</span> \x y <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-9" title="9">    ( x <span class="op">H.&lt;.&gt;</span> y</a>
<a class="sourceLine" id="cb27-10" title="10">    , \d <span class="ot">-&gt;</span> (H.konst d <span class="op">*</span> y, x <span class="op">*</span> H.konst d)</a>
<a class="sourceLine" id="cb27-11" title="11">    )</a></code></pre></div>
<p>To lift <code>(&lt;.&gt;)</code>, we provide a function that, given its inputs <code>x</code> and <code>y</code>, gives the result (<code>x H.&lt;.&gt; y</code>), and also its gradient with respect to the total derivative of the result. For more details on the math, see the <a href="https://hackage.haskell.org/package/backprop-0.1.2.0/docs/Numeric-Backprop-Op.html">documentation for <code>Numeric.Backprop.Op</code></a>!</p>
<p>If you’re interested in writing your own lifted operations, take a look at the <a href="https://github.com/mstksg/hmatrix-backprop/blob/master/src/Numeric/LinearAlgebra/Static/Backprop.hs">source of the lifted hmatrix module</a>, which lifts (most) of the functionality of <em>hmatrix</em> for backprop. (And if you’re good at computing gradients, check out the module notes for some of the current unimplemented operators – any PR’s would definitely be appreciated!)</p>
<h2 id="conclusion">Conclusion</h2>
<p>The world is now your oyster! Go out and feel emboldened to numerically optimize everything you can get your hands on!</p>
<p>If you want to see an application to a more complex neural network type (and if you’re curious at how to implement the more “extensible” neural network types like in my <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html">blog series on extensible neural networks</a>), I wrote <a href="https://github.com/mstksg/backprop/blob/master/renders/extensible-neural.pdf">a quick write-up</a> on how to apply those type-level dependent programming techniques to <em>backprop</em> (also available in <a href="https://github.com/mstksg/backprop/blob/master/samples/extensible-neural.lhs">literate haskell</a>).</p>
<p>Really, though, the goal of backprop is to allow you to automatically differentiate and optimize things you have <em>already</em> written (or plan to write, if only you had the ability to optimize them). Over the next few weeks I’ll be lifting operations from other libraries in the ecosystem. Let me know if there are any that you might want me to look at first! Be also on the lookout for some other posts I’ll be writing on applying <em>backprop</em> to optimize things other than neural networks.</p>
<p>If you have any questions, feel free to leave a comment. You can also give me a shout on <a href="https://twitter.com/mstk" title="Twitter">twitter</a> (I’m <em><span class="citation" data-cites="mstk">@mstk</span></em>), on freenode’s <em>#haskell</em> (where I am usually idling as <em>jle`</em>), or on the <a href="https://gitter.im/dataHaskell/Lobby">DataHaskell gitter</a> (where I hang out as <em><span class="citation" data-cites="mstksg">@mstksg</span></em>).</p>
<p>Please let me know if you end up doing anything interesting with the library — I’d love to hear about it! And, until next time, happy Haskelling!</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>More or less. See module documentation for more information.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Backprop&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+backprop.html" class="tag-a-series" title="+Backprop"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/artificial-neural-networks.html" class="tag-a-tag">#artificial neural networks</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/machine-learning.html" class="tag-a-tag">#machine learning</a></li><li><a href="https://blog.jle.im/entries/tagged/numerical.html" class="tag-a-tag">#numerical</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+backprop.html" class="tag-a-series">+Backprop</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/interpreters-a-la-carte-duet.html">&quot;Interpreters a la Carte&quot; in Advent of Code 2017 Duet</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/you-could-have-invented-matrices.html">You Could Have Invented Matrices!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introducing-the-backprop-library.html';
    this.page.identifier = 'backprop-intro';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>