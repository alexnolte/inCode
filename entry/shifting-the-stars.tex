\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Shifting the Stars: Advent of Code with Galilean Optimization},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Shifting the Stars: Advent of Code with Galilean Optimization}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/shifting-the-stars.html}{in Code}}.}

Another short Advent of Code post! \href{https://adventofcode.com/2018}{Advent
of Code 2018} is in full swing; we're 40\% of the way through. Every once in a
while, if I find a fun way to solve a problem, I'll make a short post about it.
You can check out my other ones
\href{https://blog.jle.im/entries/series/+advent-of-code.html}{here on the
series page}, and you can also find my
\href{https://github.com/mstksg/advent-of-code-2018/blob/master/reflections.md}{daily
reflections} here, as well. And, again, if you're following along in Haskell,
why not hop on \href{https://twitter.com/glguy}{glguy's} semi-official
\href{https://adventofcode.com/2018/leaderboard/private}{Haskell Leaderboard}
(join code \texttt{43100-84040706})! There are also Haskellers on freenode
\#\#adventofcode, and also \#adventofcode on the Functional Programming slack.
You might also find my
\href{https://hackage.haskell.org/package/advent-of-code-api}{advent of code
api} haskell bindings helpful too!

Today, we're going to be using linear algebra, calculus, and galilian
transformations to solve the \emph{Day 10} challenge. (That's right, this isn't
just a Haskell blog, I do have
\href{https://blog.jle.im/entries/category/@math.html}{math} posts on occasion
too :) )

\hypertarget{part-1}{%
\section{Part 1}\label{part-1}}

\begin{quote}
It's no use; your navigation system simply isn't capable of providing walking
directions in the arctic circle, and certainly not in 1018.

The Elves suggest an alternative. In times like these, North Pole rescue
operations will arrange points of light in the sky to guide missing Elves back
to base. Unfortunately, the message is easy to miss: the points move slowly
enough that it takes hours to align them, but have so much momentum that they
only stay aligned for a second. If you blink at the wrong time, it might be
hours before another message appears.

You can see these points of light floating in the distance, and record their
position in the sky and their velocity, the relative change in position per
second (your puzzle input). The coordinates are all given from your perspective;
given enough time, those positions and velocities will move the points into a
cohesive message!

Rather than wait, you decide to fast-forward the process and calculate what the
points will eventually spell.

For example, suppose you note the following points:

\begin{verbatim}
position=< 9,  1> velocity=< 0,  2>
position=< 7,  0> velocity=<-1,  0>
position=< 3, -2> velocity=<-1,  1>
position=< 6, 10> velocity=<-2, -1>
position=< 2, -4> velocity=< 2,  2>
position=<-6, 10> velocity=< 2, -2>
position=< 1,  8> velocity=< 1, -1>
position=< 1,  7> velocity=< 1,  0>
position=<-3, 11> velocity=< 1, -2>
position=< 7,  6> velocity=<-1, -1>
position=<-2,  3> velocity=< 1,  0>
position=<-4,  3> velocity=< 2,  0>
position=<10, -3> velocity=<-1,  1>
position=< 5, 11> velocity=< 1, -2>
position=< 4,  7> velocity=< 0, -1>
position=< 8, -2> velocity=< 0,  1>
position=<15,  0> velocity=<-2,  0>
position=< 1,  6> velocity=< 1,  0>
position=< 8,  9> velocity=< 0, -1>
position=< 3,  3> velocity=<-1,  1>
position=< 0,  5> velocity=< 0, -1>
position=<-2,  2> velocity=< 2,  0>
position=< 5, -2> velocity=< 1,  2>
position=< 1,  4> velocity=< 2,  1>
position=<-2,  7> velocity=< 2, -2>
position=< 3,  6> velocity=<-1, -1>
position=< 5,  0> velocity=< 1,  0>
position=<-6,  0> velocity=< 2,  0>
position=< 5,  9> velocity=< 1, -2>
position=<14,  7> velocity=<-2,  0>
position=<-3,  6> velocity=< 2, -1>
\end{verbatim}

Each line represents one point. Positions are given as
\texttt{\textless{}X,\ Y\textgreater{}} pairs: X represents how far left
(negative) or right (positive) the point appears, while Y represents how far up
(negative) or down (positive) the point appears.

At \texttt{0} seconds, each point has the position given. Each second, each
point's velocity is added to its position. So, a point with velocity
\texttt{\textless{}1,\ -2\textgreater{}} is moving to the right, but is moving
upward twice as quickly. If this point's initial position were
\texttt{\textless{}3,\ 9\textgreater{}}, after \texttt{3} seconds, its position
would become \texttt{\textless{}6,\ 3\textgreater{}}.

Over time, the points listed above would move like this:

\begin{verbatim}
Initially:
........#.............
................#.....
.........#.#..#.......
......................
#..........#.#.......#
...............#......
....#.................
..#.#....#............
.......#..............
......#...............
...#...#.#...#........
....#..#..#.........#.
.......#..............
...........#..#.......
#...........#.........
...#.......#..........

After 1 second:
......................
......................
..........#....#......
........#.....#.......
..#.........#......#..
......................
......#...............
....##.........#......
......#.#.............
.....##.##..#.........
........#.#...........
........#...#.....#...
..#...........#.......
....#.....#.#.........
......................
......................

After 2 seconds:
......................
......................
......................
..............#.......
....#..#...####..#....
......................
........#....#........
......#.#.............
.......#...#..........
.......#..#..#.#......
....#....#.#..........
.....#...#...##.#.....
........#.............
......................
......................
......................

After 3 seconds:
......................
......................
......................
......................
......#...#..###......
......#...#...#.......
......#...#...#.......
......#####...#.......
......#...#...#.......
......#...#...#.......
......#...#...#.......
......#...#..###......
......................
......................
......................
......................

After 4 seconds:
......................
......................
......................
............#.........
........##...#.#......
......#.....#..#......
.....#..##.##.#.......
.......##.#....#......
...........#....#.....
..............#.......
....#......#...#......
.....#.....##.........
...............#......
...............#......
......................
......................
\end{verbatim}

After 3 seconds, the message appeared briefly: \texttt{HI}. Of course, your
message will be much longer and will take many more seconds to appear.

\emph{What message will eventually appear in the sky?}
\end{quote}

The problem tells us to talk about a system of N particles, each moving at
constant velocity. From this, we can see that the position of particle
\includegraphics{https://latex.codecogs.com/png.latex?i} at time
\includegraphics{https://latex.codecogs.com/png.latex?t} is
\includegraphics{https://latex.codecogs.com/png.latex?\%5Cmathbf\%7Br\%7D_i\%20\%2B\%20\%5Cmathbf\%7Bv\%7D_i\%20t},
where
\includegraphics{https://latex.codecogs.com/png.latex?\%5Cmathbf\%7Br\%7D_i} is
the \emph{initial position} vector, and
\includegraphics{https://latex.codecogs.com/png.latex?\%5Cmathbf\%7Bv\%7D_i} is
the \emph{velocity} vector.

More generally, we can express this in terms of matrices. If we talk talk about
\includegraphics{https://latex.codecogs.com/png.latex?R} as the
\includegraphics{https://latex.codecogs.com/png.latex?n\%20\%5Ctimes\%202}
matrix of initial positions, and
\includegraphics{https://latex.codecogs.com/png.latex?V} as the
\includegraphics{https://latex.codecogs.com/png.latex?n\%20\%5Ctimes\%202}
matrix of initial velocities:

\$\$ R \sim \textbackslash{}begin\{bmatrix\} x\_0 \& y\_0 \textbackslash{} x\_1
\& y\_1 \textbackslash{} x\_2 \& y\_2 \textbackslash{} \vdots \&
\vdots \textbackslash{}end\{bmatrix\}

V \sim \textbackslash{}begin\{bmatrix\} v\_x0 \& v\_y0 \textbackslash{} v\_x1 \&
v\_y1 \textbackslash{} v\_x2 \& v\_y2 \textbackslash{} \vdots \&
\vdots \textbackslash{}end\{bmatrix\} \$\$

Then we can say that the state of the total system at time
\includegraphics{https://latex.codecogs.com/png.latex?t} is given by
\includegraphics{https://latex.codecogs.com/png.latex?R\%20\%2B\%20V\%20t}

Now, how can we find the time when all of the letters are aligned?

For this, we can make a \emph{somewhat justified guess}: looking at the input
data, we see that things start out as ``scattered'', and end up in a clean
clustered arrangement. We know that the ending arrangement must be clustered
fairly close together because we only have a few hundred points in the input
data set, whereas the start times are all in the thousands or higher. And, once
things get clustered, they will also get un-clustered right away, because of the
randomness of the directions of motion.

This gives us a clue: if we can find the
\includegraphics{https://latex.codecogs.com/png.latex?t} that will give us the
\includegraphics{https://latex.codecogs.com/png.latex?R\%20\%2B\%20V\%20t} with
the \emph{least variance}, we are good to go!

All of a sudden, this is now an
\href{https://en.wikipedia.org/wiki/Mathematical_optimization}{optimization}
problem. Find the \includegraphics{https://latex.codecogs.com/png.latex?t} that
minimizes the variance of x plus the variance of y. This can be done by using
some calculus: we can compute the function producing the sum of variances as a
function of time, take the first derivative with respect to time, and solve for
\includegraphics{https://latex.codecogs.com/png.latex?t} that makes the first
derivative zero.

The typical formula for finding the sum of variances of a matrix
\includegraphics{https://latex.codecogs.com/png.latex?M} is to take
\includegraphics{https://latex.codecogs.com/png.latex?\%5Cmathrm\%7BTr\%7D\%20\%5Cleft\%28\%20\%5Cleft\%28M\%20-\%20\%5Cmu_M\%20\%5Cright\%29\%5ET\%20\%5Cleft\%28M\%20-\%20\%5Cmu_M\%20\%5Cright\%29\%20\%5Cright\%29},
but in this form it's not too fun to work with. That's because we have to
re-compute the mean of of the positions at every point, and things will get
messy before they get clean.

Conceptually, however, we have a powerful tool: the
\href{https://en.wikipedia.org/wiki/Center-of-momentum_frame}{Center of Mass
frame}. Essentially, because our system has no external forces (and no net
acceleration), we can \emph{perform a Galilean transform} into a frame of
reference where the center of mass is \emph{fixed at the origin}, and
\emph{never changes}. If we can do this, then we only need to compute
\includegraphics{https://latex.codecogs.com/png.latex?\%5Cmathrm\%7BTr\%7D\%20\%5Cleft\%28M\%5ET\%20M\%20\%5Cright\%29}
(since we guarantee that the mean of
\includegraphics{https://latex.codecogs.com/png.latex?M} is 0), which is
relatively easy peasy. If we find the minimizing time in the CoM frame, then we
can also use that same time in our original frame, because Galilean
transformations leave time unchanged (unlike Lorentz transforms and other
similar coordinate transformations).

Because our system has points of all equal ``mass'', we can shift
\includegraphics{https://latex.codecogs.com/png.latex?R} into
\includegraphics{https://latex.codecogs.com/png.latex?\%5Chat\%7BR\%7D}
(\includegraphics{https://latex.codecogs.com/png.latex?R} shifted into the
center of mass frame) and
\includegraphics{https://latex.codecogs.com/png.latex?V} into
\includegraphics{https://latex.codecogs.com/png.latex?\%5Chat\%7BV\%7D} by just
subtracting by the \emph{initial} mean:

{[} \textbackslash{}begin\{aligned\} \textbackslash{}hat\{R\} \& = R -
\textbackslash{}mu\_R \textbackslash{}\textbackslash{} \textbackslash{}hat\{V\}
\& = V - \textbackslash{}mu\_V
\textbackslash{}end\{aligned\}{]}(https://latex.codecogs.com/png.latex?\%0A\%5Cbegin\%7Baligned\%7D\%0A\%5Chat\%7BR\%7D\%20\%26\%20\%3D\%20R\%20-\%20\%5Cmu\_R\%20\%5C\%5C\%0A\%5Chat\%7BV\%7D\%20\%26\%20\%3D\%20V\%20-\%20\%5Cmu\_V\%0A\%5Cend\%7Baligned\%7D\%0A
" \textbackslash{}begin\{aligned\} \hat{R} \& = R - \mu\_R \textbackslash{}
\hat{V} \& = V - \mu\_V \textbackslash{}end\{aligned\} ")

This means that our formula for variance at time T is now simple to manipulate.
Because we now know that center of mass \emph{is always zero}, we can compute
the sum of variance as:

{[} \textbackslash{}lvert \textbackslash{}Sigma(t) \textbackslash{}rvert =
\textbackslash{}mathrm\{Tr\} \textbackslash{}left( \textbackslash{}hat\{R\} +
\textbackslash{}hat\{V\} t \textbackslash{}right)\^{}T \textbackslash{}left(
\textbackslash{}hat\{R\} + \textbackslash{}hat\{V\} t
\textbackslash{}right){]}(https://latex.codecogs.com/png.latex?\%0A\%5Clvert\%20\%5CSigma\%28t\%29\%20\%5Crvert\%20\%3D\%20\%5Cmathrm\%7BTr\%7D\%20\%5Cleft\%28\%20\%5Chat\%7BR\%7D\%20\%2B\%20\%5Chat\%7BV\%7D\%20t\%20\%5Cright\%29\%5ET\%20\%5Cleft\%28\%20\%5Chat\%7BR\%7D\%20\%2B\%20\%5Chat\%7BV\%7D\%20t\%20\%5Cright\%29\%0A
" \lvert \Sigma(t) \rvert = \mathrm{Tr} \left( \hat{R} + \hat{V} t \right)\^{}T
\left( \hat{R} + \hat{V} t \right) ")

We can do some simplification, remembering that the trace distributes over
addition, and that
\includegraphics{https://latex.codecogs.com/png.latex?\%5Cmathrm\%7BTr\%20\%5Cleft\%28\%20X\%5ET\%20Y\%20\%5Cright\%29\%20\%3D\%20\%5Cmathrm\%7BTr\%7D\%20\%5Cleft\%20\%28Y\%5ET\%20\%5Cright\%29}:

{[} \textbackslash{}begin\{aligned\} \textbackslash{}lvert
\textbackslash{}Sigma(t) \textbackslash{}rvert \& = \textbackslash{}mathrm\{Tr\}
(\textbackslash{}hat\{R\}\^{}T \textbackslash{}hat\{R\})
\textbackslash{}\textbackslash{} \& + 2 \textbackslash{}mathrm\{Tr\}
(\textbackslash{}hat\{R\}\^{}T \textbackslash{}hat\{V\}) t
\textbackslash{}\textbackslash{} \& + \textbackslash{}mathrm\{Tr\}
(\textbackslash{}hat\{V\}\^{}T \textbackslash{}hat\{V\}) t\^{}2
\textbackslash{}end\{aligned\}{]}(https://latex.codecogs.com/png.latex?\%0A\%5Cbegin\%7Baligned\%7D\%0A\%5Clvert\%20\%5CSigma\%28t\%29\%20\%5Crvert\%20\%26\%20\%3D\%20\%5Cmathrm\%7BTr\%7D\%20\%28\%5Chat\%7BR\%7D\%5ET\%20\%5Chat\%7BR\%7D\%29\%20\%5C\%5C\%0A\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%26\%20\%2B\%202\%20\%5Cmathrm\%7BTr\%7D\%20\%28\%5Chat\%7BR\%7D\%5ET\%20\%5Chat\%7BV\%7D\%29\%20t\%20\%5C\%5C\%0A\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%26\%20\%2B\%20\%5Cmathrm\%7BTr\%7D\%20\%28\%5Chat\%7BV\%7D\%5ET\%20\%5Chat\%7BV\%7D\%29\%20t\%5E2\%0A\%5Cend\%7Baligned\%7D\%0A
"

\begin{aligned}
\lvert \Sigma(t) \rvert & = \mathrm{Tr} (\hat{R}^T \hat{R}) \\
                   & + 2 \mathrm{Tr} (\hat{R}^T \hat{V}) t \\
                   & + \mathrm{Tr} (\hat{V}^T \hat{V}) t^2
\end{aligned}

")

Now, we want to minimize the sum of variances. So to do that, we can take the
first derivative with respect to
\includegraphics{https://latex.codecogs.com/png.latex?t}, and set it to be zero:

{[} \textbackslash{}begin\{aligned\} \textbackslash{}frac\{d\}\{d t\}
\textbackslash{}lvert \textbackslash{}Sigma(t) \textbackslash{}rvert \& = 2
\textbackslash{}mathrm\{Tr\} (\textbackslash{}hat\{R\}\^{}T
\textbackslash{}hat\{V\}) + 2 \textbackslash{}mathrm\{Tr\}
(\textbackslash{}hat\{V\}\^{}T \textbackslash{}hat\{V\}) t
\textbackslash{}\textbackslash{} 0 \& = 2 \textbackslash{}mathrm\{Tr\}
(\textbackslash{}hat\{R\}\^{}T \textbackslash{}hat\{V\}) + 2
\textbackslash{}mathrm\{Tr\} (\textbackslash{}hat\{V\}\^{}T
\textbackslash{}hat\{V\}) t\_f \textbackslash{}\textbackslash{} t\_f \& = -
\textbackslash{}frac\{\textbackslash{}mathrm\{Tr\}
(\textbackslash{}hat\{R\}\^{}T
\textbackslash{}hat\{V\}\^{}T)\}\{\textbackslash{}mathrm\{Tr\}(\textbackslash{}hat\{V\}\^{}T
\textbackslash{}hat\{V\})\}
\textbackslash{}end\{aligned\}{]}(https://latex.codecogs.com/png.latex?\%0A\%5Cbegin\%7Baligned\%7D\%0A\%5Cfrac\%7Bd\%7D\%7Bd\%20t\%7D\%20\%5Clvert\%20\%5CSigma\%28t\%29\%20\%5Crvert\%20\%26\%20\%3D\%202\%20\%5Cmathrm\%7BTr\%7D\%20\%28\%5Chat\%7BR\%7D\%5ET\%20\%5Chat\%7BV\%7D\%29\%0A\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%20\%2B\%202\%20\%5Cmathrm\%7BTr\%7D\%20\%28\%5Chat\%7BV\%7D\%5ET\%20\%5Chat\%7BV\%7D\%29\%20t\%20\%5C\%5C\%0A0\%20\%26\%20\%3D\%202\%20\%5Cmathrm\%7BTr\%7D\%20\%28\%5Chat\%7BR\%7D\%5ET\%20\%5Chat\%7BV\%7D\%29\%20\%2B\%202\%20\%5Cmathrm\%7BTr\%7D\%20\%28\%5Chat\%7BV\%7D\%5ET\%20\%5Chat\%7BV\%7D\%29\%20t\_f\%20\%5C\%5C\%0At\_f\%20\%26\%20\%3D\%20-\%20\%5Cfrac\%7B\%5Cmathrm\%7BTr\%7D\%20\%28\%5Chat\%7BR\%7D\%5ET\%20\%5Chat\%7BV\%7D\%5ET\%29\%7D\%7B\%5Cmathrm\%7BTr\%7D\%28\%5Chat\%7BV\%7D\%5ET\%20\%5Chat\%7BV\%7D\%29\%7D\%0A\%5Cend\%7Baligned\%7D\%0A
" \textbackslash{}begin\{aligned\} \frac{d}{d t} \lvert \Sigma(t) \rvert \& = 2
\mathrm{Tr} (\hat{R}\^{}T \hat{V}) + 2 \mathrm{Tr} (\hat{V}\^{}T \hat{V}) t
\textbackslash{} 0 \& = 2 \mathrm{Tr} (\hat{R}\^{}T \hat{V}) + 2 \mathrm{Tr}
(\hat{V}\^{}T \hat{V}) t\_f \textbackslash{} t\_f \& = -
\frac{\mathrm{Tr} (\hat{R}^T \hat{V}^T)}{\mathrm{Tr}(\hat{V}^T \hat{V})}
\textbackslash{}end\{aligned\} ")

And just like that, we have a formula for
\includegraphics{https://latex.codecogs.com/png.latex?t}!

We can simplify this a little more by remembering that the trace of a matrix
multiplication is the sum of the dot product of the rows. That means we can
write:

{[} t\_f = - \textbackslash{}frac\{\textbackslash{}Sigma\_i
\textbackslash{}hat\{r\} \textbackslash{}cdot
\textbackslash{}hat\{v\}\}\{\textbackslash{}Sigma\_i \textbackslash{}hat\{v\}
\textbackslash{}cdot
\textbackslash{}hat\{v\}\}{]}(https://latex.codecogs.com/png.latex?\%0At\_f\%20\%3D\%20-\%20\%5Cfrac\%7B\%5CSigma\_i\%20\%5Chat\%7Br\%7D\%20\%5Ccdot\%20\%5Chat\%7Bv\%7D\%7D\%7B\%5CSigma\_i\%20\%5Chat\%7Bv\%7D\%20\%5Ccdot\%20\%5Chat\%7Bv\%7D\%7D\%0A
" t\_f = - \frac{\Sigma_i \hat{r} \cdot \hat{v}}{\Sigma_i \hat{v} \cdot \hat{v}}
")

Once we find this, we can plug into our original form, to find that our final
points are, in our un-shifted coordinates,
\includegraphics{https://latex.codecogs.com/png.latex?R\%20\%2B\%20V\%20t} (we
can also use the shifted coordinates as well).

We can write this as a Haskell function, assuming we take in a list of
\texttt{V2\ Double} for velocities and \texttt{V2\ Double} for positions, from
the \emph{\href{https://en.wikipedia.org/wiki/Center-of-momentum_frame}{linear}}
library:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- | Shift so that centroid is at zero}
\OtherTok{centralize ::}\NormalTok{ [}\DataTypeTok{V2} \DataTypeTok{Double}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{V2} \DataTypeTok{Double}\NormalTok{]}
\NormalTok{centralize ps }\FunctionTok{=}\NormalTok{ map (subtract mean) ps}
  \KeywordTok{where}
\NormalTok{    mean }\FunctionTok{=}\NormalTok{ (}\FunctionTok{/}\NormalTok{ len) }\FunctionTok{<$>}\NormalTok{ tot}
\NormalTok{    (}\DataTypeTok{Sum}\NormalTok{ tot, }\DataTypeTok{Sum}\NormalTok{ len) }\FunctionTok{=}\NormalTok{ foldMap (\textbackslash{}x }\OtherTok{->}\NormalTok{ (}\DataTypeTok{Sum}\NormalTok{ x, }\DataTypeTok{Sum} \DecValTok{1}\NormalTok{)) ps}

\CommentTok{-- | Sum of dot products}
\OtherTok{sumOfDots ::}\NormalTok{ [}\DataTypeTok{Point}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Point}\NormalTok{] }\OtherTok{->} \DataTypeTok{Double}
\NormalTok{sumOfDots xs ys }\FunctionTok{=}\NormalTok{ sum }\FunctionTok{$}\NormalTok{ zipWith L.dot xs ys}

\NormalTok{findWord}
\OtherTok{    ::}\NormalTok{ [}\DataTypeTok{V2} \DataTypeTok{Double}\NormalTok{]                  }\CommentTok{-- ^ velocities}
    \OtherTok{->}\NormalTok{ [}\DataTypeTok{V2} \DataTypeTok{Double}\NormalTok{]                  }\CommentTok{-- ^ initial positions}
    \OtherTok{->}\NormalTok{ ([}\DataTypeTok{V2} \DataTypeTok{Double}\NormalTok{], }\DataTypeTok{Double}\NormalTok{)    }\CommentTok{-- ^ points in word, and final time t}
\NormalTok{findWord (centralize}\OtherTok{->}\NormalTok{vs) (centralize}\OtherTok{->}\NormalTok{xs) }\FunctionTok{=}\NormalTok{ (final, t)}
  \KeywordTok{where}
\NormalTok{    t     }\FunctionTok{=}\NormalTok{ negate }\FunctionTok{$}\NormalTok{ sumOfDots xs vs }\FunctionTok{/}\NormalTok{ sumOfDots vs vs}
\NormalTok{    final }\FunctionTok{=}\NormalTok{ zipWith (\textbackslash{}v x }\OtherTok{->}\NormalTok{ x }\FunctionTok{+}\NormalTok{ t }\FunctionTok{L.*^}\NormalTok{ v) vs xs}
\end{Highlighting}
\end{Shaded}

To answer the actual problem, we do need to \texttt{round} the time (and the
final points) to display them on the screen.

\hypertarget{part-2}{%
\section{Part 2}\label{part-2}}

\begin{quote}
Good thing you didn't have to wait, because that would have taken a long time -
much longer than the \texttt{3} seconds in the example above.

Impressed by your sub-hour communication capabilities, the Elves are curious:
\emph{exactly how many seconds would they have needed to wait for that message
to appear?}
\end{quote}

This one is just \includegraphics{https://latex.codecogs.com/png.latex?t}, which
we solved for in the last part!

\hypertarget{message-in-the-stars}{%
\section{Message in the Stars}\label{message-in-the-stars}}

Optimization by finding the first derivative is a common tool in math that is
definitely under-utilized! In practice, unless we have a really clean system, we
won't be able to analytically ``solve for zero'' in most situations. However,
this system shows all of the signs of being well-behaved: the thing we are
minimizing is quadratic on our variable, so the first derivative will be linear
on our variable, making ``solving for zero'' very simple.

The first step was looking at our system as a matrix formula in the first place.
This gave us key insights from linear algebra that we could exploit. However,
even though things are quadratic, they might have been mentally complex because
we have to re-evaluate the mean of all of the points at all points in time in
order to compute the sum of variances. To get around this, we borrow from a
common tool used in classical mechanics that allows us not only to \emph{fix the
mean} over the entire time span, but also \emph{set it to the origin}, so we
don't even have to worry about it ever coming up at any point in time. This made
our symbolic manipulation easy enough to do on a few lines of notebook paper.

Anyway, I thought this was a fun twist on the typical Advent of Code challenges.
It's always fun when something that you might think can only be solved by
simulation turns out to have a closed-form solution\ldots{}but even more fun
when the closed-form solution turns out to just be simple linear algebra:

{[} t\_f = - \textbackslash{}frac\{\textbackslash{}Sigma\_i
\textbackslash{}hat\{r\} \textbackslash{}cdot
\textbackslash{}hat\{v\}\}\{\textbackslash{}Sigma\_i \textbackslash{}hat\{v\}
\textbackslash{}cdot
\textbackslash{}hat\{v\}\}{]}(https://latex.codecogs.com/png.latex?\%0At\_f\%20\%3D\%20-\%20\%5Cfrac\%7B\%5CSigma\_i\%20\%5Chat\%7Br\%7D\%20\%5Ccdot\%20\%5Chat\%7Bv\%7D\%7D\%7B\%5CSigma\_i\%20\%5Chat\%7Bv\%7D\%20\%5Ccdot\%20\%5Chat\%7Bv\%7D\%7D\%0A
" t\_f = - \frac{\Sigma_i \hat{r} \cdot \hat{v}}{\Sigma_i \hat{v} \cdot \hat{v}}
")

``It's just dot products all the way down.''

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
