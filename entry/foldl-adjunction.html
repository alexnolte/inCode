<!DOCTYPE HTML>
<html><head><title>Adjunctions in the wild: foldl · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="I recently made a few connections that linked some different concepts in Haskell that I hadn’t realized before."><meta property="og:type" content="article"><meta property="og:title" content="Adjunctions in the wild: foldl"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/foldl-adjunction.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/foldl-adjunction.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Adjunctions in the wild: foldl</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/foldl-adjunction.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/foldl-adjunction.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/foldl-adjunction.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@math.html" class="tag-a-category" title="@MATH">Math</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>I recently made a few connections that linked some different concepts in Haskell that I hadn’t realized before.</p>
<h2 id="foldl">foldl</h2>
<p>The first concept is the great <em><a href="http://hackage.haskell.org/package/foldl">foldl</a></em> library, which provides a nice “stream processor” type called <code>Fold</code>, where <code>Fold r a</code> is a stream processor that takes a stream of <code>r</code>s and produces an <code>a</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">sum</span><span class="ot">  ::</span> <span class="dt">Num</span> a        <span class="ot">=&gt;</span> <span class="dt">Fold</span> a a</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">mean ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Fold</span> a a</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="fu">elem</span><span class="ot"> ::</span> <span class="dt">Eq</span> a         <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fold</span> a <span class="dt">Bool</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a>fold <span class="fu">sum</span>  [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="pp">#   =&gt; 10</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>fold mean [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="pp">#   =&gt; 2.5</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>fold (<span class="fu">elem</span> <span class="dv">3</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="pp">#   =&gt; True</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>fold (<span class="fu">elem</span> <span class="dv">5</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="pp">#   =&gt; False</span></span></code></pre></div>
<p>The most useful thing about the library is that it treats the folds as first-class objects, so you can create more complex folds by combining simpler folds</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">{-# LANGUAGE ApplicativeDo #-}</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="ot">variance ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Fold</span> a a</span>
<span id="cb2-4"><a href="#cb2-4"></a>variance <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    m  <span class="ot">&lt;-</span> mean</span>
<span id="cb2-6"><a href="#cb2-6"></a>    m2 <span class="ot">&lt;-</span> lmap (<span class="op">^</span><span class="dv">2</span>) mean     <span class="co">-- the mean of squared items</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="fu">pure</span> (m2 <span class="op">-</span> m<span class="op">*</span>m)</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="ot">varianceTooBig ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Fold</span> a <span class="dt">Bool</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>varianceTooBig <span class="ot">=</span> (<span class="op">&gt;</span> <span class="dv">3</span>) <span class="op">&lt;$&gt;</span> variance</span></code></pre></div>
<p>Most importantly, <code>Fold r</code> is an instance of both <code>Functor</code> and <code>Applicative</code>, so you can map over and combine the results of different folds.</p>
<h2 id="adjunctions">Adjunctions</h2>
<p>The second concept is the idea of <em><a href="https://en.wikipedia.org/wiki/Adjoint_functors">adjoint functors</a></em> (see also <a href="https://bartoszmilewski.com/2016/04/18/adjunctions/">Bartosz Milewski’s introduction</a> and <a href="https://ncatlab.org/nlab/show/adjoint+functor">nlab</a>’s description), represented in Haskell by the <em><a href="https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html">adjunctions</a></em> library and typeclass (<a href="https://chrispenner.ca/posts/adjunction-battleship">Chris Penner</a> has a nice article with an example of using the typeclass).</p>
<p>The idea is that, for some functors, we can think of a “conceptual inverse”. We can ask “I have a nice functor <code>F</code>. Conceptually, what functor represents the opposite idea/spirit of <code>F</code>?” The concept of an adjunction is one way to formalize what this means. The high-level idea is that if <code>F -| G</code> (<code>F</code> is left adjoint to <code>G</code>, and <code>G</code> is right adjoint to <code>F</code>), then all the ways of going “out of” <code>F a</code> to <code>b</code> are the same as all the ways of going “into” <code>G b</code> from <code>a</code>. Ways of going out can be encoded as ways of going in, and vice versa. They represent opposite ideas.</p>
<p>For example, one of the more famous adjunctions in Haskell is the adjunction between <code>(,) r</code> and <code>(-&gt;) r</code>. “Tupling” represents some sort of “opposite” idea to “parameterizing”.</p>
<p>The ways to get “out” of a tuple is <code>(r, a) -&gt; b</code>. The ways to go “into” a function is <code>a -&gt; (r -&gt; b)</code>. Haskellers will recognize that these two types are the “same” (isomorphic) — any <code>(a, b) -&gt; c</code> can be re-written as <code>a -&gt; (b -&gt; c)</code> (currying), and vice versa (uncurrying).</p>
<p>Another common pair is with same-typed either and tuple:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">newtype</span> <span class="dt">SameEither</span> a <span class="ot">=</span> <span class="dt">SE</span> (<span class="dt">Either</span> a a)</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">newtype</span> <span class="dt">SameTuple</span>  a <span class="ot">=</span> <span class="dt">ST</span> (a, a)</span></code></pre></div>
<p>People familiar with <code>Either</code> (sums) and <code>(,)</code> (products) in Haskell will recognize them as “opposite” ideas — one is “or”, and the other is “and” (depending on if you are talking about using them or making them).</p>
<p>We can formalize this idea of opposites using adjunctions: Going “out of” <code>Either a a</code> into <code>b</code> can be encoded as going “into” <code>(b, b)</code> from <code>a</code>,m and vice versa: <code>Either a a -&gt; b</code> can be encoded as <code>a -&gt; (b, b)</code> (and vice versa) — the two types are isomorphic</p>
<p>Conceptually this makes sense: to go out of <code>Either a a</code>, you have to handle the situation of getting a <code>Left</code> and the situation of getting a <code>Right</code>. To go into <code>(b, b)</code>, you have to able to ask what goes in the first field, and what goes in the right field.</p>
<p>Aside from being an interesting curiosity (formalizing the idea of “opposite idea” is pretty neat), hunting for adjunctions can be useful in figuring out “why” a functor is useful, what you can do with it, and also what functors are intimately connected with it. There’s also the helper functions in the <a href="https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html">Data.Functor.Adjunction</a> module that implement some nice helper functions on your types if an adjoint happens to exist — you can do some neat things by going “back and forth” between adjoint functors.</p>
<h2 id="hunting-for-adjunctions">Hunting for Adjunctions</h2>
<p>So, from the build-up, you’ve probably guessed what we’re going to do next: find a functor that is adjoint to <code>Fold r</code>. If you guessed that … you’re right! Let’s go adjunction hunting!</p>
<p>Important note — the rest of this section is not a set of hard rules, but rather an intuitive process of heuristics to search for candidates that would be adjoint to a given functor of interest. There are no hard and fast rules, and the adjoint might not always exist — it usually doesn’t. But when it does, it can be a pleasant surprise.</p>
<p>Now, on to the hunting. Let’s say we have functor <code>Q</code> and we want to identify any adjoints. We want to spot functions that use both <code>Q a</code> and <code>a</code> with some other value, in <a href="https://www.foldl.io/posts/pos-neg-functions/">opposite positions</a>.</p>
<p>(Of course, this is only the case if we are using a functor that comes from a library. If we are writing our own functor from scratch, and want to hunt for adjunctions there, we have to instead <em>think</em> of ways to use <code>F a</code> and <code>a</code>)</p>
<p>One common pattern is functions for “converting between” the going-in and going-out functions. In <a href="https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html">Data.Functor.Adjunctions</a>, these are called <code>leftAdjunct</code> and <code>rightAdjunct</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">leftAdjunct  ::</span> <span class="dt">Adjunction</span> f u <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> u b)</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ot">rightAdjunct ::</span> <span class="dt">Adjunction</span> f u <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> u b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>These will often come in pairs, and they are significant because they are essentially the adjunctions “in practice”: Sure, an <code>(r, a) -&gt; b</code> is useful, but “using” the adjunction means that you can convert between <code>(r, a) -&gt; b</code> (<code>uncurry</code>) and backwards.</p>
<p>Basically, any time <code>Q a</code> is spotted with <code>a</code> with opposite polarity, it’s something to investigate.</p>
<p>Another common pattern that you can spot are “indexing” and “tabulating” functions, in the case that you have a right-adjoint:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">indexAdjunction    ::</span> <span class="dt">Adjunction</span> f u <span class="ot">=&gt;</span> u b <span class="ot">-&gt;</span> f () <span class="ot">-&gt;</span> b</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">tabulateAdjunction ::</span> <span class="dt">Adjunction</span> f u <span class="ot">=&gt;</span> (f () <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> u b</span></code></pre></div>
<p>These also come in pairs! And it’s possible to write the other pair (<code>leftAdjunct</code> and <code>rightAdjunct</code>) in terms of this pair, actually — so finding one is finding the other.</p>
<p><code>indexAdjunction</code> means: if it’s possible to “extract” from <code>u b</code> to <code>b</code> using only an <code>f ()</code> as extra information, then <code>u</code> is right-adjoint to <code>f</code>.</p>
<p><code>tabulateAdjunction</code> means: if it’s possible to “generate” a <code>u b</code> based on a function that “builds” a <code>b</code> from <code>f ()</code>, then <code>u</code> is right-adjoint to <code>f</code>.</p>
<p>In the case of <code>Fold</code>, there is actually only one takes a <code>Fold r a</code> and returns an <code>a</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">fold ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> [r] <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>(the type has been simplified and re-labeled, for illustration’s sake)</p>
<p>You “give” a <code>Fold r b</code> and “get” an <code>b</code> (and so they have opposite polarities/positions). This sort of function would make <code>Fold r</code> a <em>right adjoint</em>, since the naked type <code>b</code> is the final result, not the input.</p>
<p>Of our common patterns, this one looks a looooot like <code>indexAdjunction</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">fold            ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> [r]  <span class="ot">-&gt;</span> b</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="ot">indexAdjunction ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> f () <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>This means that <code>Fold r b</code> is right-adjoint to some functor <code>f</code> where <code>f () = [r]</code>. A good first guess (just a hunch?) would be to just have <code>f a = ([r], a)</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">data</span> <span class="dt">EnvList</span> r a <span class="ot">=</span> <span class="dt">EnvList</span> [r] a</span>
<span id="cb8-2"><a href="#cb8-2"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p><code>EnvList r</code> is essentially just a <em>list</em> of <code>r</code>s. It is now also our suspect for a potential left-adjoint to <code>Fold r</code>: a “conceptual opposite”.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">indexFold ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> <span class="dt">EnvList</span> r () <span class="ot">-&gt;</span> b</span>
<span id="cb9-2"><a href="#cb9-2"></a>indexFold fld (<span class="dt">EnvList</span> rs _) <span class="ot">=</span> fold f rs</span></code></pre></div>
<p>So to “seal the deal”, let’s find its pair, <code>tabulateAdjunction</code>. That means we are looking for:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">tabulateFold ::</span> (<span class="dt">EnvList</span> r () <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span></code></pre></div>
<p>Or, to simplify the type by expanding the definition of <code>EnvList r ()</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">tabulateFold ::</span> ([r] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span></code></pre></div>
<p>This tells us that, given any list processor <code>[r] -&gt; b</code>, we can write a fold <code>Fold r b</code> representing that list processor. Scanning things more, we can see that this actually looks a lot like <code>foldMap</code> from the library:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Foldl</span> <span class="kw">as</span> <span class="dt">F</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a>F.foldMap (\r <span class="ot">-&gt;</span> [r])</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="ot">    ::</span> ([r] <span class="ot">-&gt;</span> b)</span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span></code></pre></div>
<p>So:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">tabulateFold ::</span> (<span class="dt">EnvList</span> r () <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span>
<span id="cb13-2"><a href="#cb13-2"></a>tabulateFold f <span class="ot">=</span> F.foldMap (\r <span class="ot">-&gt;</span> <span class="dt">EnvList</span> [r] ())</span></code></pre></div>
<p>And…that gives us a pretty strong footing to claim that <code>EnvList r</code> is the left-adjoint of <code>Fold r</code>.</p>
<p>Note that if we had missed <code>fold</code> during our adjunction hunt, we might have also lucked out by noticing <code>F.foldMap (:[])</code> fitting the criteria for a candidate for <code>tabulateAdjunction</code>, instead.</p>
<h2 id="opposite-concepts">Opposite Concepts</h2>
<p>We’ve identified a likely candidate for a left-adjoint to <code>Fold r</code>! But … does any of this make any sense? Does this make sense as a left-adjoint, conceptually … and did we gain anything?</p>
<p>Let’s think about this from the beginning: What is the conceptual opposite of “something that folds a list”?</p>
<p>Well, what other thing is more naturally an opposite than “a list to be folded”!</p>
<ul>
<li><code>EnvList r</code>: Is a list of <code>r</code></li>
<li><code>Fold r</code>: Consumes a list of <code>r</code></li>
</ul>
<p>Or, in terms of the result of the functor application:</p>
<ul>
<li><code>EnvList r a</code>
<ul>
<li>A list of <code>r</code></li>
<li>Tuplied with an <code>a</code></li>
</ul></li>
<li><code>Fold r a</code>
<ul>
<li>Consumes a list of <code>r</code></li>
<li>Produces an <code>a</code> as a result</li>
</ul></li>
</ul>
<p>It seems to “flip” the idea of “list vs. list consumer”, and <em>also</em> the idea of “tupled vs. producing”.</p>
<p>In addition, lists seem to be at the heart of how to create and consume a <code>Fold r</code>.</p>
<p><code>fold</code> can be thought of as the fundamental way to <em>consuming</em> a <code>Fold r</code>. This makes the adjunction against <code>EnvList r</code> make sense: what good is the <em>ability</em> to fold … if there is nothing <em>to fold</em>? <code>EnvList r</code> (a list of <code>[r]</code>) is intimately related to <code>Fold r</code>: they are the yin and yang, peanut butter and jelly, night and day. Their fates are intertwined from their very inception. You cannot have one without the other.</p>
<p>In addition, <code>F.foldMap</code> is arguably the fundamental way to <em>construct</em> a <code>Fold r</code>. A <code>Fold r</code> is, fundamentally, a list processor — which is what <code>EnvList r a -&gt; b</code> literally is (an <code>[r] -&gt; b</code>). <code>Fold r</code> and <code>EnvList r</code> — <a href="https://starwars.fandom.com/wiki/Dyad_in_the_Force">dyads in the force</a>. Or, well…I guess literally monads, since <a href="http://www.stephendiehl.com/posts/adjunctions.html">all adjunctions give rise to monads</a>…and comonads too.</p>
<p>The fact that <code>EnvList r</code> and <code>Fold r</code> form an adjunction together formalizes the fact that they are conceptually “opposite” concepts, and also that they are bound together by destiny in a close and fundamental way.</p>
<h2 id="investigations">Investigations</h2>
<p>Let’s take a look at some of the useful helper functions that an instance of <code>Adjunction</code> gives us for <code>Fold r</code>. For all of these, I’m going to write them first as <code>EnvList r a</code>, and then also as <code>([r], a)</code>, to help make things clearer.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="ot">unit ::</span> a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r (<span class="dt">EnvList</span> r a)</span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="ot">unit ::</span> a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r ([r], a)</span>
<span id="cb14-3"><a href="#cb14-3"></a></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="ot">counit ::</span> <span class="dt">EnvList</span> r (<span class="dt">Fold</span> r a) <span class="ot">-&gt;</span> a</span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="ot">counit ::</span> [r] <span class="ot">-&gt;</span> <span class="dt">Fold</span> r a <span class="ot">-&gt;</span> a</span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="ot">leftAdjunct ::</span> (<span class="dt">EnvList</span> r a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b)</span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="ot">leftAdjunct ::</span> ([r] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b   ) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b)</span>
<span id="cb14-9"><a href="#cb14-9"></a></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="ot">rightAdjunct ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b) <span class="ot">-&gt;</span> (<span class="dt">EnvList</span> r a <span class="ot">-&gt;</span> b)</span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="ot">rightAdjunct ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b) <span class="ot">-&gt;</span> ([r] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b   )</span>
<span id="cb14-12"><a href="#cb14-12"></a></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="ot">tabulateAdjunction ::</span> (<span class="dt">EnvList</span> r () <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span>
<span id="cb14-14"><a href="#cb14-14"></a><span class="ot">tabulateAdjunction ::</span> ([r] <span class="ot">-&gt;</span> b)          <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span>
<span id="cb14-15"><a href="#cb14-15"></a></span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="ot">indexAdjunction ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> <span class="dt">EnvList</span> r a <span class="ot">-&gt;</span> b</span>
<span id="cb14-17"><a href="#cb14-17"></a><span class="ot">indexAdjunction ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> [r]         <span class="ot">-&gt;</span> b</span>
<span id="cb14-18"><a href="#cb14-18"></a></span>
<span id="cb14-19"><a href="#cb14-19"></a><span class="ot">zipR ::</span> <span class="dt">Fold</span> r a <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> <span class="dt">Fold</span> r (a, b)</span></code></pre></div>
<ol type="1">
<li><p><code>unit :: a -&gt; Fold r ([r], a)</code>, when we specialize <code>a ~ ()</code>, becomes:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">unit ::</span> <span class="dt">Fold</span> r [r]</span></code></pre></div>
<p>This means that <code>unit</code> for <code>Fold r</code> folds a list <code>[r]</code> into “itself”:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a>fold unit [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="pp">#   =&gt; [1,2,3]</span></span></code></pre></div></li>
<li><p><code>counit :: [r] -&gt; Fold r a -&gt; a</code> is essentially just <code>fold</code>. Neat!</p></li>
<li><p><code>leftAdjunct :: ([r] -&gt; a -&gt; b) -&gt; (a -&gt; Fold r b)</code> … if we write it as <code>leftAdjunct :: a -&gt; (a -&gt; [r] -&gt; b) -&gt; Fold r b</code>, and feed the <code>a</code> into the first function, we get:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="ot">leftAdjunct&#39; ::</span> ([r] <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fold</span> r b</span></code></pre></div>
<p>which is just <code>tabulateAdjunction</code>, or <code>F.foldMap (:[])</code>! It encodes our list processor <code>[r] -&gt; b</code> into a <code>Fold r b.</code></p></li>
<li><p><code>rightAdjunct :: (a -&gt; Fold r b) -&gt; ([r] -&gt; a -&gt; b)</code> – if we again rewrite as <code>rightAdjunct :: a -&gt; (a -&gt; Fold r b) -&gt; [r] -&gt; b</code>, and again feed the <code>a</code> into the first function, becomes:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="ot">rightAdjunct&#39; ::</span> <span class="dt">Fold</span> r b <span class="ot">-&gt;</span> [r] <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>Which is just <code>fold</code>, or <code>counit</code>!</p>
<p>Note that <code>leftAdjunct</code> and <code>rightAdjunct</code> aren’t always this cleanly rearranged into <code>tabulate</code> or <code>counit</code> etc. – in this case it’s just because of how <code>EnvList r a</code> is shaped.</p></li>
<li><p><code>tabulateAdjunction</code> and <code>indexAdjunction</code> we went over earlier, seeing them as <code>F.foldMap (:[])</code> and <code>fold</code></p></li>
<li><p><code>zipR :: Fold r a -&gt; Fold r b -&gt; Fold r (a, b)</code> takes two <code>Fold r</code>s and combines them into a single fold. This is exactly the “combining fold” behavior that makes <code>Fold</code>s so useful! The implementation of <code>zipR</code> is less efficient than the implementation of <code>&lt;*&gt;</code>/<code>liftA2</code> for <code>Fold r</code>, but knowing that <code>zipR</code> exists means that we know <code>Fold r</code>s can be combined.</p></li>
</ol></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Advent of Code&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+advent-of-code.html" class="tag-a-series" title="+Advent of Code"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@math.html" class="tag-a-category">@MATH</a></li><li><a href="https://blog.jle.im/entries/series/+advent-of-code.html" class="tag-a-series">+Advent of Code</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/foldl-adjunction.html';
    this.page.identifier = 'advent-shuffle';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>