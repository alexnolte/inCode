<!DOCTYPE HTML>
<html><head><title>Introduction to Singletons (Part 1) · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Real dependent types are coming to Haskell soon! Until then, we have the great singletons library :) If you’ve ever run into dependently typed programming in Haskell, you’ve probably encountered mentions of singletons (and the singletons library). This series of articles will be my attempt at giving you the story of the library, the problems it solves, the power that it gives to you, and how you can integrate it into your code today! (Also, after my previous April Fools post, people have been asking me for an actual non-joke singletons post) This post (Part 1) will go over first using the singleton pattern for reflection, then introducing how the singletons library helps us. Part 2 will discuss using the library for reification, to get types that depend on values at runtime. Part 3 will go into the basics of promoting functions values to become functions on types in a usable, and Part 4 will go deeper into the lifting of functions, using singleton’s defunctionalization scheme to utilize the higher-order functions we love at the type level. Part 3 will go into the basics singleton’s I definitely am writing this post with the hope that it will be obsolete in a year or two. When dependent types come to Haskell, singletons will be nothing more than a painful historical note. But for now, singletons might be the best way to get your foot into the door and experience the thrill and benefits of dependently typed programming today!"><meta property="og:type" content="article"><meta property="og:title" content="Introduction to Singletons (Part 1)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introduction-to-singletons-1.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introduction-to-singletons-1.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Introduction to Singletons (Part 1)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2017-12-22T10:42:07Z" pubdate="" class="pubdate">Friday December 22, 2017</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/singletons-1.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introduction-to-singletons-1.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introduction-to-singletons-1.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category" title="Technical tutorials/walkthroughs on specific programming processes and problems
that I&#39;ve struggled through in the past.">Tutorials</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Real dependent types are coming to Haskell soon! Until then, we have the great <em><a href="http://hackage.haskell.org/package/singletons">singletons</a></em> library :)</p>
<p>If you’ve ever run into dependently typed programming in Haskell, you’ve probably encountered mentions of singletons (and the <em>singletons</em> library). This series of articles will be my attempt at giving you the story of the library, the problems it solves, the power that it gives to you, and how you can integrate it into your code today!<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> (Also, after <a href="https://blog.jle.im/entry/verified-instances-in-haskell.html">my previous April Fools post</a>, people have been asking me for an actual non-joke singletons post)</p>
<p>This post (Part 1) will go over first using the singleton pattern for <em>reflection</em>, then introducing how the singletons library helps us. Part 2 will discuss using the library for <em>reification</em>, to get types that depend on values at runtime. Part 3 will go into the basics of promoting <em>functions</em> values to become functions on types in a usable, and Part 4 will go deeper into the lifting of functions, using singleton’s <em>defunctionalization</em> scheme to utilize the higher-order functions we love at the type level. Part 3 will go into the basics singleton’s</p>
<p>I definitely am writing this post with the hope that it will be obsolete in a year or two. When dependent types come to Haskell, singletons will be nothing more than a painful historical note. But for now, singletons might be the best way to get your foot into the door and experience the thrill and benefits of dependently typed programming <em>today</em>!</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>These posts will assume no knowledge of dependent types, and, for now, only basic to intermediate Haskell knowledge (Types, kinds, typeclasses, data types, functions). The material in this post <em>overlaps</em> with my <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html">dependently typed neural networks</a> series, but the concepts are introduced in different contexts.</p>
<p>All code is built on <em>GHC 8.6.1</em> and with the <em><a href="https://www.stackage.org/nightly-2018-09-29">nightly-2018-09-29</a></em> snapshot (so, <em>singletons-2.5</em>). However, unless noted, all of the code should still work with <em>GHC 8.4</em> and <em>singletons-2.4</em>.</p>
<p>The content in the first section of this post, describing the singleton design pattern, uses the following extensions:</p>
<ul>
<li>DataKinds</li>
<li>GADTs</li>
<li>KindSignatures</li>
<li>RankNTypes</li>
</ul>
<p>With some optional “convenience extensions”</p>
<ul>
<li>LambdaCase</li>
<li>TypeApplications</li>
</ul>
<p>And the second section, introducing the <em>singletons</em> library itself, uses, additionally:</p>
<ul>
<li>TemplateHaskell</li>
<li>TypeFamilies</li>
</ul>
<p>These extension will be explained when they are used or become relevant.</p>
<h2 id="the-phantom-of-the-types">The Phantom of the Types</h2>
<p><em>(The code for this pre-singletons section is available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs">on github</a>)</em></p>
<p>Let’s start with a very common Haskell trick that most learn early in their Haskelling journey: the <a href="https://wiki.haskell.org/Phantom_type">phantom type</a>.</p>
<p>Phantom types in Haskell are a very simple way to add a layer of “type safety” for your types and DSL’s. It helps you restrict what values functions can take and encode pre- and post-conditions directly into your types.</p>
<p>For example, in</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo</span> a <span class="fu">=</span> <span class="dt">MkFoo</span></a></code></pre></div>
<p>The <code>a</code> parameter is <em>phantom</em>, because nothing of type <code>a</code> in the data type…it just exists as a dummy parameter for the <code>Foo</code> type. We can use <code>MkFoo</code> without ever requiring something of type <code>a</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">MkFoo</span><span class="ot"> ::</span> <span class="dt">Foo</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="dt">Foo</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">MkFoo</span><span class="ot"> ::</span> <span class="dt">Foo</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="dt">Foo</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">MkFoo</span><span class="ot"> ::</span> <span class="dt">Foo</span> <span class="dt">Either</span>      <span class="co">-- requires -XPolyKinds where &#39;Foo&#39; is defined</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="dt">Foo</span> <span class="dt">Either</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">MkFoo</span><span class="ot"> ::</span> <span class="dt">Foo</span> <span class="dt">Monad</span>       <span class="co">-- requires -XConstraintKinds</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="dt">Foo</span> <span class="dt">Monad</span></a></code></pre></div>
<p>One use case of phantom type parameters is to prohibit certain functions on different types of values and let you be more descriptive with how your functions work together (like in <a href="https://ren.zone/articles/safe-money">safe-money</a>). One “hello world” use case of phantom type parameters is to tag data as “sanitized” or “unsanitized” (<code>UserString 'Sanitized</code> type vs. <code>UserString 'Unsanitized</code>) or paths as absolute or relative (<code>Path 'Absolute</code> vs. <code>Path 'Relative</code>). For a simple example, let’s check out a simple DSL for a type-safe door:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L11-L15</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">data</span> <span class="dt">DoorState</span> <span class="fu">=</span> <span class="dt">Opened</span> <span class="fu">|</span> <span class="dt">Closed</span> <span class="fu">|</span> <span class="dt">Locked</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">data</span> <span class="dt">Door</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>) <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> {<span class="ot"> doorMaterial ::</span> <span class="dt">String</span> }</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">                  <span class="co">-- requires -XDataKinds</span></a></code></pre></div>
<p>A couple things going on here:</p>
<ol type="1">
<li><p>Our type we are going to be playing with is a <code>Door</code>, which contains a single field <code>doorMaterial</code> describing, say, the material that the door is made out of. (<code>UnsafeMkDoor &quot;Oak&quot;</code> would be an oak door)</p></li>
<li><p>We’re using the <code>DataKinds</code> extension to create both the <em>type</em> <code>DoorState</code> as well as the <em>kind</em> <code>DoorState</code>.</p>
<p>Normally, <code>data DoorState = Opened | Closed | Locked</code> in Haskell defines the type <code>DoorState</code> and the value constructors <code>Opened</code>, <code>Closed</code>, and <code>Locked</code>.</p>
<p>However, with <code>DataKinds</code>, that statement also defines a new <em>kind</em> <code>DoorState</code>, with <em>type</em> constructors <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code>. (note the <code>'</code> ticks!)<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>k &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dt">DoorState</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>k &#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dt">DoorState</span></a></code></pre></div></li>
</ol>
<ol start="3" type="1">
<li><p>We’re defining the <code>Door</code> type with a <em>phantom parameter</em> <code>s</code>. It’s a phantom type because we don’t actually have any <em>values</em> of type <code>s</code> in our data type<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> …the <code>s</code> is only just there as a dummy parameter for the type.</p>
<p>We can use <code>UnsafeMkDoor</code> without ever using anything of type <code>s</code>. In reality, a real <code>Door</code> type would be a bit more complicated (and the direct <code>UnsafeMkDoor</code> constructor would be hidden).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">UnsafeMkDoor</span> <span class="st">&quot;Birch&quot;</span><span class="ot"> ::</span> <span class="dt">Door</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="dt">Door</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">UnsafeMkDoor</span> <span class="st">&quot;Iron&quot;</span><span class="ot"> ::</span> <span class="dt">Door</span> &#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dt">Door</span> &#39;<span class="dt">Locked</span></a></code></pre></div>
<p>We can also use the <em>TypeApplications</em> extension to write this in a bit more convenient way –</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Opened</span> <span class="st">&quot;Birch&quot;</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="dt">Door</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Locked</span> <span class="st">&quot;Iron&quot;</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="dt">Door</span> &#39;<span class="dt">Locked</span></a></code></pre></div></li>
</ol>
<p>Alternatively, we can define <code>Door</code> using <a href="https://en.wikibooks.org/wiki/Haskell/GADT#Syntax"><em>GADT</em> syntax</a> (which requires the <code>GADTs</code> extension)<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Door</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="dt">UnsafeMkDoor</span><span class="ot"> ::</span> {<span class="ot"> doorMaterial ::</span> <span class="dt">String</span> } <span class="ot">-&gt;</span> <span class="dt">Door</span> s</a></code></pre></div>
<p>This is defining the exact same type in the alternate “GADT syntax” style of data type declaration – here, we define types by giving the type of its constructors, <code>UnsafeMkDoor :: String -&gt; Door s</code>.</p>
<p><code>Door</code> here is an <strong>indexed data type</strong>, which is sometimes called a “type family” in the dependently typed programming world (which is not to be confused with type families in <em>GHC Haskell</em>, <code>-XTypeFamilies</code>, which is a language mechanism that is related but definitely not the same).</p>
<h3 id="phantoms-in-action">Phantoms in Action</h3>
<p>At first, this seems a bit silly. Why even have the extra type parameter if you don’t ever use it?</p>
<p>Well, right off the bat, we can write functions that expect only a certain type of <code>Door</code>, and return a specific type of <code>Door</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L17-L18</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ot">closeDoor ::</span> <span class="dt">Door</span> &#39;<span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">closeDoor (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> m</a></code></pre></div>
<p>So, the <code>closeDoor</code> function will <em>only</em> take a <code>Door 'Opened</code> (an opened door). And it will return a <code>Door 'Closed</code> (a closed door).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="kw">let</span> myDoor <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Opened</span> <span class="st">&quot;Spruce&quot;</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t myDoor</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="dt">Door</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t closeDoor myDoor</a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="dt">Door</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">ghci<span class="fu">&gt;</span> <span class="kw">let</span> yourDoor <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Closed</span> <span class="st">&quot;Acacia&quot;</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t closeDoor yourDoor</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span>  <span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span></a></code></pre></div>
<p>You can think of this as a nice way of catching <em>logic errors</em> at compile-time. If your door type did not have its status in the type, the <code>closeDoor</code> could have been given a closed or locked door, and you’d have to handle and reject it at <em>runtime</em>.</p>
<p>By adding the state of the door into its type, we can encode our pre-conditions and post-conditions directly into the type. And any opportunity to move runtime errors to compile-time errors should be celebrated with a party!</p>
<p>This would also stop you from doing silly things like closing a door twice in a row:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t closeDoor <span class="fu">.</span> closeDoor</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span>  <span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span>  <span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span></a></code></pre></div>
<p>Do you see why?</p>
<p>With a couple of state transitions, we can write compositions that are type-checked to all be legal:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L20-L24</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="ot">lockDoor ::</span> <span class="dt">Door</span> &#39;<span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">lockDoor (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> m</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="ot">openDoor ::</span> <span class="dt">Door</span> &#39;<span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">openDoor (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> m</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t closeDoor <span class="fu">.</span> openDoor</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="dt">Door</span> &#39;<span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t lockDoor <span class="fu">.</span> closeDoor <span class="fu">.</span> openDoor</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="dt">Door</span> &#39;<span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t lockDoor <span class="fu">.</span> openDoor</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span>  <span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span>  <span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span></a></code></pre></div>
<p>Because of the type of <code>lockDoor</code>, you <em>cannot</em> lock an opened door! Don’t even try! You’d have to close it first.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="kw">let</span> myDoor <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Opened</span> <span class="st">&quot;Spruce&quot;</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t myDoor</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="dt">Door</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t lockDoor</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="dt">Door</span> &#39;<span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t lockDoor myDoor</a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span>  <span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span>  <span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t closeDoor myDoor</a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="dt">Door</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t lockDoor (closeDoor myDoor)</a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="dt">Door</span> &#39;<span class="dt">Locked</span></a></code></pre></div>
<p><code>lockDoor</code> expects a <code>Door 'Closed</code>, so if you give it a <code>Door 'Opened</code>, that’s a static compile-time type error. But, <code>closeDoor</code> takes a <code>Door 'Opened</code> and returns a <code>Door 'Closed</code> – so <em>that</em> is something that you can call <code>lockDoor</code> with!</p>
<h3 id="the-phantom-menace">The Phantom Menace</h3>
<p>However, in standard Haskell, we quickly run into some practical problems if we program with phantom types this way.</p>
<p>For example, how could we write a function to get the state of a door?</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">doorStatus ::</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">DoorState</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">doorStatus _ <span class="fu">=</span> <span class="co">-- ?</span></a></code></pre></div>
<p>(It can be done with an ad-hoc typeclass, but it’s not simple, and it’s prone to implementation bugs)</p>
<p>And, perhaps even more important, how can you create a <code>Door</code> with a given state that isn’t known until runtime? If we know the type of our doors at compile-time, we can just explicitly write <code>UnsafeMkDoor &quot;Iron&quot; :: Door 'Opened</code> or <code>UnsafeMkDoor @'Opened &quot;Iron&quot;</code>. But what if we wanted to make a door based on a <code>DoorState</code> <em>value</em>? Something we might not get until runtime?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">mkDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">mkDoor <span class="dt">Opened</span> <span class="fu">=</span> <span class="co">-- ?</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">mkDoor <span class="dt">Closed</span> <span class="fu">=</span> <span class="co">-- ?</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">mkDoor <span class="dt">Locked</span> <span class="fu">=</span> <span class="co">-- ?</span></a></code></pre></div>
<p>Ah hah, you say. That’s easy!</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">mkDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">mkDoor <span class="dt">Opened</span> <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">mkDoor <span class="dt">Closed</span> <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">mkDoor <span class="dt">Locked</span> <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span></a></code></pre></div>
<p>Unfortunately, that’s not how types work in Haskell. Remember that for a polymorphic type <code>forall s. DoorState -&gt; String -&gt; Door s</code>, the <em>caller</em> picks the type variable.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t mkDoor <span class="dt">Opened</span> <span class="st">&quot;Acacia&quot;</span><span class="ot"> ::</span> <span class="dt">Door</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="dt">Door</span> &#39;<span class="dt">Closed</span></a></code></pre></div>
<p>Oops!</p>
<h3 id="the-fundamental-issue-in-haskell">The Fundamental Issue in Haskell</h3>
<p>We’ve hit upon a fundamental issue in Haskell’s type system: <strong>type erasure</strong>. In Haskell, types only exist <em>at compile-time</em>, for help with type-checking. They are completely erased at runtime.</p>
<p>This is usually what we want. It’s great for performance, and you can bypass things like the ad-hoc runtime type checking that you have to deal with in dynamic languages like python.</p>
<p>But in our case, it makes functions like <code>doorState</code> fundamentally impossible. Or, does it?</p>
<h2 id="the-singleton-pattern">The Singleton Pattern</h2>
<p>A singleton in Haskell is a type (of kind <code>Type</code> – that is, <code>*</code>) that has exactly one inhabitant. In practice (and when talking about the design pattern), it refers to a parameterized type that, for each pick of parameter, gives a type with exactly one inhabitant. It is written so that pattern matching on the <em>constructor</em> of that value reveals the unique type parameter.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L26-L29</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="kw">data</span> <span class="dt">SingDS</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">SingDS</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    <span class="dt">SClosed</span><span class="ot"> ::</span> <span class="dt">SingDS</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">SingDS</span> &#39;<span class="dt">Locked</span></a></code></pre></div>
<p>Here we’re using <em>GADT syntax</em> again (but to make an actual GADT). (Also note that <code>Type</code> is a synonym for the <code>*</code> kind, exported from the <em>Data.Kind</em> module) So, if we use <code>SOpened</code>, we will get a <code>SingDS 'Opened</code>. And if we have a <code>SingDS 'Opened</code>, we know that it was constructed using <code>SOpened</code>. Essentially, this gives us three values:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">SingDS</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="dt">SClosed</span><span class="ot"> ::</span> <span class="dt">SingDS</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">SingDS</span> &#39;<span class="dt">Locked</span></a></code></pre></div>
<h3 id="the-power-of-the-pattern-match">The Power of the Pattern Match</h3>
<p>The power of singletons is that we can now <em>pattern match</em> on types, essentially.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L17-L35</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="ot">closeDoor ::</span> <span class="dt">Door</span> &#39;<span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5"><span class="ot">lockDoor ::</span> <span class="dt">Door</span> &#39;<span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="ot">lockAnyDoor ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">lockAnyDoor sng door <span class="fu">=</span> <span class="kw">case</span> sng <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> lockDoor (closeDoor door) <span class="co">-- in this branch, s is &#39;Opened</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10">    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> lockDoor door             <span class="co">-- in this branch, s is &#39;Closed</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> door                      <span class="co">-- in this branch, s is &#39;Locked</span></a></code></pre></div>
<p><code>lockAnyDoor</code> is a function that can take a door of any state (a <code>Door s</code> of any <code>s</code>) and <em>lock</em> it using a composition of <code>lockDoor</code> or <code>closeDoor</code> as necessary.</p>
<p>If we have <code>lockAnyDoor</code> take a <code>SingDS s</code> as its input (and, importantly, make sure that the <code>s</code> in <code>SingDS s</code> is the same <code>s</code> in the <code>Door s</code>), we can <em>pattern match</em> on the <code>SingDS s</code> to <em>reveal</em> what <code>s</code> is, to the type checker. This is known as a <strong>dependent pattern match</strong>.</p>
<ul>
<li><p>If <code>SingDS s</code>’s pattern match goes down the <code>SOpened -&gt;</code> case, then we <em>know</em> that <code>s ~ 'Opened</code><a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>. We know that <code>s</code> must be <code>'Opened</code>, because <code>SOpened :: SingDS 'Opened</code>, so there really isn’t anything else the <code>s</code> in <code>SingDS s</code> could be!</p>
<p>So, if we know that <code>s ~ 'Opened</code>, that means that the <code>Door s</code> is <code>Door 'Opened</code>. So because <code>door :: Door' Opened</code>, we have to <code>closeDoor</code> it to get a <code>Door' Closed</code>, and then <code>lockDoor</code> it to get a <code>Door 'Locked</code></p>
<p>We say that <code>SOpened</code> is a <em>runtime witness</em> to <code>s</code> being <code>'Opened</code>.</p></li>
<li><p>Same for the <code>SClosed -&gt;</code> branch – since <code>SClosed :: SingDS 'Closed</code>, then <code>s ~ 'Closed</code>, so our <code>Door s</code> must be a <code>Door 'Closed</code>. This allows us to simply take our <code>door :: Door 'Closed</code> and use <code>lockDoor</code> to get a <code>Door 'Locked</code></p></li>
<li><p>For the <code>SLocked -&gt;</code> branch, <code>SLocked :: SingDS 'Locked</code>, so <code>s ~ 'Locked</code>, so our <code>Door s</code> is a <code>Door 'Locked</code>. Our door is “already” locked, so we can just use the <code>door :: Door 'Locked</code> that we got!</p></li>
</ul>
<p>Essentially, our singletons give us <em>runtime values</em> that can be used as <em>witnesses</em> for types and type variables. These values exist at runtime, so they “bypass” type erasure. Types themselves are directly erased, but we can hold on to them using these runtime tokens when we need them.</p>
<p>Note that we can also write <code>lockAnyDoor</code> using the <em>LambdaCase</em> extension syntactic sugar, which I think offers a lot of extra insight:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">lockAnyDoor ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> (<span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Locked</span>)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">lockAnyDoor <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> lockDoor <span class="fu">.</span> closeDoor  <span class="co">-- in this branch, s is &#39;Opened</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> lockDoor              <span class="co">-- in this branch, s is &#39;Closed</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> id                    <span class="co">-- in this branch, s is &#39;Locked</span></a></code></pre></div>
<p>Here, we can see <code>lockAnyDoor sng</code> as a partially applied function that returns a <code>Door s -&gt; Door 'Locked</code> For any <code>SingDS s</code> you give to <code>lockAnyDoor</code>, <code>lockAnyDoor</code> returns a “locker function” (<code>Door s -&gt; Door 'Locked</code>) that is custom-made for your <code>SingDS</code>:</p>
<ul>
<li><p><code>lockAnyDoor SOpened</code> will return a <code>Door 'Opened -&gt; Door 'Locked</code>. Here, it has to give <code>lockDoor . closeDoor :: Door 'Opened -&gt; Door 'Locked</code>.</p></li>
<li><p><code>lockAnyDoor SClosed</code> will return a <code>Door 'Closed -&gt; Door 'Locked</code> – namely <code>lockDoor :: Door 'Closed -&gt; Door 'Locked</code>.</p></li>
<li><p><code>lockAnyDoor SLocked</code> will return a <code>Door 'Locked -&gt; Door 'Locked</code>, which will just be <code>id :: Door 'Locked -&gt; Door 'Locked</code></p></li>
</ul>
<p>Note that all of these functions will <em>only</em> typecheck under the branch they fit in. If we gave <code>lockDoor</code> for the <code>SOpened</code> branch, or <code>id</code> for the <code>SClosed</code> branch, that’ll be a compile-time error!</p>
<h4 id="reflection">Reflection</h4>
<p>Writing <code>doorStatus</code> is now pretty simple –</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">doorStatus ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">DoorState</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">doorStatus <span class="dt">SOpened</span> _ <span class="fu">=</span> <span class="dt">Opened</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">doorStatus <span class="dt">SClosed</span> _ <span class="fu">=</span> <span class="dt">Closed</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">doorStatus <span class="dt">SLocked</span> _ <span class="fu">=</span> <span class="dt">Locked</span></a></code></pre></div>
<p>The benefit of the singleton again relies on the fact that the <code>s</code> in <code>SingDS s</code> is the same as the <code>s</code> in <code>Door s</code>, so if the user gives a <code>SingDS s</code>, it <em>has</em> to match the <code>s</code> in the <code>Door s</code> they give.</p>
<p>Since we don’t even care about the <code>door</code>, we could also just write:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L37-L40</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="ot">fromSingDS ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">DoorState</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">fromSingDS <span class="dt">SOpened</span> <span class="fu">=</span> <span class="dt">Opened</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">fromSingDS <span class="dt">SClosed</span> <span class="fu">=</span> <span class="dt">Closed</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">fromSingDS <span class="dt">SLocked</span> <span class="fu">=</span> <span class="dt">Locked</span></a></code></pre></div>
<p>Which we can use to write a nicer <code>doorStatus</code></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L42-L43</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="ot">doorStatus ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">DoorState</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">doorStatus s _ <span class="fu">=</span> fromSingDS s</a></code></pre></div>
<p>This process – of turning a type variable (like <code>s</code>) into a dynamic runtime value is known as <strong>reflection</strong>. We move a value from the <em>type level</em> to the <em>term level</em>.</p>
<h3 id="recovering-implicit-passing">Recovering Implicit Passing</h3>
<p>One downside is that we are required to manually pass in our witness. Wouldn’t it be nice if we could have it be passed implicitly? We can actually leverage typeclasses to give us this ability:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L45-L53</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"></a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="kw">class</span> <span class="dt">SingDSI</span> s <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="ot">    singDS ::</span> <span class="dt">SingDS</span> s</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">SingDSI</span> &#39;<span class="dt">Opened</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">    singDS <span class="fu">=</span> <span class="dt">SOpened</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">SingDSI</span> &#39;<span class="dt">Closed</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9">    singDS <span class="fu">=</span> <span class="dt">SClosed</span></a>
<a class="sourceLine" id="cb25-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">SingDSI</span> &#39;<span class="dt">Locked</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    singDS <span class="fu">=</span> <span class="dt">SLocked</span></a></code></pre></div>
<p>(Note that <em>it’s impossible</em> to write our <code>SingDSI</code> instances improperly! GHC checks to make sure that this is <em>correct</em>)</p>
<p>And so now we can do:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L55-L59</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="ot">lockAnyDoor_ ::</span> <span class="dt">SingDSI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4">lockAnyDoor_ <span class="fu">=</span> lockAnyDoor singDS</a>
<a class="sourceLine" id="cb26-5" data-line-number="5"></a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="ot">doorStatus_ ::</span> <span class="dt">SingDSI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">DoorState</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">doorStatus_ <span class="fu">=</span> doorStatus singDS</a></code></pre></div>
<p>Here, type inference will tell GHC that you want <code>singDS :: SingDS s</code>, and it will pull out the proper singleton for the door you want to check!</p>
<p>Now, we can call <code>lockAnyDoor_</code> <em>without passing in</em> a singleton, explicitly!</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="kw">let</span> myDoor <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Opened</span> <span class="st">&quot;Birch&quot;</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t lockAnyDoor <span class="dt">SOpened</span> myDoor <span class="co">-- our original method!</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="dt">Door</span> &#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t lockAnyDoor singDS myDoor  <span class="co">-- the power of type inference!</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="dt">Door</span> &#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t lockAnyDoor_ myDoor        <span class="co">-- no explicit singleton being passed!</span></a>
<a class="sourceLine" id="cb27-7" data-line-number="7"><span class="dt">Door</span> &#39;<span class="dt">Locked</span></a></code></pre></div>
<h4 id="the-same-power">The Same Power</h4>
<p>In Haskell, a constraint <code>SingDSI s =&gt;</code> is essentially the same as passing in <code>SingDS s</code> explicitly. Either way, you are passing in a runtime witness that your function can use. You can think of <code>SingDSI s =&gt;</code> as passing it in <em>implicitly</em>, and <code>SingDS s -&gt;</code> as passing it in <em>explicitly</em>.</p>
<p>So, it’s important to remember that <code>lockAnyDoor</code> and <code>lockAnyDoor_</code> are the “same function”, with the same power. They are just written in different styles – <code>lockAnyDoor</code> is written in explicit style, and <code>lockAnyDoor_</code> is written in implicit style.</p>
<h4 id="going-backwards">Going backwards</h4>
<p>Going from <code>SingDSI s =&gt;</code> to <code>SingDS s -&gt;</code> (implicit to explicit) is very easy – just use <code>singDS</code> to get a <code>SingDS s</code> if you have a <code>SingDSI s</code> constraint available. This is what we did for <code>lockAnyDoor_</code> and <code>doorStatus_</code>.</p>
<p>Going from <code>SingDS s -&gt;</code> to <code>SingDSI s =&gt;</code> (explicit to implicit) in Haskell is actually a little trickier. The typical way to do this is with a CPS-like utility function:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L61-L65</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="ot">withSingDSI ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> (<span class="dt">SingDSI</span> s <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">withSingDSI sng x <span class="fu">=</span> <span class="kw">case</span> sng <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-5" data-line-number="5">    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> x</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> x</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> x</a></code></pre></div>
<p><code>withSingDSI</code> takes a <code>SingDS s</code>, and a value (of type <code>r</code>) that requires a <code>SingDSI s</code> instance to be created. And it creates that value for you!</p>
<p>To use <code>x</code>, you must have a <code>SingDSI s</code> instance available. This all works because in each branch, <code>s</code> is now a <em>specific</em>, monomorphic, “concrete” <code>s</code>, and GHC knows that such an instance exists for every branch.</p>
<ul>
<li>In the <code>SOpened</code> branch, <code>s ~ 'Opened</code>. We explicitly wrote an instance of <code>SingDSI</code> for <code>'Opened</code>, so GHC <em>knows</em> that there is a <code>SingDSI 'Opened</code> instance in existence, allowing you to use/create <code>x</code>.</li>
<li>In the <code>SClosed</code> branch, <code>s ~ 'Closed</code>, so GHC knows that there is a <code>SingDSI 'Closed</code> instance (because we wrote one explicitly!), and gives <em>that</em> to you – and so you are allowed to use/create <code>x</code>.</li>
<li>In the <code>SLocked</code> branch, <code>s ~ 'Locked</code>, and because we wrote a <code>SingDSI 'Locked</code> explicitly, we <em>know</em> that a <code>SingDSI s</code> instance is available, so we can use/create <code>x</code>.</li>
</ul>
<p>Now, we can run our implicit functions (like <code>lockAnyDoor_</code>) by giving them explicit inputs:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L67-L68</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="ot">lockAnyDoor__ ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">lockAnyDoor__ s d <span class="fu">=</span> withSingDSI s (lockAnyDoor_ d)</a></code></pre></div>
<p>And the cycle begins anew.</p>
<p>One interesting thing to point out – note that the type of <code>withSingDSI</code> is very similar to the type of another common combinator:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">withSingDSI ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> (<span class="dt">SingDSI</span> s <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">flip<span class="ot">  ($)   ::</span>        a <span class="ot">-&gt;</span> (        a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</a></code></pre></div>
<p>Which is a bit of a testament to what we said earlier about how a <code>SingDSI s =&gt; ..)</code> is the same as <code>SingDS s -&gt; ..</code>. <code>flip ($)</code> takes a value and a function and applies the function to that value. <code>withSingDSI</code> takes a value and “something like a function” and applies the “something like a function” to that value.</p>
<h3 id="fun-with-witnesses">Fun with Witnesses</h3>
<p>We can write a nice version of <code>mkDoor</code> using singletons:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L70-L71</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"></a>
<a class="sourceLine" id="cb31-3" data-line-number="3"><span class="ot">mkDoor ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">mkDoor _ <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span></a></code></pre></div>
<p>We take advantage of the fact that <code>SingDS s</code> “locks in” the <code>s</code> type variable for <code>Door s</code>. We can call it now with values of <code>SingDS</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t mkDoor <span class="dt">SOpened</span> <span class="st">&quot;Oak&quot;</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="dt">Door</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t mkDoor <span class="dt">SLocked</span> <span class="st">&quot;Spruce&quot;</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4"><span class="dt">Door</span> &#39;<span class="dt">Locked</span></a></code></pre></div>
<p>Now we can’t do something silly like pass in <code>SLocked</code> to get a <code>Door 'Opened</code>.</p>
<h2 id="the-singletons-library">The Singletons Library</h2>
<p><em>(The code for this post-singletons section is available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs">on github</a>)</em></p>
<p>Now that we understand some of the benefits of singletons as they relate to phantom types, we can appreciate what the singletons <em>library</em> has to offer: a fully unified, coherent system for working with singletons of almost <em>all</em> Haskell types!</p>
<p>First, there’s Template Haskell for generating our singletons given our type:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">data</span> <span class="dt">DoorState</span> <span class="fu">=</span> <span class="dt">Opened</span> <span class="fu">|</span> <span class="dt">Closed</span> <span class="fu">|</span> <span class="dt">Locked</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">genSingletons [&#39;&#39;<span class="dt">DoorState</span>]</a>
<a class="sourceLine" id="cb33-5" data-line-number="5"></a>
<a class="sourceLine" id="cb33-6" data-line-number="6"><span class="co">-- or</span></a>
<a class="sourceLine" id="cb33-7" data-line-number="7"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs#L21-L24</span></a>
<a class="sourceLine" id="cb33-8" data-line-number="8"></a>
<a class="sourceLine" id="cb33-9" data-line-number="9"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb33-10" data-line-number="10">  data DoorState = Opened | Closed | Locked</a>
<a class="sourceLine" id="cb33-11" data-line-number="11">    deriving (Show, Eq)</a>
<a class="sourceLine" id="cb33-12" data-line-number="12">  |])</a></code></pre></div>
<p>This generates, for us:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="co">-- not the actual code, but essentially what happens</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Sing</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    <span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">Sing</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="dt">SClosed</span><span class="ot"> ::</span> <span class="dt">Sing</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    <span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">Sing</span> &#39;<span class="dt">Locked</span></a></code></pre></div>
<p><code>Sing</code> is a poly-kinded type constructor (a “data family”). <code>STrue :: Sing 'True</code> is the singleton for <code>'True</code>, <code>SJust SOpened :: Sing ('Just 'Opened)</code> is the singleton for <code>'Just 'Opened</code>, etc.</p>
<p>It also generates us instances for <code>SingI</code>, a poly-kinded typeclass:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">SingI</span> &#39;<span class="dt">Opened</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">    sing <span class="fu">=</span> <span class="dt">SOpened</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">SingI</span> &#39;<span class="dt">Closed</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4">    sing <span class="fu">=</span> <span class="dt">SClosed</span></a>
<a class="sourceLine" id="cb35-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">SingI</span> &#39;<span class="dt">Locked</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6">    sing <span class="fu">=</span> <span class="dt">SLocked</span></a></code></pre></div>
<p>Which is basically our <code>SingDSI</code> typeclass, except we have instances for singletons of all kinds! (heh) There’s a <code>SingI</code> instance for <code>'True</code>, a <code>SingI</code> instance for <code>10</code>, a <code>SingI</code> instance for <code>'Just 'Opened</code>, etc.:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1">ghci<span class="fu">&gt;</span><span class="ot"> sing ::</span> <span class="dt">Sing</span> &#39;<span class="dt">True</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="dt">STrue</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3">ghci<span class="fu">&gt;</span><span class="ot"> sing ::</span> <span class="dt">Sing</span> (&#39;<span class="dt">Just</span> &#39;<span class="dt">Opened</span>)</a>
<a class="sourceLine" id="cb36-4" data-line-number="4"><span class="dt">SJust</span> <span class="dt">SOpened</span></a></code></pre></div>
<p>We also have <code>withSingI</code>, which is equivalent to our <code>withSingDSI</code> function earlier.<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">withSingI ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> (forall r<span class="fu">.</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> r</a></code></pre></div>
<p>Note that if you have singletons for a kind <code>k</code>, you also have instances for kind <code>Maybe k</code>, as well. And also for <code>[k]</code>, even! The fact that we have a unified way of working with and manipulating singletons of so many different types is a major advantage of using the <em>singletons</em> library to manage your singletons instead of writing them yourself.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">SOpened</span> <span class="ot">`SCons`</span> <span class="dt">SClosed</span> <span class="ot">`SCons`</span> <span class="dt">SLocked</span> <span class="ot">`SCons`</span> <span class="dt">SNil</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="dt">Sing</span> &#39;[ &#39;<span class="dt">Opened</span>, &#39;<span class="dt">Closed</span>, &#39;<span class="dt">Locked</span> ]</a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="co">-- &#39;SCons is the singleton for `:` (cons),</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4"><span class="co">-- and &#39;SNil is the singleton for `[]` (nil)</span></a></code></pre></div>
<p>(Remember that, because of <code>DataKinds</code>, <code>Maybe</code> is a kind constructor, who has two type constructors, the type <code>'Nothing</code> and the type constructor <code>'Just :: k -&gt; Maybe k</code>)</p>
<p>Singletons for all kinds integrate together seamlessly, and you have mechanisms to generate them for your own type and roll it all into the system!</p>
<h3 id="extra-goodies">Extra Goodies</h3>
<p>In addition to generating singletons for our libraries, it gives us convenient functions for working with the different “manifestations” of our types.</p>
<p>Recall that <code>DoorState</code> has four different things associated with it now:</p>
<ol type="1">
<li>The <em>type</em> <code>DoorState</code>, whose value constructors are <code>Opened</code>, <code>Closed</code>, and <code>Locked</code>.</li>
<li>The <em>kind</em> <code>DoorState</code>, whose type constructors are <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code></li>
<li><p>The singletons for <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">Sing</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="dt">SClosed</span><span class="ot"> ::</span> <span class="dt">Sing</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3"><span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">Sing</span> &#39;<span class="dt">Locked</span></a></code></pre></div></li>
<li><p>The <code>SingI</code> instances for <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked'</code></p></li>
</ol>
<p>Kind of confusing, and in the future, when we have real dependent types, we can combine all of these manifestations into the <em>one</em> thing. But for now, we do have to deal with converting between them, and for that, <em>singletons</em> generates for us <code>fromSing :: Sing (s :: DoorState) -&gt; DoorState</code>. <code>fromSing</code> takes us from singletons to term-level values (<em>reflection</em>):</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1">ghci<span class="fu">&gt;</span> fromSing <span class="dt">SOpened</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="dt">Opened</span></a></code></pre></div>
<p>It does this by defining a type class (actually, a “kind class”), <code>SingKind</code>, associating each type to the corresponding datakinds-generated kind. The <code>SingKind</code> instance for <code>DoorState</code> links the <em>type</em> <code>DoorState</code> to the <em>kind</em> <code>DoorState</code>.</p>
<p>The library also defines a neat type synonym, <code>type SDoorState = Sing</code>, so you can do <code>SDoorState 'Opened</code> instead of <code>Sing 'Opened</code>, if you wish.</p>
<p>There are definitely more useful utility functions, but we will investigate these later on in the series! For now, you can look at the <a href="http://hackage.haskell.org/package/singletons/docs/Data-Singletons.html">documentation</a> for the library to see more interesting utility functions!</p>
<h2 id="the-singularity">The Singularity</h2>
<p>In this post, at shortcomings in the usage of phantom types, and then saw how singletons could help us with these. Then, we looked at how the <em>singletons</em> <strong>library</strong> makes using this pattern extremely easy and smooth to integrate into your existing code.</p>
<p>You can see all of the “manual singletons” code in this post <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs">here</a>, and then see the code re-implemented using the <em>singletons</em> library <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs">here</a>.</p>
<p>You can actually drop into a ghci session with all of the bindings in scope by executing the files:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb41-1" data-line-number="1">$ <span class="ex">./Door.hs</span></a></code></pre></div>
<p>However, remember the question that I asked earlier, about creating a <code>Door</code> with a given state that we don’t know until runtime? So far, we are only able to create <code>Door</code> and <code>SingDS</code> from types we <em>know</em> at compile-time. There is no way we have yet to convert a <code>DoorState</code> from the value level to the type level – so it seems that there is no way to “load” a <code>Door s</code> with an <code>s</code> that depends on, say, a file’s contents, or user input. The fundamental issue is still <em>type erasure</em>.</p>
<p>In Part 2, we will delve into how to overcome this and break through from the barrier of the dynamic “unsafe” runtime to the world of safe, typed, verified code, and see how the <em>singletons</em> library gives us great tools for this. Afterwards, in Part 3, we will learn to express more complicated relationships with types and type-level functions using defunctionalization and the tools from the <em>singletons</em> library, and finally break into the world of actual “type-level programming”.</p>
<p>As always, let me know in the comments if you have any questions! You can also usually find me idling on the freenode <code>#haskell</code> channel, as well, as <em>jle`</em>. The <em>singletons</em> <a href="https://github.com/goldfirere/singletons/issues">issue tracker</a> is also very active. Happy haskelling!</p>
<p>For further reading, check out the <a href="https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf">original singletons paper</a>! It’s very readable and goes over many of the same techniques in this blog post, just written with a different perspective and tone :)</p>
<h2 id="exercises">Exercises</h2>
<p>Click on the links in the corner of the text boxes for solutions! (or just check out <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs">the source file</a>)</p>
<p>These should be written in the singletons library style, with <code>Sing</code> instead of <code>SingDS</code> and <code>SingI</code> instead of <code>SingDSI</code>. Review the <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs">singletons file</a> for a comparison, if you are still unfamiliar.</p>
<ol type="1">
<li><p>Write a function to unlock a door, but only if the user enters an odd number (as a password).</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs#L64-L64</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2"></a>
<a class="sourceLine" id="cb42-3" data-line-number="3"><span class="ot">unlockDoor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> &#39;<span class="dt">Locked</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Door</span> &#39;<span class="dt">Closed</span>)</a></code></pre></div>
<p>It should return a closed door in <code>Just</code> if the caller gives an odd number, or <code>Nothing</code> otherwise.</p></li>
<li><p>Write a function that can open any door, taking a password, in “implicit Sing” style:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs#L69-L69</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2"></a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="ot">openAnyDoor ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Door</span> &#39;<span class="dt">Opened</span>)</a></code></pre></div>
<p>This should be written in terms of <code>unlockDoor</code> and <code>openDoor</code> (see above) – that is, you <strong>should not</strong> use <code>UnsafeMkDoor</code> directly for <code>openAnyDoor</code>.</p>
<p>If the door is already unlocked or opened, it should ignore the <code>Int</code> input.</p></li>
</ol>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This series will be based on <a href="http://talks.jle.im/lambdaconf-2017/singletons/">a talk</a> I gave over the summer, and will expand on it.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>The <code>'</code> ticks are technically optional, but I find that it’s good style, at this point in Haskell, to use them whenever you can. It’ll prevent a lot of confusion, trust me!<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>Indeed, this is not even possible. There are no values of type <code>'SClosed</code>, <code>'SOpened</code>, etc.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>Actually, GADT syntax just requires <code>-XGADTSyntax</code>, but <code>-XGADT</code> allows you to actually make GADTs (which we will be doing later), and implies <code>-XGADTSyntax</code><a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><code>~</code> here refers to “type equality”, or the constraint that the types on both sides are equal. <code>s ~ 'Opened</code> can be read as “<code>s</code> is <code>'Opened</code>”.<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>It is probably worth mentioning that, for practical reasons, the implementation of <em>singleton</em>’s <code>withSingI</code> is very different than the implementation we used for our <code>withSingDSI</code>. However, understanding its implementation isn’t really relevant understanding how to use the library, so we won’t really go to deep into this.<a href="#fnref6" class="footnote-back">↩</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Introduction to Singletons&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html" class="tag-a-series" title="+Introduction to Singletons"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category">@TUTORIALS</a></li><li><a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html" class="tag-a-series">+Introduction to Singletons</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/advent-of-code-2017.html">Advent of Code 2017! Ongoing solutions and explanations</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introduction-to-singletons-2.html">Introduction to Singletons (Part 2)</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introduction-to-singletons-1.html';
    this.page.identifier = 'singletons-1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>