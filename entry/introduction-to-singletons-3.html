<!DOCTYPE HTML>
<html><head><title>Introduction to Singletons (Part 3) · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Welcome back! This article is part 3 of our journey through the singleton design pattern, and the great singletons library! This post will be a continuation of Part 1 and Part 2, so if you haven’t read those first, now would be a good time to pause and do so (and also try to complete the exercises). Today we will be expanding on the ideas in those posts by working with more complex ways to restrict functions based on types. Like the previous posts, we will start by writing things “by hand”, and then jumping into the singletons library and seeing how the framework gives you tools to work with these ideas in a smoother way. The first half of today’s post will introduce a new application and design pattern that the usage of singletons greatly enhances. The second part of today’s post deals directly with the lifting of functions to the type level, which is made practical by the usage of singletons and the singletons library. Code in this post is built on GHC 8.6.1 with the nightly-2018-09-29 snapshot (so, singletons-2.5). However, unless noted, all of the code should still work with GHC 8.4 and singletons-2.4. Again, you can download the source for this file here, and, if stack is installed, you can drop into a ghci session with all of the bindings in scope executing it: $ ./Door3.hs"><meta property="og:type" content="article"><meta property="og:title" content="Introduction to Singletons (Part 3)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introduction-to-singletons-3.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introduction-to-singletons-3.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Introduction to Singletons (Part 3)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2018-10-01T13:56:55Z" pubdate="" class="pubdate">Monday October 1, 2018</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/singletons-3.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introduction-to-singletons-3.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introduction-to-singletons-3.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Welcome back! This article is part 3 of our journey through the <em>singleton design pattern</em>, and the great <em><a href="http://hackage.haskell.org/package/singletons">singletons</a></em> library!</p>
<p>This post will be a continuation of <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">Part 1</a> and <a href="https://blog.jle.im/entry/introduction-to-singletons-2.html">Part 2</a>, so if you haven’t read those first, now would be a good time to pause and do so (and also try to complete the exercises). Today we will be expanding on the ideas in those posts by working with more complex ways to <em>restrict functions</em> based on types. Like the previous posts, we will start by writing things “by hand”, and then jumping into the singletons library and seeing how the framework gives you tools to work with these ideas in a smoother way.</p>
<p>The first half of today’s post will introduce a new application and design pattern that the usage of singletons greatly enhances. The second part of today’s post deals directly with the lifting of functions to the type level, which is made practical by the usage of singletons and the <em>singletons</em> library.</p>
<p>Code in this post is built on <em>GHC 8.6.1</em> with the <em><a href="https://www.stackage.org/nightly-2018-09-29">nightly-2018-09-29</a></em> snapshot (so, <em>singletons-2.5</em>). However, unless noted, all of the code should still work with <em>GHC 8.4</em> and <em>singletons-2.4</em>. Again, you can download the source for this file <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs">here</a>, and, if <em>stack</em> is installed, you can drop into a ghci session with all of the bindings in scope executing it:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="ex">./Door3.hs</span></a></code></pre></div>
<h2 id="review">Review</h2>
<p>In the first post we looked at the <code>Door</code> type, indexed with a phantom type of kind <code>DoorState</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L29-L35</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  data DoorState = Opened | Closed | Locked</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    deriving (Show, Eq)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  |])</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Door</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    <span class="dt">UnsafeMkDoor</span><span class="ot"> ::</span> {<span class="ot"> doorMaterial ::</span> <span class="dt">String</span> } <span class="ot">-&gt;</span> <span class="dt">Door</span> s</a></code></pre></div>
<p>This gives us (at least) three distinct types <code>Door 'Opened</code>, <code>Door 'Closed</code>, and <code>Door 'Locked</code>, which can be used to represent opened, closed, and locked doors, respectively. We talked in previous posts about how we can use this for for a lot of enat tings, including enforcing type-safety, talking about how inputs relate to outputs, and uniting functions polymorphic on all door states.</p>
<p>Then we talked about situations where we want to “not care” about the door status in the type system, or when we want to return a door with a state that is not known statically, and must be determined dynamically at runtime. After going through many “analogous” and equivalent type, we arrived at the existential wrapper <code>SomeDoor</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L37-L42</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ot">mkSomeDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">mkSomeDoor ds mat <span class="fu">=</span> withSomeSing ds <span class="fu">$</span> \dsSing <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="dt">MkSomeDoor</span> dsSing (<span class="dt">UnsafeMkDoor</span> mat)</a></code></pre></div>
<p>(We must be careful to pack the <code>Sing s</code> with the <code>Door s</code>, so that we can pattern match at runtime to determine what the original <code>s</code> was.)</p>
<p>For the rest of this post, <code>SomeDoor</code> will essentially be used as a stand-in for a <code>Door s</code> that we do not know the state (the <code>s</code>) of until runtime, because to use a <code>SomeDoor</code>, we pattern-match at runtime. In general you’ll encounter types at runtime in a variety of different situations (discussed more deeply in <a href="https://blog.jle.im/entry/introduction-to-singletons-2.html">Part 2</a>), but <code>SomeDoor</code> is a nice nugget that we can examine to demonstrate more general points.</p>
<h2 id="a-need-for-more-expressive-restrictions">A Need for More Expressive Restrictions</h2>
<p>Let’s write a function that “knocks” on a door in IO:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">knock ::</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">knock d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a></code></pre></div>
<p>Hm. This doesn’t feel right. We can’t knock on an opened door..can we? Is there a way we can restrict this function to only work on <em>non-opened</em> doors? Or, more generally, is there a way to be more expressive in the manner in which we can restrict functions?</p>
<p>There are a couple of ways of doing this — we’re going to look at two possible ways that singletons and the <em>singletons</em> library help with. Both of these methods allow us to write dependently typed functions that are “type-safe” in more expressive ways than before.</p>
<p>Note that we’ll be exploring ways that are “generalizable” — to different types of restrictions that might be more complicated than just “cannot be <code>'Opened</code>”.</p>
<h2 id="dependently-typed-proofs">Dependently Typed Proofs</h2>
<p>To look at our first way of tackling this restriction problem, we’re going to explore a fun <em>new application</em> of singletons and DataKinds.</p>
<p>This new application is the usage of the dependently-typed “proof” to prove that an operation is legal. <em>Proofs</em> (in the dependently typed/constructivist/Curry-Howard sense) are witnesses to some type-level <em>predicate</em> or proposition.</p>
<p>A <strong>value-level predicate</strong> in Haskell is (generally) a function of type <code>a -&gt; Bool</code>. Given a value of type <code>a</code>, if the function returns <code>True</code>, then the predicate is satisfied. If it returns <code>False</code>, it is not.</p>
<p>A <strong>type-level predicate</strong> is (generally) a type constructor of kind <code>k -&gt; Type</code>. Given a type of kind <code>k</code>, if <em>a value exists of that type</em> (or, if a value can be constructed), then the predicate is satisfied. If no value exists, it is not. That value, if it exists, is called a <em>witness</em> or a <em>proof</em>.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>We can define a predicate <code>Knockable :: DoorState -&gt; Type</code> as a GADT that only has values if given <code>'Closed</code> and <code>'Locked</code>, but not <code>'Opened</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L44-L46</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Knockable</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="dt">KnockClosed</span><span class="ot"> ::</span> <span class="dt">Knockable</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="dt">KnockLocked</span><span class="ot"> ::</span> <span class="dt">Knockable</span> &#39;<span class="dt">Locked</span></a></code></pre></div>
<p>Now, we have a value of type <code>Knockable 'Closed</code> and <code>Knockable 'Locked</code> (<code>KnockClosed</code> and <code>KnockLocked</code>, respectively), but no value of type <code>Knockable 'Opened</code>. How can we use this?</p>
<p>Well, we can make a version of <code>knock</code> that requires a proof that <code>s</code> is <code>Knockable</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L48-L49</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">knock ::</span> <span class="dt">Knockable</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">knock _ d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a></code></pre></div>
<p><code>knock</code> can now only be called with <code>Closed</code> and <code>Locked</code> doors — do you see why? There is no way to call <code>knock</code> with <code>s ~ 'Opened</code>…because there is no way to pass a value of <code>Knockable 'Opened</code>. No such value exists! There’s no compiler error because it’s “not even wrong”!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">ghci<span class="fu">&gt;</span> knock <span class="dt">KnockClosed</span> (<span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Closed</span> <span class="st">&quot;Birch&quot;</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="dt">Knock</span> knock on <span class="dt">Birch</span> door<span class="fu">!</span></a></code></pre></div>
<p>This works well if we want to do things at compile-time</p>
<h3 id="let-the-compiler-prove-it-for-you">Let the compiler prove it for you</h3>
<p>We can even make it more seamless to use by auto-generating proofs at compile-time, with a general class like <code>Auto</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L51-L58</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">class</span> <span class="dt">Proved</span> p a <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">    auto ::</span> p a</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Proved</span> <span class="dt">Knockable</span> &#39;<span class="dt">Closed</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    auto <span class="fu">=</span> <span class="dt">KnockClosed</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Proved</span> <span class="dt">Knockable</span> &#39;<span class="dt">Locked</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    auto <span class="fu">=</span> <span class="dt">KnockLocked</span></a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">ghci<span class="fu">&gt;</span> knock auto (<span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Closed</span> <span class="st">&quot;Acacia&quot;</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="dt">Knock</span> knock on <span class="dt">Acacia</span> door<span class="fu">!</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">ghci<span class="fu">&gt;</span> knock auto (<span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Opened</span> <span class="st">&quot;Jungle&quot;</span>)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="dt">COMPILER</span> <span class="dt">ERROR</span><span class="fu">!!</span> <span class="dt">COMPILER</span> <span class="dt">ERROR</span><span class="fu">!!</span></a></code></pre></div>
<p>Such a typeclass exists in libraries like <em><a href="http://hackage.haskell.org/package/type-combinators">type-combinators</a></em> (called <code>Known</code>) and <a href="http://hackage.haskell.org/package/decidable">decidable</a> (called <code>Auto</code>). In dependently typed languages like Idris, <code>auto</code> is actually a built-in language keyword that does this automatically!</p>
<h3 id="decidable-predicates">Decidable Predicates</h3>
<p>However, all of this only works if you know what <code>s</code> is at compile-time. What if you don’t? What if you are retrieving <code>s</code> at runtime (like from a <code>SomeDoor</code> or <code>withSomeSing</code>), or you are forced to handle all possible <code>s</code>s?</p>
<p>To do this, we’re going to take advantage of a property of some predicates called “decidability”. We say that a predicate is <em>decidable</em> if, for any input type, we can say whether or not the predicate is satisfiable.</p>
<p>We say that a predicate <code>P</code> in Haskell is <em>decidable</em> if we can always prove, for any input, if the predicate holds or does not hold. Concretely, it means that we can write a total function:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">decidePred</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Sing</span> x               <span class="co">-- ^ given a type</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">P</span> x)       <span class="co">-- ^ return a decision</span></a></code></pre></div>
<p>Where:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Decision</span> a <span class="fu">=</span> <span class="dt">Proved</span> a                  <span class="co">-- ^ a value of a exists</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">                <span class="fu">|</span> <span class="dt">Disproved</span> (<span class="dt">Refuted</span> a)     <span class="co">-- ^ a value of a cannot exist</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="co">-- | The data type with no values</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="co">-- | &#39;a&#39; cannot exist.  Commonly also called `Not`</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">type</span> <span class="dt">Refuted</span> a <span class="fu">=</span> a <span class="ot">-&gt;</span> <span class="dt">Void</span></a></code></pre></div>
<p><code>Decision a</code> is like a <code>Maybe a</code>, except instead of <code>Nothing</code>, we include a proof that the predicate is <em>not</em> true.</p>
<p>The <code>a -&gt; Void</code> idiom (often called <code>Not a</code>, or <code>Refuted a</code>) is type we use in Haskell and other languages to represent the fact that it is impossible to construct a value of type <code>a</code>. That’s because if you could, then you could give it to an <code>a -&gt; Void</code> to get a value of type <code>Void</code>, which is impossible to have. So, if a possible function <code>a -&gt; Void</code> exists, it necessarily means that a value of type <code>a</code> cannot exist.</p>
<p>It’s a lot to handle all at once, so let’s look at an example. Is <code>Knockable</code> a decidable predicate? Yes!</p>
<p>We need to write a function:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">isKnockable ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">Knockable</span> s)</a></code></pre></div>
<p>I recommend taking a moment and trying to implement this yourself. Remember to enable <code>-Werror=incomplete-patterns</code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> (or at least <code>-Wall</code>) to make sure you’re handling all potential pattern matching cases.</p>
<p>Are you ready? Here’s a solution:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L60-L64</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="ot">isKnockable ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">Knockable</span> s)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">isKnockable <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Disproved</span> <span class="fu">$</span> \<span class="kw">case</span> {}    <span class="co">-- s ~ &#39;Opened</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Proved</span> <span class="dt">KnockClosed</span>      <span class="co">-- s ~ &#39;Closed</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">Proved</span> <span class="dt">KnockLocked</span>      <span class="co">-- s ~ &#39;Locked</span></a></code></pre></div>
<p>This definition should seem pretty straightforward for the <code>SClosed</code> and <code>SLocked</code> branches. <code>isKnockable SClosed :: Decision (Knockable 'Closed)</code>, we give <code>Proved KnockClosed</code>, which gives us just that!</p>
<p>However, <code>isKnockable SOpened :: Decision (Knockable 'Opened)</code>. We can’t use <code>Proved :: a -&gt; Decision a</code>, because no such value of type <code>Knockable 'Opened</code> exists. So, we have to say that we <em>disprove</em> it: we have to prove to GHC that no such type could possibly exist. We do this by providing a function of type <code>Refuted (Knockable 'Opened)</code>, or type <code>Knockable 'Opened -&gt; Void</code>.</p>
<p>We can write it like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L66-L67</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="ot">disproveOpened ::</span> <span class="dt">Knockable</span> &#39;<span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">disproveOpened k <span class="fu">=</span> <span class="kw">case</span> k <span class="kw">of</span> {}             <span class="co">-- empty pattern match</span></a></code></pre></div>
<p>And we’re good to go!</p>
<p>How does this work?</p>
<p>Well, remember, we have to pattern match on the possible inputs. However, we can’t use any of the “legal” patterns:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">disproveOpened ::</span> <span class="dt">Knockable</span> &#39;<span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">disproveOpened k <span class="fu">=</span> <span class="kw">case</span> k <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="dt">KnockClosed</span> <span class="ot">-&gt;</span> <span class="fu">...</span>    <span class="co">-- not a valid pattern, since it&#39;s `Knockable &#39;Closed`</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    <span class="dt">KnockLocked</span> <span class="ot">-&gt;</span> <span class="fu">...</span>    <span class="co">-- not a valid pattern, since it&#39;s `Knockable &#39;Locked`</span></a></code></pre></div>
<p>If you include either of those patterns, GHC will complain. So, there is no valid pattern to match on… so <code>disproveOpened = \case {}</code> is enough to write the function <code>Knockable 'Opened -&gt; Void</code>, since there is no constructor for a value of type <code>Knockable 'Opened</code> to match on. This only works because <code>disproveOpened</code> is a <strong>complete pattern match</strong>, and therefore total.</p>
<p>We can use this decision function, finally, to handle an arbitrary <code>Door</code> whose status we not know until runtime:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L69-L74</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">knockSomeDoor</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">SomeDoor</span>     <span class="co">-- ^ status not known until you pattern match at runtime</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">knockSomeDoor (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span> <span class="kw">case</span> isKnockable s <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    <span class="dt">Proved</span> k    <span class="ot">-&gt;</span> knock k d</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    <span class="dt">Disproved</span> _ <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;No knocking allowed!&quot;</span></a></code></pre></div>
<p>While arguably less useful than one provable predicates, a typeclass for decidable predicates is also possible; the aptly-named <a href="http://hackage.haskell.org/package/decidable">decidable</a> package offers such a typeclass, called <code>Decidable</code>!</p>
<h3 id="decision">Decision</h3>
<p>The definition of the <code>Decision</code> data type might be surprising if you’re first seeing it. You want to prove something…so why would you care about the case where it’s “not true”? Why not just have something like <code>Maybe</code>, where you have <code>data Decision a = Proved a | Disproved</code>?</p>
<p>In other words, why do we care about proving both true or false, when it looks like we only ever use the true situation? After all, we ignore the <code>Refuted (Knockable s)</code> in our implementation of <code>knockSomeDoor</code>.</p>
<p>One answer is that we <em>do</em> use the contents of <code>Disproved</code> in practice. In <code>knockSomeDoor</code>, we matched on <code>Disproved _</code> and threw away the counter-proof…however, as we see later in the exercises, there are situations where the contents of <code>Disproved</code> are used.</p>
<p>However, a deeper answer to me is that it keeps the author of the function accountable. You can’t just say “this predicate isn’t true”…you have to <em>earn</em> it. And often, the act of trying to earn your disproof (or not being able to) helps you iron out bad assumptions you’ve made.</p>
<p>For example, if we used <code>Maybe</code> instead of <code>Decision</code>, we could write:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">isKnockable ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> s</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">isKnockable <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="dt">KnockLocked</span></a></code></pre></div>
<p>We might falsely claim that <code>SClosed</code> is not knockable. So, if the user of our bad <code>isKnockable</code> gets <code>Nothing</code>, they don’t know if their input is not knockable or knockable…they know <em>nothing</em> about the knockability status of <code>'Opened</code> or <code>'Closed</code>.</p>
<p>However, we can’t write this bad implementation with <code>Decision</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">isKnockable ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Decision</span> s</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">isKnockable <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Disproved</span> <span class="fu">$</span> \<span class="kw">case</span> {}</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Disproved</span> <span class="fu">$</span> <span class="co">-- ????</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">Proved</span> <span class="dt">KnockLocked</span></a></code></pre></div>
<p>There is no valid thing you can put in the <code>????</code>! That’s because you need to write a function of type <code>Knocked 'Closed -&gt; Void</code>…but no such (total or non-partial) function exists. We can’t write <code>\case {}</code>, because that’s an incomplete pattern match — it’s missing a match on the <code>KnockClosed</code> pattern.</p>
<p>Note also that this is why it’s very important to always have <code>-Werror=incomplete-patterns</code> (or at least <code>-Wall</code> — warn all) on when writing dependently typed proofs, to ensure that GHC warns you when your pattern matches are incomplete and you know your proof is invalid.</p>
<p>In the examples, we see two more non-trivial examples of decision functions (<code>and p q</code> and <code>or p q</code>) that are impossible to implement incorrectly, due to the structure of the predicates.</p>
<h3 id="perspective-on-proofs">Perspective on Proofs</h3>
<p>We just briefly touched on a very simple version of a dependently typed proof, and how to “prove” properties.</p>
<p>If you have heard things about dependently typed programming before, you might have heard that a lot of it involves “proving properties about your programs” and “forcing you to provide proofs for all of your actions”. The idea of a “proof” might seem a bit scary and “mathematical” to those coming from a software development world.</p>
<p>However, as we just saw, working with proofs and decisions of proofs can be as simple as a couple lines of GADTs and dependent pattern matches.</p>
<p>So, when we see a function like:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">knock ::</span> <span class="dt">Knockable</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>We can read the type signature as: “Knocking requires both a <code>Door s</code> and a <em>proof</em> that the door’s status is <code>Knockable</code>”. It makes it impossible for us to run <code>knock</code> on a status that is not <code>Knockable</code>, like, say, <code>'Opened</code>.</p>
<p>In this light, the role of a proof is like a “key” that a type (like <code>'Closed</code>) must provide to “unlock” functions like <code>knock</code>.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> A <em>decision function</em> is a function to generate these proofs (or prove that they are impossible) for given types.</p>
<p>On one level, you can think of proofs as “compiler tricks”, or things that exist only to appease the compiler. In fact, compilers of languages that encourage heavy usage of proofs (like Agda, Coq, Idris) actually implement something called <em>proof erasure</em>. That is, in those languages, values like <code>KnockClosed</code> and <code>KnockLocked</code> might never exist at runtime, since they never actually <em>do</em> anything at runtime. They only exist as ways to limit or enable specific programs from compiling, and serve no purpose after compilation. GHC Haskell does not implement proof erasure at the time of this post (current GHC version 8.6), but if proofs like this become commonplace, you might be reading this during a time where GHC Haskell erases proofs like <code>Knockable</code> witnesses!<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<h3 id="the-role-of-singletons">The Role of Singletons</h3>
<p>Proofs themselves might not play a role at run-time, but generating/deciding them with types requires being able to pattern match and work with <em>types</em> at run-time. Because of this, singletons play an important practical role in working with proofs in Haskell.</p>
<p>After all, remember the type of our decision function:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">isKnockable ::</span> <span class="dt">Sing</span> a <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">Knockable</span> a)</a></code></pre></div>
<p>The <code>Sing</code> allows <code>isKnockable</code> to pattern match and inspect the <em>type</em> <code>a</code> to create your proof.</p>
<p>In this light, the <em>singletons</em> library provides many tools for working with proofs and decisions. In fact, the entire <em>Data.Singletons.Decide</em> module is dedicated to working with proofs and decisions. It provides the <code>Decision</code> data type and <code>Refuted</code> type synonym, both featured above.</p>
<p>It also re-exports a particularly useful predicate from <em>base</em>, <em>propositional equality</em>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">data</span><span class="ot"> (:~:) ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    <span class="dt">Refl</span><span class="ot"> ::</span> a <span class="fu">:~:</span> a</a></code></pre></div>
<p>Like how <code>Knockable</code> is a predicate that a given status is “knockable”, <code>('Blah :~:)</code> is a predicate that a given type is <em>equal to</em> <code>'Blah</code>. A value of type <code>Knockable s</code> is a proof that <code>s</code> is knockable, and a value of type <code>'Blah :~: a</code> is a proof that <code>a</code> is <em>equal to</em> <code>'Blah</code>.</p>
<p>To see how, note the constructors that it allows. Remember that we limit <code>Knockable s</code> to only having “knockable” <code>s</code> by only allowing two constructors, so we can only construct valid values. The same thing happens here – <code>('Blah :~:)</code> only has <em>one single constructor</em>: <code>Refl :: 'Blah :~: 'Blah</code>. The only valid constructor is one where the left hand side is equal to the right hand side. I like to use <code>Refl</code> with type application syntax, like <code>Refl @'Blah</code>, so it’s always clear exactly what we are saying is the same.</p>
<p>It also offers the “kindclass” <code>SDecide</code>, which provides <em>decision functions</em> for the <code>(a :~:)</code> predicate:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">class</span> <span class="dt">SDecide</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="ot">    (%~) ::</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">         <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">b ::</span> k)</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">         <span class="ot">-&gt;</span> <span class="dt">Decision</span> (a <span class="fu">:~:</span> b)</a></code></pre></div>
<p>For example, <code>Bool</code> is an instance of <code>SDecide</code>, so we have a function:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">(<span class="dt">STrue</span> <span class="fu">%~</span>)<span class="ot"> ::</span> <span class="dt">Sing</span> b <span class="ot">-&gt;</span> <span class="dt">Decision</span> (&#39;<span class="dt">True</span> <span class="fu">:~:</span> b)</a></code></pre></div>
<p>which is a decision function to check if <code>b</code> is equal to <code>'True</code>. You can sort of imagine <code>SDecide</code> as a type-level <code>Eq</code> typeclass, but for “type equality”.</p>
<h2 id="type-level-functions">Type Level Functions</h2>
<p>We’re now going to look at a different method useful for restricting how we can call functions. Something we can do is define a type that expresses knockable-or-not-knockable, as a value:<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  data Pass = Obstruct | Allow</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  |])</a></code></pre></div>
<p>And we can write a <em>type-level function</em> (implemented as <em>type family</em>) from <code>DoorState</code> to a <code>Pass</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">StatePass</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>)<span class="ot"> ::</span> <span class="dt">Pass</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    <span class="dt">StatePass</span> &#39;<span class="dt">Opened</span> <span class="fu">=</span> &#39;<span class="dt">Allow</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    <span class="dt">StatePass</span> &#39;<span class="dt">Closed</span> <span class="fu">=</span> &#39;<span class="dt">Obstruct</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    <span class="dt">StatePass</span> &#39;<span class="dt">Locked</span> <span class="fu">=</span> &#39;<span class="dt">Obstruct</span></a></code></pre></div>
<p>We’ve briefly touched on type families before (in talking about <code>SingKind</code>), but, as a quick review: type families act a bit like type-level functions. They take types as input arguments and return types in return.</p>
<p>We can inspect how type families are applied by using the <code>:kind!</code> command in ghci:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">StatePass</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">&#39;<span class="dt">Allow</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">StatePass</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4">&#39;<span class="dt">Obstruct</span></a></code></pre></div>
<p>Like type synonyms, type families can’t be partially applied. They only ever make sense in “fully applied” form, with all arguments given syntactically.</p>
<p>Armed with this type family, we can write a new version of <code>knock</code>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L86-L87</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="ot">knockP ::</span> (<span class="dt">StatePass</span> s <span class="fu">~</span> &#39;<span class="dt">Obstruct</span>) <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">knockP d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a></code></pre></div>
<p><code>a ~ b</code> is a constraint for <em>type equality</em>. This constraint means that calling <code>knock</code> requires that <code>StatePass s</code> is <em>equal to</em> (or unifies with) <code>'Allow</code>. So, if we attempt to call <code>knock</code> with a <code>'Locked</code> door, then because <code>StatePass 'Locked</code> is <code>'Allow</code>, the constraint is satisfied and everyone is happy. If we attempt to call <code>knock</code> with an <code>'Opened</code> door, <code>StatePass 'Opened</code> is <code>'Obstruct</code>, so the constraint is not satisfied and everyone is sad.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="kw">let</span> door1 <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Closed</span> <span class="st">&quot;Oak&quot;</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">ghci<span class="fu">&gt;</span> <span class="kw">let</span> door2 <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Opened</span> <span class="st">&quot;Spruce&quot;</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">ghci<span class="fu">&gt;</span> knock door1</a>
<a class="sourceLine" id="cb28-4" data-line-number="4"><span class="co">-- Knock knock on Oak door!</span></a>
<a class="sourceLine" id="cb28-5" data-line-number="5">ghci<span class="fu">&gt;</span> knock door2</a>
<a class="sourceLine" id="cb28-6" data-line-number="6"><span class="dt">COMPILE</span> <span class="dt">ERROR</span><span class="fu">!</span></a>
<a class="sourceLine" id="cb28-7" data-line-number="7"><span class="co">--     • Couldn&#39;t match type ‘&#39;Allow’ with ‘&#39;Obstruct’</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8"><span class="co">--             arising from a use of ‘knock’</span></a></code></pre></div>
<h3 id="deciding-at-runtime">Deciding at Runtime</h3>
<p>One nice thing is that, if we know <code>s</code> at compile-time, we can call this function without having to pass any manual proofs. However, we have to deal with the same issue as before: what happens if we don’t know <code>s</code> until runtime? How do we prove to the compiler that <code>Passable s</code> is <code>'Allow</code>?</p>
<p>Remember that type families take <em>types</em> as inputs, so we can’t write:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">knockSomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">knockSomeDoor (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    <span class="kw">case</span> <span class="dt">StatePass</span> s <span class="kw">of</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">      <span class="co">-- ...</span></a></code></pre></div>
<p>because <code>s</code>, a value, can’t be given to <code>StatePass</code>.</p>
<p>What we really want to do is pass <code>s</code> (the singleton representing a type) to <code>StatePass</code> (the type family). And then, we want to match on the <em>resulting type</em>, so we can decide what to do based on the result.</p>
<p>If you think about this predicament long enough, you might begin to see a solution. Essentially, we want a function that takes a <em>singleton</em> of <code>s</code>, and return a <em>singleton</em> of <code>StatePass s</code>.</p>
<p>What we want, in the end, is a <em>mirror</em> of the type-level function <em>at the value level</em>. We need to write a function of type <code>Sing s -&gt; Sing (StatePass s)</code>: given a singleton of a type, return a singleton of the type family applied to the type.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">StatePass</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>)<span class="ot"> ::</span> <span class="dt">Pass</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">    <span class="dt">StatePass</span> &#39;<span class="dt">Opened</span> <span class="fu">=</span> &#39;<span class="dt">Allow</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">    <span class="dt">StatePass</span> &#39;<span class="dt">Closed</span> <span class="fu">=</span> &#39;<span class="dt">Obstruct</span></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">    <span class="dt">StatePass</span> &#39;<span class="dt">Locked</span> <span class="fu">=</span> &#39;<span class="dt">Obstruct</span></a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="ot">sStatePass ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">StatePass</span> s)</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">sStatePass <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">SAllow</span></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">SObstruct</span></a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">SObstruct</span></a></code></pre></div>
<p>We have to be very careful with how we define <code>sStatePass</code>, because GHC isn’t too smart. It’ll reject any definition that isn’t structurally identical to the type family it’s mirroring.</p>
<p>With our new tool, we can now write:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L89-L94</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">knockSomeDoorP</a>
<a class="sourceLine" id="cb31-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">SomeDoor</span>     <span class="co">-- ^ status not known until you pattern match at runtime</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">knockSomeDoorP (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span> <span class="kw">case</span> sStatePass s <span class="kw">of</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    <span class="dt">SObstruct</span> <span class="ot">-&gt;</span> knockP d                        <span class="co">-- ^ `StatePass s ~ &#39;Obstruct`</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    <span class="dt">SAllow</span>    <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;No knocking allowed!&quot;</span> <span class="co">-- ^ `StatePass s ~ &#39;Allow`</span></a></code></pre></div>
<p>First we use <code>sStatePass s</code> to check the “pass” of the <code>s</code>. Then, we match on the <code>Pass</code>: if it’s <code>'Obstruct</code>, like the type signature of <code>knock</code> requires, we can run <code>knock</code>. If not, then we cannot!</p>
<h3 id="singletons-library-to-the-rescue">Singletons Library to the Rescue</h3>
<p>At the high level, we defined a “function” on types (<code>StatePass</code>), using type families.</p>
<p>And, just like we have to define singletons (<code>SOpened</code>, <code>SClosed</code>, etc.) at the value level to mirror what is happening at the type level, we also have to define <em>singleton functions</em> (<code>sStatePass</code>) at the value level to mirror what is happening at the type level.</p>
<p>Defining singletons for our types is a tedious and mechanical process. Defining singletonized functions for our type families is also similarly tedious and mechanical. This is where the <em>singletons</em> library comes in: it provides us Template Haskell tools to automatically define type families and their associated singleton functions:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">  statePass :: DoorState -&gt; Pass</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">  statePass Opened = Allow</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">  statePass Closed = Obstruct</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">  statePass Locked = Obstruct</a>
<a class="sourceLine" id="cb32-6" data-line-number="6">  |])</a></code></pre></div>
<p>The above declaration would normally declare only the value-level function <code>statePass</code> with the type <code>DoorSate -&gt; Pass</code>.</p>
<p>However, with singleton’s template haskell, this also generates:<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<ul>
<li>The <em>type family</em> <code>StatePass (s :: DoorState) :: Pass</code>, like we defined above</li>
<li>The <em>singleton function</em> <code>sStatePass</code>, with the type <code>Sing s -&gt; Sing (StatePass s)</code>, like we defined above.</li>
</ul>
<p>The naming convention for functions with non-symbol names takes a function like <code>myFunction</code> and generates the type family <code>MyFunction</code> and the singleton function <code>sMyFunction</code>.</p>
<p>The naming convention for functions with symbolic names (operators) takes an operator like <code>++</code> and generates the type family <code>++</code> (keeping the identical name) and the singleton function <code>%++</code>.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a></p>
<h2 id="a-comparison">A Comparison</h2>
<p>We went over two methods of using phantom types with the singleton library and dependent types to restrict how certain functions can be called, on a more non-trivial level.</p>
<p>Our first method was leveraging “dependently typed proofs”. These are useful because they are constructed to exploit the “structure” of the types you create. Essentially, we create a data type (predicate) in a way so that it is impossible to create an “invalid” proof. And, often, if we write our proofs in a clever enough way, we can actually use and combine proofs to generate new proofs. (More examples in the exercises)</p>
<p>Personally, I find this to be the source of a lot of the “fun” of dependently typed programming — our proofs become first class values, and if we define them in a nice enough way, we can use manipulate them to create new proofs. (A full exploration of this is well beyond the scope of this post)</p>
<p>However, in practice, carefully constructing predicates and proofs (ones more complicated than the one we just looked at) requires some up-front cost in thinking about how to best express your predicate, and is sometimes not straightforward.</p>
<p>I consider the second method, using type-level functions, to be the more “mechanical” way, with less upfront cost in thinking time. For the most part, if you can write a normal term-level function (something that most Haskell programmers are comfortable doing), you can write a type-level function. This is even made simpler with singletons — you can just write your term-level relationship as a normal function, and you can now just directly use your function at the type level.</p>
<p>In fact, consider if there were more than two <code>Pass</code> (maybe allow, obstruct, or partial?). In that case, we can easily restrict a function based on the <code>Pass</code> being equal to any of the three or more by using the <code>~</code> constraint. Using the dependently typed proof version, though, we would have to create a new GADT for each situation.</p>
<p>In a way, type-level functions deliver on the promise of blurring the line between type and value. Our term-level functions are now type-level functions! We just need to remember to switch our capitalizations!</p>
<p>But this strength is also its weakness. Remember that the problem of normal term-level functions was that they are potentially “incorrect”, and not directly verifiable. So, if you just lift your potentially incorrect term-level functions to the type level…what you get is potentially incorrect type-level functions! You get the <em>same</em> logic errors. Really, writing type-level functions (unsurprisingly) brings all of the error-proneness of writing at the term-level.</p>
<p>In contrast, if you use dependently typed proofs correctly, these proofs can <em>compose</em>, and GHC can check that <em>these proofs compose correctly</em>, or that the compositions of your proofs are also valid proofs. That’s because this is enforced at the <em>structural level</em>. (We’ll look at some examples in the exercises) GHC can’t do that directly with functions; it can’t check that the composition of functions gives correct answers.</p>
<p>These two approaches aren’t necessarily mutually exclusive, and you often might mix the two. It’s good to understand the trade-offs in up-front cost, expressiveness, and correctness! But, however way you play, the <em>singletons</em> library is here to make our life easier.</p>
<h2 id="singleton-library-functions">Singleton Library Functions</h2>
<p>As we have seen, working with type-level functions with singletons involves at least two parts — the type family working on the type-level values, and the singleton functions mirroring the type family, working on the term-level singletons.</p>
<p>The singletons library offers template haskell to make working with these things pretty seamless. In fact, a good portion of Prelude and base is promoted and exported by singletons!</p>
<p>You can find most of these in the <em>Data.Singletons.Prelude</em> module namespace. So, with singletons, you get functions like:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">fst<span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2"></a>
<a class="sourceLine" id="cb33-3" data-line-number="3"><span class="kw">type</span> family <span class="dt">Fst</span> (<span class="ot">t ::</span> (a, b))<span class="ot"> ::</span> a</a>
<a class="sourceLine" id="cb33-4" data-line-number="4"></a>
<a class="sourceLine" id="cb33-5" data-line-number="5"><span class="ot">sFst ::</span> <span class="dt">Sing</span> t <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">Fst</span> t)</a></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="ot">isLeft ::</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"></a>
<a class="sourceLine" id="cb34-3" data-line-number="3"><span class="kw">type</span> family <span class="dt">IsLeft</span> (<span class="ot">t ::</span> <span class="dt">Either</span> a b)<span class="ot"> ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4"></a>
<a class="sourceLine" id="cb34-5" data-line-number="5"><span class="ot">sIsLeft ::</span> <span class="dt">Sing</span> t <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">IsLeft</span> t)</a></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb35-2" data-line-number="2"></a>
<a class="sourceLine" id="cb35-3" data-line-number="3"><span class="kw">type</span> family (<span class="ot">xs ::</span> [a]) <span class="fu">++</span> (<span class="ot">ys ::</span> [a])<span class="ot"> ::</span> [a]</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"></a>
<a class="sourceLine" id="cb35-5" data-line-number="5"><span class="ot">(%++) ::</span> <span class="dt">Sing</span> xs <span class="ot">-&gt;</span> <span class="dt">Sing</span> ys <span class="ot">-&gt;</span> <span class="dt">Sing</span> (xs <span class="fu">++</span> ys)</a></code></pre></div>
<h3 id="promoted-typeclasses">Promoted Typeclasses</h3>
<p>But, how can we promote functions like <code>(==)</code> and <code>max</code>, which are typeclass-polymorphic?</p>
<p>With kindclasses (typeclasses for kinds), of course!</p>
<p>Let’s remember what we need for these promoted functions to work: the type families, and the singleton functions.</p>
<p>The <em>singletons</em> library handles this by providing each of these in a separate typeclass. Let’s look at the humble <code>Eq</code> typeclass as an example:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3"><span class="ot">    (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p>The <em>singletons</em> library promotes this as:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">class</span> <span class="dt">PEq</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2">    <span class="kw">type</span> (<span class="ot">x ::</span> a) <span class="fu">==</span> (<span class="ot">y ::</span> a)<span class="ot"> ::</span> <span class="dt">Bool</span>       <span class="co">-- ^ associated type / type family</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">    <span class="kw">type</span> (<span class="ot">x ::</span> a) <span class="fu">/=</span> (<span class="ot">y ::</span> a)<span class="ot"> ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb37-4" data-line-number="4"></a>
<a class="sourceLine" id="cb37-5" data-line-number="5"><span class="kw">class</span> <span class="dt">SEq</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6"><span class="ot">    (%==) ::</span> <span class="dt">Sing</span> (<span class="ot">x ::</span> a) <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">y ::</span> a) <span class="ot">-&gt;</span> <span class="dt">Sing</span> (x <span class="fu">==</span> y)</a>
<a class="sourceLine" id="cb37-7" data-line-number="7"><span class="ot">    (%/=) ::</span> <span class="dt">Sing</span> (<span class="ot">x ::</span> a) <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">y ::</span> a) <span class="ot">-&gt;</span> <span class="dt">Sing</span> (x <span class="fu">/=</span> y)</a></code></pre></div>
<p>The naming convention is to just add <code>P</code> for the “promoted” type family functions, and <code>S</code> for the singleton functions.</p>
<p>In fact, you can even promote your own custom typeclasses:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb38-2" data-line-number="2">  class MyClass a where</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    myFunc :: a -&gt; a</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">  |])</a></code></pre></div>
<p>This would create:</p>
<ol type="1">
<li>The <em>typeclass</em> <code>MyClass</code> with method <code>myFunc :: MyClass a =&gt; a -&gt; a</code></li>
<li>The <em>promoted typeclass</em> <code>PMyClass</code> with associated type/type family <code>MyFunc (x :: a) :: a</code></li>
<li>The <em>singletonized</em> typeclass <code>SMyClass</code> with method <code>sMyFunc :: Sing x -&gt; Sing (MyFunc x)</code>.</li>
</ol>
<h3 id="automatically-promoting-instances">Automatically Promoting Instances</h3>
<p>The <em>singletons</em> library is smart enough to automatically promote instances, as well, including derived ones!</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb39-2" data-line-number="2">  data Pass = Obstruct | Allow</a>
<a class="sourceLine" id="cb39-3" data-line-number="3"></a>
<a class="sourceLine" id="cb39-4" data-line-number="4">  instance Eq Pass where</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">      Obstruct == Obstruct = True</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">      Obstruct == Allow    = False</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">      Allow    == Obstruct = False</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">      Allow    == Allow    = True</a>
<a class="sourceLine" id="cb39-9" data-line-number="9"></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">      Obstruct /= Obstruct = True</a>
<a class="sourceLine" id="cb39-11" data-line-number="11">      Obstruct /= Allow    = False</a>
<a class="sourceLine" id="cb39-12" data-line-number="12">      Allow    /= Obstruct = False</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">      Allow    /= Allow    = True</a>
<a class="sourceLine" id="cb39-14" data-line-number="14">  |])</a></code></pre></div>
<p>This automatically also generates <code>PEq</code> and <code>SEq</code> instances for <code>Pass</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> &#39;<span class="dt">Obstruct</span> <span class="fu">==</span> &#39;<span class="dt">Obstruct</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">&#39;<span class="dt">True</span></a>
<a class="sourceLine" id="cb40-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="dt">SAllow</span> <span class="fu">%==</span> <span class="dt">SObstruct</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4"><span class="dt">SFalse</span></a></code></pre></div>
<p>But, you can also just write:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">  data Pass = Obstruct | Allow</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">    deriving (Show, Eq, Ord)</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">  |])</a></code></pre></div>
<p>And this works as well!</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Show_</span> &#39;<span class="dt">Obstruct</span>      <span class="co">-- is named Show_ to not conflict with prelude Show</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="st">&quot;Obstruct&quot;</span></a>
<a class="sourceLine" id="cb42-3" data-line-number="3">ghci<span class="fu">&gt;</span> sMax <span class="dt">SObstruct</span> <span class="dt">SAllow</span></a>
<a class="sourceLine" id="cb42-4" data-line-number="4"><span class="dt">SAllow</span></a></code></pre></div>
<h2 id="next-steps">Next Steps</h2>
<p>In this article we tackled the problem of more expressive ways to <em>restrict</em> the ways users can manipulate our data types. We talked about “dependently typed proofs” (a staple tool of dependently typed programming) and about “type level functions” (a familiar friend in a new context), their trade-offs, and how the <em>singletons</em> library provides tools to make working with both easier.</p>
<p>When we first looked at the idea of phantom type parameters, using them to <em>restrict</em> how functions are called was definitely one of the promises I made. By now, this promise has hopefully been fully realized.</p>
<p>However, the <em>other</em> promise we made about the usefulness of phantom type parameters is that we can use them be more expressive in what our functions do. One huge benefit of using phantom types in this way is that we can express how our input values relate to our output values in ways that we couldn’t before. (as a simple example, we had previously written <code>closeDoor :: Door 'Opened -&gt; Door 'Closed</code>, which we know closes a door just by looking at its type)</p>
<p>This goes beyond simple restrictions, and we will begin discussing this in the next post! We’ll explore using type-level functions to express more non-trivial and complex relationships, and also talk about code re-use using <em>higher-order functions</em> via singleton’s defunctionalization system.</p>
<p>That’s it for now — check out the exercises, and feel free to ask any questions in the comments, or in freenode <code>#haskell</code>, where I idle as <em>jle`</em>!</p>
<h2 id="exercises">Exercises</h2>
<p>Here are some exercises to help cement your understanding of the concepts here! Feel free to start from <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs">the sample source code</a>; it contains all of the solutions, but you can delete everything after the comment <code>-- Exercises</code> if you wish to start on your own!</p>
<p><strong>Remember to enable <code>-Werror=incomplete-patterns</code> or <code>-Wall</code></strong> to ensure that all of your functions are total! None of these implementations should require any incomplete pattern matches!</p>
<ol type="1">
<li><p>We talk about predicates as type constructors with type <code>k -&gt; Type</code>. This fits a lot of things we’ve seen before (all instances of <code>Functor</code>, for example), but some predicates are more interesting than others.</p>
<p>What is the interpretation of <code>SDoorState</code> as a predicate? (remember, <code>SDoorState s</code> is the type synonym for <code>Sing (s :: DoorState)</code>) What “traditional” (that is, <code>a -&gt; Bool</code>) predicate does it correspond to?</p>
<p>What is the type of its <em>decision function</em>? Can you implement it?</p>
<p>Solution available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L101-L106">here</a>!</p></li>
<li><p>Now let’s practice working with predicates, singletons, and negation via <code>Refuted</code> together.</p>
<p>You may have heard of the principle of “double negation”, where <em>not (not p)</em> implies <em>p</em>. So, we should be able to say that <code>Refuted (Refuted (Knockable s))</code> implies <code>Knockable s</code>.<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> If something is not “not knockable”, then it must be knockable, right?</p>
<p>Try writing <code>refuteRefuteKnockable</code> to verify this principle — at least for the <code>Knockable</code> predicate.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L109-L112</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2"></a>
<a class="sourceLine" id="cb43-3" data-line-number="3">refuteRefuteKnockable</a>
<a class="sourceLine" id="cb43-4" data-line-number="4"><span class="ot">    ::</span> forall s<span class="fu">.</span> <span class="dt">SingI</span> s</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">Refuted</span> (<span class="dt">Refuted</span> (<span class="dt">Knockable</span> s))</a>
<a class="sourceLine" id="cb43-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Knockable</span> s</a></code></pre></div>
<p>While not required, I recommend using <code>isKnockable</code> and writing your implementation in terms of it! Use <code>sing</code> to give <code>isKnockable</code> the singleton it needs.</p>
<p>Solution available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L109-L116">here</a>!</p>
<p><em>Hint:</em> You might find <code>absurd</code> (from <em>Data.Void</em>) helpful:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="ot">absurd ::</span> forall a<span class="fu">.</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>If you have a <code>Void</code>, you can make a value of any type!<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a></p></li>
<li><p>(This next one is fairly difficult compared to the others, and is only tangentially related to singletons, so feel free to skip it!)</p>
<p>Type-level predicates are logical constructs, so we should be able to define concepts like “and” and “or” with them.</p>
<ol type="a">
<li><p>Define a predicate constructor <code>And</code> that takes two predicates and returns a new predicate. This new predicate is true (aka, has an inhabitant) if and only if the two original predicates are true (aka, have inhabitants)</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L119-L119</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2"></a>
<a class="sourceLine" id="cb45-3" data-line-number="3"><span class="kw">data</span> <span class="dt">And</span><span class="ot"> ::</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="kw">where</span></a></code></pre></div></li>
<li><p>Define a predicate constructor <code>Or</code> that takes two predicates and returns a new predicate. This new predicate is true (aka, has an inhabitant) if and only if at least one of the two original predicates are true (aka, have inhabitants)</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L122-L122</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2"></a>
<a class="sourceLine" id="cb46-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Or</span><span class="ot"> ::</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="kw">where</span></a></code></pre></div>
<p>There are potentially multiple non-trivial variations of this type.</p>
<p>Do <code>And</code> and <code>Or</code> look similar to any types you might have encountered in the past? Maybe, perhaps, similiar to types that are a part of basic beginner Haskell concepts?</p></li>
<li><p>Maybe surprisingly, <code>And p q</code> and <code>Or p q</code> are decidable if <code>p</code> and <code>q</code> are. Can we write the decision functions?</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L126-L141</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2"></a>
<a class="sourceLine" id="cb47-3" data-line-number="3">decideAnd</a>
<a class="sourceLine" id="cb47-4" data-line-number="4"><span class="ot">    ::</span> (forall x<span class="fu">.</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Decision</span> (p x))</a>
<a class="sourceLine" id="cb47-5" data-line-number="5">    <span class="ot">-&gt;</span> (forall x<span class="fu">.</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Decision</span> (q x))</a>
<a class="sourceLine" id="cb47-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> a</a>
<a class="sourceLine" id="cb47-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">And</span> p q a)</a>
<a class="sourceLine" id="cb47-8" data-line-number="8"></a>
<a class="sourceLine" id="cb47-9" data-line-number="9">decideOr</a>
<a class="sourceLine" id="cb47-10" data-line-number="10"><span class="ot">    ::</span> (forall x<span class="fu">.</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Decision</span> (p x))</a>
<a class="sourceLine" id="cb47-11" data-line-number="11">    <span class="ot">-&gt;</span> (forall x<span class="fu">.</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Decision</span> (q x))</a>
<a class="sourceLine" id="cb47-12" data-line-number="12">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> a</a>
<a class="sourceLine" id="cb47-13" data-line-number="13">    <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">Or</span> p q a)</a></code></pre></div>
<p>These functions actually demonstrate, I feel, why <code>Decision</code> having both a <code>Proved a</code> and <code>Disproved (Refuted a)</code> branch is very useful. This is because, if you wrote the <em>structure</em> of <code>And</code> and <code>Or</code> correctly, it’s <em>impossible</em> to incorrectly define <code>decideAnd</code> and <code>decideOr</code>. You can’t accidentally say false when it’s true, or true when it’s false — your implementation is guarunteed correct.</p></li>
<li><p>Now let’s use <code>And</code> and <code>Or</code> to prove some useful facts about <code>Knockable</code> and <code>('Opened :~:)</code>. We know that it’s impossible for something to be both <code>Knockable</code> <em>and</em> <code>('Opened :~:)</code> (that is, both knockable <em>and</em> equal to <code>'Opened</code>). Write such a witness:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L150-L152</span></a>
<a class="sourceLine" id="cb48-2" data-line-number="2"></a>
<a class="sourceLine" id="cb48-3" data-line-number="3">knockableNotOpened</a>
<a class="sourceLine" id="cb48-4" data-line-number="4"><span class="ot">    ::</span> forall s<span class="fu">.</span> <span class="dt">SingI</span> s</a>
<a class="sourceLine" id="cb48-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">Refuted</span> (<span class="dt">And</span> <span class="dt">Knockable</span> ((<span class="fu">:~:</span>) &#39;<span class="dt">Opened</span>) s)</a></code></pre></div>
<p>We also know that a given <code>DoorState</code> is either <code>Knockable</code> or <code>('Opened :~:)</code>…there’s no in-between. Write such a witness:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L157-L159</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2"></a>
<a class="sourceLine" id="cb49-3" data-line-number="3">knockableOrOpened</a>
<a class="sourceLine" id="cb49-4" data-line-number="4"><span class="ot">    ::</span> forall s<span class="fu">.</span> <span class="dt">SingI</span> s</a>
<a class="sourceLine" id="cb49-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">Or</span> <span class="dt">Knockable</span> ((<span class="fu">:~:</span>) &#39;<span class="dt">Opened</span>) s</a></code></pre></div></li>
</ol>
<p>Solutions available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L119-L163">here</a>!</p></li>
<li><p>Instead of creating an entire <code>Knocked</code> type, we could have just said “as long as the door is not <code>'Opened</code>, you can knock”. This means we could write <code>knock</code> as:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="ot">knock ::</span> <span class="dt">Refuted</span> (s <span class="fu">:~:</span> &#39;<span class="dt">Opened</span>) <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>Which we must pass a proof that <code>s</code> is not equal to <code>'Opened</code> in order to open our door.</p>
<p>Is this really the same thing? Is <code>Refuted (s :~: 'Opened)</code> the same thing as <code>Knockable s</code>?</p>
<p>Let’s try to say that the two things are the same! Write the following functions to show that <code>Refuted (s :~: 'Opened)</code> is the same logical predicate as <code>Knockable s</code>!</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L166-L177</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2"></a>
<a class="sourceLine" id="cb51-3" data-line-number="3">knockedRefute</a>
<a class="sourceLine" id="cb51-4" data-line-number="4"><span class="ot">    ::</span> forall s<span class="fu">.</span> <span class="dt">SingI</span> s</a>
<a class="sourceLine" id="cb51-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">Knockable</span> s</a>
<a class="sourceLine" id="cb51-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Refuted</span> (s <span class="fu">:~:</span> &#39;<span class="dt">Opened</span>)</a>
<a class="sourceLine" id="cb51-7" data-line-number="7"></a>
<a class="sourceLine" id="cb51-8" data-line-number="8">refuteKnocked</a>
<a class="sourceLine" id="cb51-9" data-line-number="9"><span class="ot">    ::</span> forall s<span class="fu">.</span> <span class="dt">SingI</span> s</a>
<a class="sourceLine" id="cb51-10" data-line-number="10">    <span class="ot">=&gt;</span> <span class="dt">Refuted</span> (s <span class="fu">:~:</span> &#39;<span class="dt">Opened</span>)</a>
<a class="sourceLine" id="cb51-11" data-line-number="11">    <span class="ot">-&gt;</span> <span class="dt">Knockable</span> s</a></code></pre></div>
<p>Solution available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L166-L183">here</a>!</p>
<p><em>Note:</em> <code>knockedRefute</code> is fairly straightforward, but <code>refuteKnocked</code> is definitely trickier, so don’t be discouraged!</p>
<p><em>Hint:</em> See the note about <code>absurd</code> from Exercise 2!</p></li>
<li><p>On our type level function version of <code>knock</code>, we wrote, with a constraint:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="ot">knock ::</span> (<span class="dt">StatePass</span> s <span class="fu">~</span> &#39;<span class="dt">Obstruct</span>) <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb52-2" data-line-number="2">knock d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a></code></pre></div>
<p>We can muddy the waters a bit, for fun, by having this take a proof of the constraint instead:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L186-L187</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2"></a>
<a class="sourceLine" id="cb53-3" data-line-number="3"><span class="ot">knockRefl ::</span> (<span class="dt">StatePass</span> s <span class="fu">:~:</span> &#39;<span class="dt">Obstruct</span>) <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb53-4" data-line-number="4">knockRefl _ d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a></code></pre></div>
<p>Rewrite a version of <code>knockSomeDoor</code> in terms of <code>knockRefl</code>, called <code>knockSomeDoorRefl</code>:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L189-L192</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2"></a>
<a class="sourceLine" id="cb54-3" data-line-number="3">knockSomeDoorRefl</a>
<a class="sourceLine" id="cb54-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb54-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb54-6" data-line-number="6">knockSomeDoorRefl (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span></a></code></pre></div>
<p>Remember not to use <code>knock</code>!</p>
<p>Solution available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L186-L195">here</a>.</p>
<p>Assume that <code>DoorState</code> has an instance of <code>SDecide</code>, so you can use <code>(%~)</code>. This should be derived automatically as long as you derive <code>Eq</code>:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb55-2" data-line-number="2">  data DoorState = Opened | Closed | Locked</a>
<a class="sourceLine" id="cb55-3" data-line-number="3">    deriving (Show, Eq)</a>
<a class="sourceLine" id="cb55-4" data-line-number="4">  |])</a></code></pre></div></li>
<li><p>With the function that inverts <code>Pass</code>:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb56-2" data-line-number="2">  invertPass :: Pass -&gt; Pass</a>
<a class="sourceLine" id="cb56-3" data-line-number="3">  invertPass Obstruct = Allow</a>
<a class="sourceLine" id="cb56-4" data-line-number="4">  invertPass Allow    = Obstruct</a>
<a class="sourceLine" id="cb56-5" data-line-number="5">|])</a></code></pre></div>
<p>Implement <code>knock</code> in a way that lets you knock if <code>invertPass</code> is <code>Allow</code>:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L204-L205</span></a>
<a class="sourceLine" id="cb57-2" data-line-number="2"></a>
<a class="sourceLine" id="cb57-3" data-line-number="3"><span class="ot">knockInv ::</span> (<span class="dt">InvertPass</span> (<span class="dt">StatePass</span> s) <span class="fu">~</span> &#39;<span class="dt">Allow</span>) <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb57-4" data-line-number="4">knockInv d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a></code></pre></div>
<p>And write <code>knockSomeDoor</code> in terms of it:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L207-L210</span></a>
<a class="sourceLine" id="cb58-2" data-line-number="2"></a>
<a class="sourceLine" id="cb58-3" data-line-number="3">knockSomeDoorInv</a>
<a class="sourceLine" id="cb58-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb58-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb58-6" data-line-number="6">knockSomeDoorInv (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span></a></code></pre></div>
<p>Remember again to implement it in terms of <code>knockInv</code>, <em>not</em> <code>knock</code>.</p>
<p>Solution available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L204-L213">here</a>!</p></li>
<li><p>Let’s work with a toy typeclass called <code>Cycle</code>, based on <code>Enum</code></p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb59-2" data-line-number="2">  class Cycle a where</a>
<a class="sourceLine" id="cb59-3" data-line-number="3">    next :: a -&gt; a</a>
<a class="sourceLine" id="cb59-4" data-line-number="4">    prev :: a -&gt; a</a>
<a class="sourceLine" id="cb59-5" data-line-number="5">  |])</a></code></pre></div>
<p><code>next</code> is like <code>succ</code>, but loops over to the first item after the last constructor. <code>prev</code> is like <code>pred</code>, but loops over to the last item if pred-ing the first item</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L222-L229</span></a>
<a class="sourceLine" id="cb60-2" data-line-number="2"></a>
<a class="sourceLine" id="cb60-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Cycle</span> <span class="dt">DoorState</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb60-4" data-line-number="4">    next <span class="dt">Opened</span> <span class="fu">=</span> <span class="dt">Closed</span></a>
<a class="sourceLine" id="cb60-5" data-line-number="5">    next <span class="dt">Closed</span> <span class="fu">=</span> <span class="dt">Locked</span></a>
<a class="sourceLine" id="cb60-6" data-line-number="6">    next <span class="dt">Locked</span> <span class="fu">=</span> <span class="dt">Opened</span></a>
<a class="sourceLine" id="cb60-7" data-line-number="7"></a>
<a class="sourceLine" id="cb60-8" data-line-number="8">    prev <span class="dt">Opened</span> <span class="fu">=</span> <span class="dt">Locked</span></a>
<a class="sourceLine" id="cb60-9" data-line-number="9">    prev <span class="dt">Closed</span> <span class="fu">=</span> <span class="dt">Opened</span></a>
<a class="sourceLine" id="cb60-10" data-line-number="10">    prev <span class="dt">Locked</span> <span class="fu">=</span> <span class="dt">Closed</span></a></code></pre></div>
<p>Can you manually promote this instance for <code>DoorState</code> to the type level?</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L231-L240</span></a>
<a class="sourceLine" id="cb61-2" data-line-number="2"></a>
<a class="sourceLine" id="cb61-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">PCycle</span> <span class="dt">DoorState</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb61-4" data-line-number="4"></a>
<a class="sourceLine" id="cb61-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">SCycle</span> <span class="dt">DoorState</span> <span class="kw">where</span></a></code></pre></div>
<p>Solution available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door3.hs#L222-L249">here</a>!</p></li>
</ol>
<h2 id="special-thanks">Special Thanks</h2>
<p>I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my two supporters at the “Amazing” level on <a href="https://www.patreon.com/justinle/overview">patreon</a>, Sam Stites and Josh Vera! :)</p>
<p>Thanks also to <a href="https://twitter.com/KozRoss">Koz Ross</a> for helping proofread this post!</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>All of this is ignoring the “bottom” value that is an occupant of every type in Haskell. We can use bottom to subvert pretty much all proofs in Haskell, unfortunately, so the discussion from this point forward assumes we are talking about a subset of Haskell where all values are non-bottom and all functions are total.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Thanks to <a href="https://www.reddit.com/r/haskell/comments/9kkbci/introduction_to_singletons_part_3_dependently/e70nc7k/">Darwin226 on reddit</a> for this tip!<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>Sorry to mix up similar metaphors like this! Definitely not intentional :)<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>Note, however, that we are a little lucky in our case. In the case of our implementation of <code>knock</code>, we match on a wildcard pattern, so the input proof is never evaluated.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>Really, we could just use <code>Bool</code> instead of defining a <code>Pass</code> type. We’re just going through a new type for the sake of example, and it can be useful because a type like <code>Pass</code> might potentially have even more constructors!<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>In the spirit of full disclosure, the Template Haskell also generates some other things (known as <em>defunctionalization symbols</em>), which we will be talking about in the next part of this series.<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>Note that this is a change since <em>singletons-2.4</em>. In previous versions, <code>++</code> would generate the type family <code>:++</code> and the singleton function <code>%:++</code>.<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>Double negation is not true in general, but it is true in the case that our predicate is <em>decidable</em>. That’s because <code>Decision a</code> is essentially a witness to the <a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle">excluded middle</a> for that specific predicate, from which double negation can be derived.<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p>It’s the good ol’ <a href="https://en.wikipedia.org/wiki/Principle_of_explosion">Principle of Explosion</a><a href="#fnref9" class="footnote-back">↩</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Introduction to Singletons&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html" class="tag-a-series" title="+Introduction to Singletons"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html" class="tag-a-series">+Introduction to Singletons</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/lenses-products-prisms-sums.html">Lenses embody Products, Prisms embody Sums</a> (Previous)</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introduction-to-singletons-3.html';
    this.page.identifier = 'singletons-3';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>