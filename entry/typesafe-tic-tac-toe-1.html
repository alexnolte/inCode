<!DOCTYPE HTML>
<html><head><title>Type-safe Tic Tac Toe (Part 1) · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="One problem with adoption of dependent types in everyday programming, I think, is that most examples out there are sort of small and self-contained. There aren’t too many larger-scale examples out there showing how dependent types can permeate your whole program to make everything more robust and error-free. So, this series will be implementing a type-safe tic tac toe game (a medium-scale Haskell app) that can be played both on the console (using Haskeline) and in the browser (using Miso), using some custom built AI. We will:  * Build up our core game engine, talking about what it really means to be type safe * Use our type-safe engine to build type-safe controllers (AI, GUI) This series will also be a mini-tutorial on the decidable package that I just recently released :) We will also be heavily using the singletons library. Where relevant, I will explain singletons concepts in brief. If you want a more in-depth introduction to the singletons library, however, check out my Introduction to Singletons series!"><meta property="og:type" content="article"><meta property="og:title" content="Type-safe Tic Tac Toe (Part 1)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/typesafe-tic-tac-toe-1.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/typesafe-tic-tac-toe-1.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Type-safe Tic Tac Toe (Part 1)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/ttt-1.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/typesafe-tic-tac-toe-1.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/typesafe-tic-tac-toe-1.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>One problem with adoption of dependent types in everyday programming, I think, is that most examples out there are sort of small and self-contained. There aren’t <em>too</em> many larger-scale examples out there showing how dependent types can permeate your whole program to make everything more robust and error-free.</p>
<p>So, this series will be implementing a type-safe <em>tic tac toe</em> game (a medium-scale Haskell app) that can be played both on the console (using Haskeline) and in the browser (using Miso), using some custom built AI. We will:</p>
<ol type="1">
<li>Build up our core game engine, talking about what it really means to be type safe</li>
<li>Use our type-safe engine to build type-safe controllers (AI, GUI)</li>
</ol>
<p>This series will also be a mini-tutorial on the <em><a href="https://hackage.haskell.org/package/decidable">decidable</a></em> package that I just recently released :) We will also be heavily using the <em><a href="https://hackage.haskell.org/package/singletons">singletons</a></em> library. Where relevant, I will explain singletons concepts in brief. If you want a more in-depth introduction to the <em>singletons</em> library, however, check out my <a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html">Introduction to Singletons</a> series!</p>
<h2 id="type-safety">Type-Safety</h2>
<p>First off, we should ask the question: what does it mean to be type-safe?</p>
<p>?????</p>
<h2 id="the-specification">The Specification</h2>
<p>We’re going to create a type that represents a <em>valid</em> game state. The goal is to make a GADT where you can only construct values whose types represent <em>valid</em> game states. If we have a value of this type, then we know that the game state must be valid.</p>
<p>A good way to start with this is by thinking of <em>induction rules</em> for defining a valid state.</p>
<p>We’ll say that there are two parts of a game state:</p>
<ol type="1">
<li>The current board</li>
<li>The current player</li>
</ol>
<p>and that there are two ways of “constructing” a valid state:</p>
<ol type="1">
<li>The empty board with player X is a valid state.</li>
<li><p>If we have:</p>
<ul>
<li>A valid state with board <em>b</em> and current player <em>p</em></li>
<li>The game is still in play</li>
<li>We can add a valid move by player <em>p</em> to board <em>b</em></li>
</ul>
<p>Then the result of this move represents a new valid board <em>b</em>, with swapped player <em>p</em>.</p></li>
</ol>
<p>This is a denotative way to talk about what it means for a state to be valid.</p>
<p>Note that our “type safety” is only as strong as the specification we just wrote. Type safety using dependent types isn’t omnipotent, and it can’t read your mind. However, there is a nice assurance that as long as your <em>specification</em> is right, your program will work as expected. And hey, it’s a step up from the untyped case, where you can have a specification wrong, but implement it incorrectly. With “type-safety”, you cut out one huge area where bugs come from: the implementation.</p>
<p>Alright, let’s do this!</p>
<h2 id="valid-state">Valid State</h2>
<p>First, we’ll define the types we need to specify our state:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  data Piece = PX | PO</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    deriving (Eq, Ord)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  type Board = [[Maybe Piece]]</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  |])</a></code></pre></div>
<p>A <code>Piece</code> will also represent our player – either <code>PX</code> or <code>PO</code>. Our <code>Board</code> will be a list of lists of <code>Maybe Piece</code>. If the spot contains <code>Nothing</code>, the spot is unplayed; if the spot is <code>Just p</code>, then it means the spot has been played by <code>p</code>.</p>
<p>And some values and functions we need to talk about empty boards and state transformations:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  emptyBoard :: Board</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  emptyBoard = [ [Nothing, Nothing, Nothing]</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">               , [Nothing, Nothing, Nothing]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">               , [Nothing, Nothing, Nothing]</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">               ]</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  altP :: Piece -&gt; Piece</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  altP PX = PO</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  altP PO = PX</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  |])</a></code></pre></div>
<p>Let’s just throw in a quick proof as a sanity check:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L62-L64</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">altP_cyclic ::</span> <span class="dt">Sing</span> p <span class="ot">-&gt;</span> <span class="dt">AltP</span> (<span class="dt">AltP</span> p) <span class="fu">:~:</span> p</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">altP_cyclic <span class="dt">SPX</span> <span class="fu">=</span> <span class="dt">Refl</span> <span class="fu">@</span>&#39;<span class="dt">PX</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">altP_cyclic <span class="dt">SPO</span> <span class="fu">=</span> <span class="dt">Refl</span> <span class="fu">@</span>&#39;<span class="dt">PO</span></a></code></pre></div>
<p>With that in mind, we can write our valid state constructor. We’ll do that with two helper types that we will implement later. First, we’ll use the <a href="https://hackage.haskell.org/package/decidable">decidable</a> library to talk about the kind of a <em>type-level predicate</em>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L66-L66</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">data</span> <span class="dt">InPlay</span><span class="ot"> ::</span> <span class="dt">Predicate</span> <span class="dt">Board</span></a></code></pre></div>
<p><code>InPlay</code> is a predicate that a given board is in-play; a value of type <code>InPlay @@ b</code> is a witness or proof that a board is in play.</p>
<p>We also need to define a type for a valid update by a given player onto a given board:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L81-L81</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Update</span><span class="ot"> ::</span> <span class="dt">Piece</span> <span class="ot">-&gt;</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a></code></pre></div>
<p>A value of type <code>Update p b1 b2</code> will represent a valid update to board <code>b1</code> by player <code>p</code> to create a board <code>b2</code>.</p>
<p>And finally, our valid state constructor:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L68-L79</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">data</span> <span class="dt">GameState</span><span class="ot"> ::</span> <span class="dt">Piece</span> <span class="ot">-&gt;</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="co">-- | The empty board is a valid state</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="dt">GSStart</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">        ::</span> <span class="dt">GameState</span> &#39;<span class="dt">PX</span> <span class="dt">EmptyBoard</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="co">-- | We can also construct a valid game state if we have:</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    <span class="dt">GSUpdate</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="ot">        ::</span> forall p b1 b2<span class="fu">.</span> ()</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">        <span class="ot">=&gt;</span> <span class="dt">InPlay</span>          <span class="fu">@@</span> b1     <span class="co">-- ^ a proof that b1 is in play</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">        <span class="ot">-&gt;</span> <span class="dt">Update</span>    p        b1 b2  <span class="co">-- ^ a valid update</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">        <span class="ot">-&gt;</span> <span class="dt">GameState</span> p        b1     <span class="co">-- ^ a proof that p, b1 are a valid state</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">        <span class="co">-- ---------------------------- then</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">        <span class="ot">-&gt;</span> <span class="dt">GameState</span> (<span class="dt">AltP</span> p)    b2  <span class="co">-- ^ `AltP p`, b2 is a valid satte</span></a></code></pre></div>
<p>And that’s it — a verified-correct representation of a game state, directly transcribed from our plain-language denotative specification.</p>
<p>Now we just need to talk about <code>InPlay</code> and <code>Update</code>. In particular, we need:</p>
<ol type="1">
<li>A definition of <code>Update</code>, and a way to turn user-input into a valid <code>Update</code> (or reject it if it isn’t valid).</li>
<li>A definition of <code>InPlay</code>, and a way to decide whether or not a given board <code>b</code> is <code>InPlay</code>. This is something that the appropriately named <em><a href="https://hackage.haskell.org/package/decidable">decidable</a></em> library will help us with.</li>
</ol>
<h3 id="update">Update</h3>
<p>Let’s go about what thinking about what defines a valid update. Remember, the kind we wanted was:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L81-L81</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Update</span><span class="ot"> ::</span> <span class="dt">Piece</span> <span class="ot">-&gt;</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a></code></pre></div>
<p>An <code>Update p b1 b2</code> will be a valid update of <code>b1</code> by player <code>p</code> to produce <code>b2</code>. So, we need to:</p>
<ol type="1">
<li>Produce <code>b2</code> from <code>b1</code></li>
<li>Be sure that the move is valid — namely, that it is placed in a clean spot so that it doesn’t overwrite any previous moves.</li>
</ol>
<p>Producing <code>b2</code> from <code>b1</code> is simple enough as a type family. In fact, we can just use the <em><a href="https://hackage.haskell.org/package/lens-typelevel">lens-typelevel</a></em> library to update our nested list:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">$</span>(singletonsOnly [d|</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  placeBoard :: N -&gt; N -&gt; Piece -&gt; Board -&gt; Board</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  placeBoard i j p = set (ixList i . ixList j) (Just p)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  |])</a></code></pre></div>
<p>This is just lenses — <code>set l x</code> is a function that sets the field specified by <code>l</code> to <code>x</code>. Here, we set the jth item of the ith list to be <code>Just p</code>. That means we can now produce <code>b2</code> from <code>b1</code> – it’s just <code>PlaceBoard i j p b1</code>.</p>
<p>Here, <code>N</code> is the peano nat type (a lot of libraries define it, but it’s also defined as a uility in <em>lens-typelevel</em>). It’s essentially <code>[()]</code> (which makes it useful as an index type), or:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span></a></code></pre></div>
<p>A natural number is either zero, or the successor of another natural number. <code>S (S Z)</code>, for example, would represent 2.</p>
<p>The trickier part is making sure that the spot at <em>(i, j)</em> isn’t already taken. For that, we’ll introduce a common helper type to say <em>what</em> the piece at spot <em>(i, j)</em> is:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L95-L95</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Coord</span><span class="ot"> ::</span> (<span class="dt">N</span>, <span class="dt">N</span>) <span class="ot">-&gt;</span> [[k]] <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a></code></pre></div>
<p>A <code>Coord '(i, j) xss x</code> is a data type that specifies that the jth item in the ith list in <code>b</code> is <code>p</code>.</p>
<p>And we require <code>Update</code> to only be constructable if the spot at <em>(i, j)</em> is <code>Nothing</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L81-L86</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Update</span><span class="ot"> ::</span> <span class="dt">Piece</span> <span class="ot">-&gt;</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="dt">MkUpdate</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="ot">        ::</span> forall i j p b<span class="fu">.</span> ()</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">        <span class="ot">=&gt;</span> <span class="dt">Coord</span> &#39;(i, j) b &#39;<span class="dt">Nothing</span>         <span class="co">-- ^ If the item at (i, j) in b is Nothing</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">        <span class="co">-- ------------------------------------- then</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">        <span class="ot">-&gt;</span> <span class="dt">Update</span> p b (<span class="dt">PlaceBoard</span> i j p b)  <span class="co">-- ^ Placing `Just p` at i, j is a valid update</span></a></code></pre></div>
<p><code>Update</code> is now defined so that, for <code>Update p b1 b2</code>, <code>b2</code> is the update via placement of a piece <code>p</code> at some position in <code>b1</code>, where the placement does not overwrite a previous piece. Note that our <code>MkUpdate</code> constructor only has four “free” variables, <code>i</code>, <code>j</code>, <code>p</code>, and <code>b</code>. If we use <code>MkUpdate</code>, it means that the “final board” is fully determined from only <code>i</code>, <code>j</code>, <code>p</code>, and <code>b</code>.</p>
<h4 id="coord">Coord</h4>
<p>Now we need to define <code>Coord</code>. We’re going to do that in terms of a simpler type that is essentially the same for normal lists — a type:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L88-L88</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Sel</span><span class="ot"> ::</span> <span class="dt">N</span> <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a></code></pre></div>
<p>A value of type <code>Sel n xs x</code> says that the nth item in <code>xs</code> is <code>x</code>.</p>
<p>We can define this type inductively, similar to the common <a href="http://hackage.haskell.org/package/type-combinators-0.2.4.3/docs/Data-Type-Index.html"><code>Index</code></a> data type. We can mention our induction rules:</p>
<ol type="1">
<li>The first item in a list as at index 0 (<code>Z</code>)</li>
<li>If an item is at index <code>n</code> in list <code>as</code>, then it is also at index <code>S n</code> in list <code>b ': as</code>.</li>
</ol>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L88-L93</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Sel</span><span class="ot"> ::</span> <span class="dt">N</span> <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    <span class="co">-- | The first item in a list is at index &#39;&#39;Z&#39;</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="dt">SelZ</span><span class="ot"> ::</span> <span class="dt">Sel</span> &#39;<span class="dt">Z</span> (a &#39;<span class="fu">:</span> as) a</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    <span class="dt">SelS</span><span class="ot"> ::</span> <span class="dt">Sel</span>     n        as  a  <span class="co">-- ^ If item `a` is at index `n` in list `as`</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">         <span class="co">-- ---------------------------- then</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">         <span class="ot">-&gt;</span> <span class="dt">Sel</span> (&#39;<span class="dt">S</span> n) (b &#39;<span class="fu">:</span> as) a  <span class="co">-- ^ Item `a` is at index `S n` in list `b : as`</span></a></code></pre></div>
<p>For example, for the type-level list <code>'[10,5,2,8]</code>, we can make values:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="dt">SelZ</span><span class="ot">             ::</span> <span class="dt">Sel</span>         &#39;<span class="dt">Z</span>   &#39;[<span class="dv">10</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">8</span>] <span class="dv">10</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="dt">SelS</span> <span class="dt">SelZ</span><span class="ot">        ::</span> <span class="dt">Sel</span>     (&#39;<span class="dt">S</span> &#39;<span class="dt">Z</span>)  &#39;[<span class="dv">10</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">8</span>] <span class="dv">5</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="dt">SelS</span> (<span class="dt">SelS</span> <span class="dt">SelZ</span>)<span class="ot"> ::</span> <span class="dt">Sel</span> (&#39;<span class="dt">S</span> (&#39;<span class="dt">S</span> &#39;<span class="dt">Z</span>)) &#39;[<span class="dv">10</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">8</span>] <span class="dv">2</span></a></code></pre></div>
<p>etc.</p>
<p>We can then use this to define <code>Coord</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L95-L100</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Coord</span><span class="ot"> ::</span> (<span class="dt">N</span>, <span class="dt">N</span>) <span class="ot">-&gt;</span> [[k]] <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">    (:$:) ::</span> forall i j rows row p<span class="fu">.</span> ()</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">          <span class="ot">=&gt;</span> <span class="dt">Sel</span> i rows row         <span class="co">-- ^ If the ith list in `rows` is `row`</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">          <span class="ot">-&gt;</span> <span class="dt">Sel</span> j row  p           <span class="co">-- ^ And the jth item in `row` is `p`</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">          <span class="co">-- --------------------------- then</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">          <span class="ot">-&gt;</span> <span class="dt">Coord</span> &#39;(i, j) rows p   <span class="co">-- ^ The item at (i, j) is `p`</span></a></code></pre></div>
<p>A <code>Coord '(i, j) rows piece</code> contains a selection into the ith list in <code>rows</code>, to get <code>row</code>, and a selection into the jth item in <code>row</code>, to get <code>piece</code>.</p>
<h3 id="trying-it-out">Trying it out</h3>
<p>That’s it! Let’s see if we can generate some sensible <code>Update</code>s, and maybe even play a sample game.</p>
<p>We’ll start with the <code>EmptyBoard</code>, and let’s add a piece by <code>PX</code> at the middle spot, index (1,1). This means we want <code>SelS SelZ :$: SelS SelZ</code> (a <code>Coord</code> with two indexes into spots 1 and 1) applied to <code>MkUpdate</code>. We’ll use <em>-XTypeApplications</em> to specify the type variables <code>p</code> and <code>b</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">MkUpdate</span> <span class="fu">@</span>_ <span class="fu">@</span>_ <span class="fu">@</span>&#39;<span class="dt">PX</span> <span class="fu">@</span><span class="dt">EmptyBoard</span> (<span class="dt">SelS</span> <span class="dt">SelZ</span> <span class="fu">:$:</span> <span class="dt">SelS</span> <span class="dt">SelZ</span>)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="dt">Update</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  &#39;<span class="dt">PX</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  &#39;[ &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span>],</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">     &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span>],</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">     &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span>]</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">   ]</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">  &#39;[ &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span>],</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">     &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Just</span> &#39;<span class="dt">PX</span>, &#39;<span class="dt">Nothing</span>],</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">     &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span>]</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  ]</a></code></pre></div>
<p>Nice! This update produces exactly he board expected.</p>
<p>Let’s see if we can see if this prevents us from creating an illegal board. We’ll take the result board and see if we can place a <code>PO</code> piece there:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="kw">let</span> <span class="dt">NewBoard</span> <span class="fu">=</span> &#39;[ &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span> ]</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">                      , &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Just</span> &#39;<span class="dt">PX</span>, &#39;<span class="dt">Nothing</span> ]</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">                      , &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span> ]</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">                      ]</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">ghci<span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">MkUpdate</span> <span class="fu">@</span>_ <span class="fu">@</span>_ <span class="fu">@</span>&#39;<span class="dt">PO</span> <span class="fu">@</span><span class="dt">NewBoard</span> (<span class="dt">SelS</span> <span class="dt">SelZ</span> <span class="fu">:$:</span> <span class="dt">SelS</span> <span class="dt">SelZ</span>)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    • <span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> ‘&#39;<span class="dt">Nothing</span>’ with ‘&#39;<span class="dt">Just</span> &#39;<span class="dt">PX</span>’</a></code></pre></div>
<p>Right! That’s because <code>SelS SelZ :&amp;: SelS SellZ</code>, applied to <code>NewBoard</code>, gives <code>Coord '('S 'Z, 'S 'Z) NewBoard ('Just 'PX)</code>. However, in order to be used with <code>MkUpdate</code>, the final field has to be <code>'Nothing</code>, not <code>'Just 'PX</code>. So, type error.</p>
<h3 id="type-safe-play">Type-safe Play</h3>
<p>At the end of this all, we finally have enough to write a truly type-safe <code>play</code> function that allows us to play a round of our game!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L102-L108</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">play</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="ot">    ::</span> forall i j p b<span class="fu">.</span> ()</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">InPlay</span> <span class="fu">@@</span> b</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Coord</span> &#39;(i, j) b &#39;<span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">GameState</span> p b</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">    <span class="ot">-&gt;</span> <span class="dt">GameState</span> (<span class="dt">AltP</span> p) (<span class="dt">PlaceBoard</span> i j p b)</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">play r c <span class="fu">=</span> <span class="dt">GSUpdate</span> r (<span class="dt">MkUpdate</span> c)</a></code></pre></div>
<p><code>play</code> is basically the entirety of our game engine! (Minus defining <code>InPlay</code>, which we will take care of later). It’ll take our new move and a proof that the game is still in play, and return a updated new game state. Our entire game is done, and type-safe! It’s impossible to play a game in an incorrect way! (once we define <code>InPlay</code>).</p>
<p>Let’s try out a few rounds in ghci, using <code>undefined</code> instead of a proper <code>InPlay</code> for now:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">ghci<span class="fu">&gt;</span> g1 <span class="fu">=</span> play undefined (<span class="dt">SelS</span> <span class="dt">SelZ</span> <span class="fu">:$:</span> <span class="dt">SelS</span> <span class="dt">SelZ</span>) <span class="dt">GSStart</span>   <span class="co">-- X plays (1,1)</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t g1</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="dt">GameState</span> &#39;<span class="dt">PO</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    &#39;[ &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span>]</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">     , &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Just</span> &#39;<span class="dt">PX</span>, &#39;<span class="dt">Nothing</span>]</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">     , &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span>]</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">     ]</a>
<a class="sourceLine" id="cb19-8" data-line-number="8"></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">ghci<span class="fu">&gt;</span> g2 <span class="fu">=</span> play undefined (<span class="dt">SelZ</span> <span class="fu">:$:</span> <span class="dt">SelS</span> <span class="dt">SelZ</span>) g1   <span class="co">-- O plays (0,1)</span></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t g2</a>
<a class="sourceLine" id="cb19-11" data-line-number="11"><span class="dt">GameState</span> &#39;<span class="dt">PX</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">    &#39;[ &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Just</span> &#39;<span class="dt">PO</span>, &#39;<span class="dt">Nothing</span>]</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">     , &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Just</span> &#39;<span class="dt">PX</span>, &#39;<span class="dt">Nothing</span>]</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">     , &#39;[ &#39;<span class="dt">Nothing</span>, &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span>]</a>
<a class="sourceLine" id="cb19-15" data-line-number="15">     ]</a>
<a class="sourceLine" id="cb19-16" data-line-number="16"></a>
<a class="sourceLine" id="cb19-17" data-line-number="17">ghci<span class="fu">&gt;</span> g3 <span class="fu">=</span> play undefined (<span class="dt">SelZ</span> <span class="fu">:$:</span> <span class="dt">SelS</span> <span class="dt">SelZ</span>) g2   <span class="co">-- X plays (1,0)</span></a>
<a class="sourceLine" id="cb19-18" data-line-number="18">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t g3</a>
<a class="sourceLine" id="cb19-19" data-line-number="19"><span class="dt">GameState</span> &#39;<span class="dt">PO</span></a>
<a class="sourceLine" id="cb19-20" data-line-number="20">    &#39;[ &#39;[ &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Just</span> &#39;<span class="dt">PO</span>, &#39;<span class="dt">Nothing</span>]</a>
<a class="sourceLine" id="cb19-21" data-line-number="21">     , &#39;[ &#39;<span class="dt">Just</span> &#39;<span class="dt">PX</span>, &#39;<span class="dt">Just</span> &#39;<span class="dt">PX</span>, &#39;<span class="dt">Nothing</span>]</a>
<a class="sourceLine" id="cb19-22" data-line-number="22">     , &#39;[ &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span> , &#39;<span class="dt">Nothing</span>]</a>
<a class="sourceLine" id="cb19-23" data-line-number="23">     ]</a>
<a class="sourceLine" id="cb19-24" data-line-number="24"></a>
<a class="sourceLine" id="cb19-25" data-line-number="25">ghci<span class="fu">&gt;</span> g4 <span class="fu">=</span> play undefined (<span class="dt">SelS</span> <span class="dt">SelZ</span> <span class="fu">:$:</span> <span class="dt">SelS</span> <span class="dt">SelZ</span>) g3   <span class="co">-- O plays (1,1)</span></a>
<a class="sourceLine" id="cb19-26" data-line-number="26">    • <span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> ‘&#39;<span class="dt">Just</span> &#39;<span class="dt">PX</span>’ with ‘&#39;<span class="dt">Nothing</span>’</a>
<a class="sourceLine" id="cb19-27" data-line-number="27"></a>
<a class="sourceLine" id="cb19-28" data-line-number="28">ghci<span class="fu">&gt;</span> g4 <span class="fu">=</span> play undefined (<span class="dt">SelS</span> (<span class="dt">SelS</span> (<span class="dt">SelS</span> <span class="dt">SelZ</span>)) <span class="fu">:$:</span> <span class="dt">SelZ</span>) g3  <span class="co">-- O plays (3,0)</span></a>
<a class="sourceLine" id="cb19-29" data-line-number="29">    • <span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> ‘&#39;[]’ with ‘&#39;<span class="dt">Nothing</span> &#39;<span class="fu">:</span> as’</a></code></pre></div>
<p><code>play</code> enforces:</p>
<ol type="1">
<li>Turns are always alternating X, then O</li>
<li>We cannot place a piece in a previously-played spot</li>
<li>We cannot place a piece out-of-bounds.</li>
</ol>
<h2 id="decision-functions-and-views">Decision Functions and Views</h2>
<p>This seems nice, but we’re forgetting an important part. <code>play</code> requires us to only give valid inputs, and enforces that the inputs are valid. However, how do we <em>create</em> valid inputs, in a way that satisfies <code>play</code>?</p>
<p>As we’ll see, this is one of the core problems that dependently typed programming gives us tools to solve.</p>
<p>At this point, we’ve reached the important part of any “type-safe” application: <em>decision functions</em> and dependent <em>views</em>. <em>Decision functions</em> let you slowly refine your more general values (types) into more specific valid types. <em>Views</em> let you sort out your our values into more “useful” perspectives.</p>
<p>We’re going to allow for users to pick to move at any natural number pair (<code>(N, N)</code>), but only <em>some</em> of those natural numbers can become valid updates. In particular, we only allow an <code>Update</code> to be made if <code>(N, N)</code> represent valid updates.</p>
<p>What are two ways this can go wrong? Well, if we allow the user to enter any two natural numbers, here are all of the potential outcomes:</p>
<ol type="1">
<li>We might get a coordinate that is out of bounds in x</li>
<li>We might get a coordinate that is in bounds in x, but out of bounds in y</li>
<li>We might get a coordinate that is in bounds in x, in bounds in y, but referencing a position that has already been played.</li>
<li>We might get a coordinate that is in bounds in x, in bounds in y, and references a blank position. This is the only “success” case.</li>
</ol>
<p>Note that we could also just have a “success or nor success” situation, but, because we might want to provide feedback to the user, it is helpful to not be “<a href="https://twitter.com/cattheory/status/887760004622757890">decision-blind</a>” (a cousin of <a href="https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/">boolean blindness</a>).</p>
<p>We’ll call these potential “views” out of <code>(N, N)</code> with respect to some board <code>b</code>. Let’s create a data type representing all of these possibilities (using <code>OutOfBounds</code> as a placeholder predicate for an out-of-bounds coordinate):</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co">-- | Placeholder predicate if a given number `n` is out of bounds for a given</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="co">-- list</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">data</span> <span class="dt">OutOfBounds</span><span class="ot"> n ::</span> <span class="dt">Predicate</span> [k]</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L115-L125</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Pick</span><span class="ot"> ::</span> (<span class="dt">N</span>, <span class="dt">N</span>, <span class="dt">Board</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    <span class="co">-- | We are out of bounds in x</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">    <span class="dt">PickOoBX</span><span class="ot">   ::</span> <span class="dt">OutOfBounds</span> i <span class="fu">@@</span> b                         <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">    <span class="co">-- | We are in-bounds in x, but out of bounds in y</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">    <span class="dt">PickOoBY</span><span class="ot">   ::</span> <span class="dt">Sel</span> i b row        <span class="ot">-&gt;</span> <span class="dt">OutOfBounds</span> j <span class="fu">@@</span> row <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">    <span class="co">-- | We are in-bounds in x, in-bounds in y, but spot is taken by `p`.</span></a>
<a class="sourceLine" id="cb20-13" data-line-number="13">    <span class="co">-- We include `Sing p` in this constructor to potentially provide</span></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">    <span class="co">-- feedback to the user on what piece is already in the spot.</span></a>
<a class="sourceLine" id="cb20-15" data-line-number="15">    <span class="dt">PickPlayed</span><span class="ot"> ::</span> <span class="dt">Coord</span> &#39;(i, j) b (&#39;<span class="dt">Just</span> p) <span class="ot">-&gt;</span> <span class="dt">Sing</span> p        <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a>
<a class="sourceLine" id="cb20-16" data-line-number="16">    <span class="co">-- | We are in-bounds in x, in-bounds in y, and spot is clear</span></a>
<a class="sourceLine" id="cb20-17" data-line-number="17">    <span class="dt">PickValid</span><span class="ot">  ::</span> <span class="dt">Coord</span> &#39;(i, j) b &#39;<span class="dt">Nothing</span>                   <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a></code></pre></div>
<p>So, if we have an <code>(N, N, Board)</code>, we should be able to categorize it into one of each of these potential views.</p>
<p>This is the job of a “decision function”; in this case, actually, a “proving function”. We need to be able to write a function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">pick ::</span> forall i j b<span class="fu">.</span> ()</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">     <span class="ot">=&gt;</span> <span class="dt">Sing</span> &#39;(i, j, b) <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a></code></pre></div>
<p>That is, given any coordinate and board, we should be able to <em>totally</em> categorize it to one of the four categories, without exception.</p>
<p>This can be considered the boundary between the unsafe and the safe world. And, to me, this is the “hard part” about dependently typed programming :)</p>
<p>We can write this by scratch, by hand, but we’re going to look at a couple of useful tools from the <em>decidable</em> library to help us.</p>
<h2 id="the-decidable-library">The Decidable Library</h2>
<p>The <em><a href="https://hackage.haskell.org/package/decidable">decidable</a></em> library offers a couple of conceptual tools to work with views and predicates. Here’s a quick run-down:</p>
<p>The main type that the library works with is <code>Predicate</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Predicate</span> k <span class="fu">=</span> k <span class="fu">~&gt;</span> <span class="dt">Type</span></a></code></pre></div>
<p><code>k ~&gt; Type</code> is the kind of a <em>defunctionalization symbol</em> — it’s a dummy data type that can be passed around, and represents a function <code>k ~&gt; Type</code> that can be “applied” using <code>Apply</code> or <code>@@</code>. We say that, for predicate <code>MyPred</code>, we define:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> <span class="dt">MyPred</span> x <span class="fu">=</span> <span class="dt">MyWitness</span></a></code></pre></div>
<p>Where <code>MyWitness</code> is the witness for the type-level predicate <code>MyPred</code>. We can define a predicate from scratch by declaring the above type family instance, but the library is defined so that you rarely ever have to define a <code>Predicate</code> by hand. Usually, we can use predicate “combinators”, to construct predicates from simpler pieces.</p>
<p>For example, we have the <code>TyPred</code> combinator:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="dt">TyPred</span><span class="ot"> ::</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> k</a></code></pre></div>
<p>It turns a normal <code>k -&gt; Type</code> type constructor into a <code>Predicate k</code>. So, we can use <code>Pick :: (N, N, Board) -&gt; Type</code></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">TyPred</span> <span class="dt">Pick</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="dt">Predicate</span> (<span class="dt">N</span>, <span class="dt">N</span>, <span class="dt">Board</span>)</a></code></pre></div>
<p><code>TyPred Pick</code> is a predicate that, given a coordinate and a board, we can create a valid <code>Pick</code> using one of the <code>Pick</code> constructors.</p>
<h3 id="provable">Provable</h3>
<p><em>decidable</em> makes this a little nicer to work with by providing a typeclass for predicates with “canonical” viewing functions, called <code>Provable</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="co">-- | Class providing a canonical proving function or view for predicate `p`.</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="kw">class</span> <span class="dt">Provable</span> p <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="co">-- | Given any `x`, produce the witness `p @@ x`.</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="ot">    prove ::</span> forall x<span class="fu">.</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> (p <span class="fu">@@</span> x)</a></code></pre></div>
<p>The benefit of using a typeclass is that we can associate a canonical proving/viewing function with a consistent name, and also so that higher-order predicate combinators can build proving functions based on proving functions of the predicates they are parameterized on.</p>
<p>In our case, writing a view function would look like this:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Provable</span> (<span class="dt">TyPred</span> <span class="dt">Pick</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="ot">    prove ::</span> <span class="dt">Sing</span> ijb <span class="ot">-&gt;</span> <span class="dt">Pick</span> ijb</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">    prove (<span class="dt">STuple3</span> i j b) <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">        <span class="co">-- ^ STuple3 is the singleton for three-tuples</span></a></code></pre></div>
<p>Then, given any <code>(i, j, b)</code> combination, we can classify it into one of the constructors of <code>Pick</code> by just using <code>prove @(TyPred Pick) sIJB</code>.</p>
<p>Now that we’ve restated things in the context of <em>decidable</em>…how do we actually write <code>prove @(TyPred Pick)</code>?</p>
<p>Well, remember that a <em>succcesful</em> <code>Pick</code> contains a <code>Sel i b row</code> and a <code>Sel j row p</code>. We need to somehow take an <code>i :: N</code> and turn it into a <code>Sel i b row</code>, and take a <code>j :: N</code> and turn it into a <code>Sel j row p</code>. We need to “convert” a <code>N</code> into some <code>Sel</code>, in a way that could potentially fail.</p>
<h3 id="parampred">ParamPred</h3>
<p>Another useful kind synonym that <em>decidable</em> gives is in <em>Data.Type.Predicate.Param</em>, the “parameterized predicate”:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ParamPred</span> k v <span class="fu">=</span> k <span class="ot">-&gt;</span> <span class="dt">Predicate</span> v</a></code></pre></div>
<p>If <code>MyPP :: ParamPred k v</code> is a parameterized predicate, then <code>MyPP x</code> is a <code>Predicate v</code>.</p>
<p>The main usage of parameterized predicate is for usage with the <code>Found</code> predicate combinator:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="dt">Found</span><span class="ot"> ::</span> <span class="dt">ParamPred</span> k v <span class="ot">-&gt;</span> <span class="dt">Predicate</span> k</a></code></pre></div>
<p><code>Found MyPP</code> is a predicate that, for any <code>x :: k</code>, we can find <em>some</em> <code>y :: v</code> that satisfies <code>MyPP x @@ y</code>.</p>
<p>Again, the library is constructed so that you shouldn’t need to define a <code>ParamPred</code> by hand; you can just use combinators and constructors.</p>
<p>For example, we have <code>TyPP</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="dt">TyPP</span><span class="ot"> ::</span> (k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">ParamPred</span> k v</a></code></pre></div>
<p>Which turns any normal type constructor into a <code>ParamPred</code>. For example, let’s look at <code>Sel 'Z</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">TyPP</span> (<span class="dt">Sel</span> &#39;<span class="dt">Z</span>)</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="dt">ParamPred</span> [k] k</a></code></pre></div>
<p><code>TyPP (Sel 'Z)</code> is the parameterized predicate that, given a list <code>xs :: [k]</code>, we can produce an <code>x :: k</code> that is at index <code>'Z</code>. That’s because its witness is <code>Sel 'Z xs x</code> (the witness that <code>x</code> is at position <code>'Z</code> in <code>xs</code>).</p>
<p>What is <code>Found (TyPP (Sel 'Z))</code>?</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">Found</span> (<span class="dt">TyPP</span> (<span class="dt">Sel</span> &#39;<span class="dt">Z</span>))</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="dt">Predicate</span> [k]</a></code></pre></div>
<p>Judging from the type, it is some predicate on a type level list. And knowing what we know about <code>Found</code>, we can conclude what it is: It is a predicate that, given some list <code>xs</code>, there <em>is some value <code>x</code></em> at position <code>'Z</code>. It’s essentially a predicate that the list <em>has</em> something at position <code>'Z</code>.</p>
<p>We can generalize it further; <code>Found (TyPP (Sel ('S 'Z)))</code> must be the predicate that some given list <code>xs</code> has a value <code>x</code> at position <code>'S 'Z</code>. It says that there must be <em>some</em> value at <code>'S 'Z</code>.</p>
<p>Really, <code>Found (TyPP (Sel n))</code> is a predicate that some list <code>xs</code> is <em>at least</em> <code>n + 1</code> items long. That’s because we know that the list has to have some item at position <code>n</code>.</p>
<p>There’s a better name for this — we’ll call it <code>InBounds</code></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L110-L110</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2"></a>
<a class="sourceLine" id="cb33-3" data-line-number="3"><span class="kw">type</span> <span class="dt">InBounds</span>    n <span class="fu">=</span> <span class="dt">Found</span> (<span class="dt">TyPP</span> (<span class="dt">Sel</span> n))</a></code></pre></div>
<p><code>InBounds n :: Predicate [k]</code> is the predicate that, given some list <code>xs</code>, <code>n</code> is “in bounds” of <code>xs</code>.</p>
<p>And <em>decidable</em> is nice because it offers a predicate combinator <code>Not</code>, which gives the negation of any predicate:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L112-L112</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"></a>
<a class="sourceLine" id="cb34-3" data-line-number="3"><span class="kw">type</span> <span class="dt">OutOfBounds</span> n <span class="fu">=</span> <span class="dt">Not</span> (<span class="dt">InBounds</span> n)</a></code></pre></div>
<p><code>OutOfBounds n :: Predicate [k]</code> is the predicate that, given some list <code>xs</code>, <code>n</code> is <em>not</em> in bounds of <code>xs</code>, and that it is actually <em>out</em> of bounds.</p>
<h3 id="decidable">Decidable</h3>
<p>Now, is <code>InBounds n</code> going to be <code>Provable</code>? No, not quite. That’s because a given list <code>xs</code> might be actually out of bounds. For example, <code>InBounds 'Z @@ '[1,2,3]</code> is satisfiable, but <code>InBounds ('S 'Z) '[]</code> is not.</p>
<p>To implement our view of <code>Pick</code>, we would like a function that can <em>decide</em> whether or not <code>InBounds n</code> is satisfied by a given list <code>xs</code>. What we want is a <em>decision function</em>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">inBounds ::</span> forall n xs<span class="fu">.</span> ()</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">         <span class="ot">=&gt;</span> <span class="dt">Sing</span> xs</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">         <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> n <span class="fu">@@</span> xs)</a></code></pre></div>
<p>Remember that <code>Decision</code> is a data type that is kind of like <code>Maybe</code>, but with a “disproof” if the input is disprovable:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Decision</span> a</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Proved</span>     a                <span class="co">-- ^ `a` is provably true</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Disproved</span> (a <span class="ot">-&gt;</span> <span class="dt">Void</span>)       <span class="co">-- ^ `a` is provably false</span></a>
<a class="sourceLine" id="cb36-4" data-line-number="4"></a>
<a class="sourceLine" id="cb36-5" data-line-number="5"><span class="co">-- | The type with no constructors.  If we have a function `a -&gt; Void`, it must</span></a>
<a class="sourceLine" id="cb36-6" data-line-number="6"><span class="co">-- mean that no value of type `a` exists.</span></a>
<a class="sourceLine" id="cb36-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Void</span></a></code></pre></div>
<p>The <em>decidable</em> library offers a typeclass for a <em>canonical</em> decision function for any <code>Predicate</code>:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="co">-- | Class providing a canonical decision function for predicate `p`.</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="kw">class</span> <span class="dt">Decidable</span> p <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">    <span class="co">-- | Given any `x`, either prove or disprove the witness `p @@ x`.</span></a>
<a class="sourceLine" id="cb37-4" data-line-number="4"><span class="ot">    decide ::</span> forall x<span class="fu">.</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Decision</span> (p <span class="fu">@@</span> x)</a></code></pre></div>
<p>Of course, we could always just write our decision function <code>inBounds</code> from scratch, but it’s convenient to pull everything into a typeclass instead for the reasons discussed earlier.</p>
<h3 id="deciding-inbounds">Deciding InBounds</h3>
<p>Alright, time to write our first bona-fide decision function for <code>InBounds</code>, which we will use to write our view function for <code>Pick</code>.</p>
<p>The decision function requires us to produce a witness for <code>InBounds n @@ xs</code>…so we need to know what that witness looks like.</p>
<p>To do this, we could either look at the documentation for <code>Found</code> (because <code>InBounds n = Found (TyPP (Sel n))</code>) to find its <code>Apply</code> instance, or we could just ask GHC what this looks like for a given input, using <code>:kind!</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">InBounds</span> &#39;<span class="dt">Z</span> <span class="fu">@@</span> &#39;[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]  <span class="co">-- what is the type of the witness for `InBounds &#39;Z1 ?</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2">Σ <span class="dt">Nat</span> (<span class="dt">TyPP</span> (<span class="dt">Sel</span> &#39;<span class="dt">Z</span>) &#39;[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</a></code></pre></div>
<p>In general, the witness for <code>Found (p :: ParamPred k v)</code> is:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> (<span class="dt">Found</span> p) x <span class="fu">=</span> Σ v (p x)</a></code></pre></div>
<p><code>Σ</code> might seem a little scary, but remember that it’s a type synonym for the dependent pair <code>Sigma</code> type, from <em>Data.Singletons.Sigma</em>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Sigma</span><span class="ot"> k ::</span> (k <span class="fu">~&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="ot">    (:&amp;:) ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> (f <span class="fu">@@</span> x) <span class="ot">-&gt;</span> <span class="dt">Sigma</span> k f</a>
<a class="sourceLine" id="cb40-3" data-line-number="3"></a>
<a class="sourceLine" id="cb40-4" data-line-number="4"><span class="kw">type</span> Σ k <span class="fu">=</span> <span class="dt">Sigma</span> k</a></code></pre></div>
<p>I wrote a small mini-tutorial on <code>Sigma</code> <a href="https://blog.jle.im/entry/introduction-to-singletons-4.html#sigma">here</a>, if you need a refresher. Basically, if we had <code>f :: k ~&gt; Type</code>, then <code>Sigma k f</code> contains an <code>f @@ x</code>, for some <code>x</code>, along with <code>Sing x</code> (to help us recover what <code>x</code> was, once we pattern match). It’s a <em>dependent pair</em> or <em>dependent sum</em> type. You can think of it as <code>Sigma k f</code> existentially <em>wrapping</em> <code>x :: k</code>, to show that there is at least some <code>x</code> somewhere out there such that <code>f @@ x</code> exists.</p>
<p>This makes a lot of sense as a witness to <code>Found p</code>. <code>Found p @@ x</code> says that there is some <code>y</code> such that <code>p x @@ y</code> is satisfied. So, what is the witness of that statement? The <code>y</code> itself! (wrapped in a <code>Σ</code>)</p>
<p>So, the witness for <code>InBounds 'Z @@ '[ 'True, 'False ]</code> is the item in the list <code>'[1,2,3]</code> at position <code>'Z</code> — <code>'True</code>. Let’s see this in action:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="ot">inBoundsTest1 ::</span> <span class="dt">InBounds</span> &#39;<span class="dt">Z</span> <span class="fu">@@</span> &#39;[ &#39;<span class="dt">True</span>, &#39;<span class="dt">False</span> ]</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">inBoundsTest1 <span class="fu">=</span> <span class="dt">STrue</span> <span class="fu">:&amp;:</span> <span class="dt">SelZ</span></a>
<a class="sourceLine" id="cb41-3" data-line-number="3">                       <span class="co">-- ^ Sel &#39;Z &#39;[ &#39;True, &#39;False ] &#39;True</span></a></code></pre></div>
<p>Note that we can’t put <code>SFalse</code> in <code>inBoundsTest1</code>, because the second half <code>SelZ</code> would be <code>Sel :: 'Z '[ 'True, 'False ] 'True</code> (because <code>'True</code> is the 0th item in the list), so we have to have the first half match <code>'True</code>.</p>
<p>And we can write a witness for <code>InBounds ('S 'Z) @@ '[ 'True, 'False ]</code>, as well, by giving the value of the list at index 1, <code>'False</code>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">inBoundsTest2 ::</span> <span class="dt">InBounds</span> (&#39;<span class="dt">S</span> &#39;<span class="dt">Z</span>) <span class="fu">@@</span> &#39;[ &#39;<span class="dt">True</span>, &#39;<span class="dt">False</span> ]</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">inBoundsTest2 <span class="fu">=</span> <span class="dt">SFalse</span> <span class="fu">:&amp;:</span> <span class="dt">SelS</span> <span class="dt">SelZ</span></a>
<a class="sourceLine" id="cb42-3" data-line-number="3">                        <span class="co">-- ^ Sel (&#39;S &#39;Z) &#39;[ &#39;True, &#39;False ] &#39;False</span></a></code></pre></div>
<p>With that in mind, let’s write our decision function for <code>InBounds n</code>. It’s going to be our actual first dependently typed function!</p>
<p>For the sake of learning, we’re going to write it as a standalone function <code>inBounds</code>. It’s going to take <code>Sing n</code> (the index) and <code>Sing xs</code> (the list) and produce a decision on <code>InBounds n @@ xs</code>. Like for any Haskell function on ADTs, we’ll start out by just writing all of our case statement branches (using <em>-XLambdaCase</em> for conciseness). An <code>N</code> can either be <code>Z</code> or <code>S n</code>, so we match on singletons <code>SZ</code> and <code>SS</code>. A <code>[a]</code> can either be <code>[]</code> or <code>x : xs</code>, so we match on singletons <code>SNil</code> and <code>x `SCons` xs</code></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="ot">inBounds ::</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> <span class="dt">Sing</span> xs <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> n <span class="fu">@@</span> xs)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">inBounds <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb43-3" data-line-number="3">    <span class="dt">SZ</span> <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb43-4" data-line-number="4">      <span class="dt">SNil</span>         <span class="ot">-&gt;</span> _</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">      x <span class="ot">`SCons`</span> xs <span class="ot">-&gt;</span> _</a>
<a class="sourceLine" id="cb43-6" data-line-number="6">    <span class="dt">SS</span> n <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb43-7" data-line-number="7">      <span class="dt">SNil</span>         <span class="ot">-&gt;</span> _</a>
<a class="sourceLine" id="cb43-8" data-line-number="8">      x <span class="ot">`SCons`</span> xs <span class="ot">-&gt;</span> _</a></code></pre></div>
<p>Okay, four cases. Initially daunting, but we can just handle this one by one. Again, for learning’s sake, ket’s split these branches into four helper functions — one for each case.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L131-L159</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2"></a>
<a class="sourceLine" id="cb44-3" data-line-number="3"><span class="ot">inBounds ::</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> <span class="dt">Sing</span> xs <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> n <span class="fu">@@</span> xs)</a>
<a class="sourceLine" id="cb44-4" data-line-number="4">inBounds <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb44-5" data-line-number="5">    <span class="dt">SZ</span> <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb44-6" data-line-number="6">      <span class="dt">SNil</span>         <span class="ot">-&gt;</span> inBounds_znil</a>
<a class="sourceLine" id="cb44-7" data-line-number="7">      x <span class="ot">`SCons`</span> xs <span class="ot">-&gt;</span> inBounds_zcons x xs</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">    <span class="dt">SS</span> n <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb44-9" data-line-number="9">      <span class="dt">SNil</span>         <span class="ot">-&gt;</span> inBounds_snil n</a>
<a class="sourceLine" id="cb44-10" data-line-number="10">      x <span class="ot">`SCons`</span> xs <span class="ot">-&gt;</span> inBounds_scons n x xs</a>
<a class="sourceLine" id="cb44-11" data-line-number="11"></a>
<a class="sourceLine" id="cb44-12" data-line-number="12">inBounds_znil</a>
<a class="sourceLine" id="cb44-13" data-line-number="13"><span class="ot">    ::</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> &#39;<span class="dt">Z</span> <span class="fu">@@</span> &#39;[])</a>
<a class="sourceLine" id="cb44-14" data-line-number="14"></a>
<a class="sourceLine" id="cb44-15" data-line-number="15">inBounds_zcons</a>
<a class="sourceLine" id="cb44-16" data-line-number="16"><span class="ot">    ::</span> <span class="dt">Sing</span> x</a>
<a class="sourceLine" id="cb44-17" data-line-number="17">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> xs</a>
<a class="sourceLine" id="cb44-18" data-line-number="18">    <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> &#39;<span class="dt">Z</span> <span class="fu">@@</span> (x &#39;<span class="fu">:</span> xs))</a>
<a class="sourceLine" id="cb44-19" data-line-number="19"></a>
<a class="sourceLine" id="cb44-20" data-line-number="20">inBounds_snil</a>
<a class="sourceLine" id="cb44-21" data-line-number="21"><span class="ot">    ::</span> <span class="dt">Sing</span> n</a>
<a class="sourceLine" id="cb44-22" data-line-number="22">    <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> (&#39;<span class="dt">S</span> n) <span class="fu">@@</span> &#39;[])</a>
<a class="sourceLine" id="cb44-23" data-line-number="23"></a>
<a class="sourceLine" id="cb44-24" data-line-number="24">inBounds_scons</a>
<a class="sourceLine" id="cb44-25" data-line-number="25"><span class="ot">    ::</span> <span class="dt">Sing</span> n</a>
<a class="sourceLine" id="cb44-26" data-line-number="26">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> x</a>
<a class="sourceLine" id="cb44-27" data-line-number="27">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> xs</a>
<a class="sourceLine" id="cb44-28" data-line-number="28">    <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> (&#39;<span class="dt">S</span> n) <span class="fu">@@</span> (x &#39;<span class="fu">:</span> xs))</a></code></pre></div>
<ol type="1">
<li><p>For the first branch, we have <code>'Z</code> and <code>'[]</code>. This should be false, because there is no item in the zeroth position in <code>[]</code>. But, also, there is no way to construct the <code>Sel</code> necessary for the witness, since there is no constructor for <code>Sel</code> that gives <code>'[]</code>.</p>
<p>So we can write this as <code>Disproved</code>, which takes a <code>InBounds 'Z @@ '[] -&gt; Void</code>:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L140-L142</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2"></a>
<a class="sourceLine" id="cb45-3" data-line-number="3">inBounds_znil</a>
<a class="sourceLine" id="cb45-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> &#39;<span class="dt">Z</span> <span class="fu">@@</span> &#39;[])</a>
<a class="sourceLine" id="cb45-5" data-line-number="5">inBounds_znil <span class="fu">=</span> <span class="dt">Disproved</span> <span class="fu">$</span> \(_ <span class="fu">:&amp;:</span> s) <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span> {}</a></code></pre></div>
<p>We can satisfy that <code>InBounds 'Z @@ '[] -&gt; Void</code> by pattern matching on the <code>Sel</code> it <em>would</em> contain. Because there is no <code>Sel</code> for an empty list, the empty pattern match is safe.</p>
<p>Remember to enable <em>-Werror=incomplete-patterns</em> to be sure!</p></li>
<li><p>For the second branch, we have <code>'Z</code> and <code>(x ': xs)</code>. We want to prove that there exists an item at position <code>'Z</code> in the list <code>x ': xs</code>. The answer is <em>yes</em>, there does, and that item is <code>x</code>, and the <code>Sel</code> is <code>SelZ</code>!</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L144-L148</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2"></a>
<a class="sourceLine" id="cb46-3" data-line-number="3">inBounds_zcons</a>
<a class="sourceLine" id="cb46-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">Sing</span> x</a>
<a class="sourceLine" id="cb46-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> xs</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> &#39;<span class="dt">Z</span> <span class="fu">@@</span> (x &#39;<span class="fu">:</span> xs))</a>
<a class="sourceLine" id="cb46-7" data-line-number="7">inBounds_zcons x _ <span class="fu">=</span> <span class="dt">Proved</span> (x <span class="fu">:&amp;:</span> <span class="dt">SelZ</span>)</a></code></pre></div></li>
<li><p>For the third branch, we have <code>'S n</code> and <code>'[]</code>. Again, this should be false, because there is no item in the <code>'S n</code> position in <code>'[]</code>. We should be able to use the same strategy for the first branch:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L150-L153</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2"></a>
<a class="sourceLine" id="cb47-3" data-line-number="3">inBounds_snil</a>
<a class="sourceLine" id="cb47-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">Sing</span> n</a>
<a class="sourceLine" id="cb47-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> (&#39;<span class="dt">S</span> n) <span class="fu">@@</span> &#39;[])</a>
<a class="sourceLine" id="cb47-6" data-line-number="6">inBounds_snil _ <span class="fu">=</span> <span class="dt">Disproved</span> <span class="fu">$</span> \(_ <span class="fu">:&amp;:</span> s) <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span> {}</a></code></pre></div></li>
<li><p>The fourth branch is the most interesting one. We have <code>'S n</code> and <code>(x ': xs)</code>. How do we know if the list <code>x ': xs</code> has an item in the <code>'S n</code> spot?</p>
<p>Well, we can check if the list <code>xs</code> has an item in its <code>n</code> spot.</p>
<ul>
<li><p>If it does, then call that item <code>y</code>, and we know that <code>x ': xs</code> has <code>y</code> in its <code>'S n</code> spot.</p></li>
<li><p>If it doesn’t, then we can’t have an item at <code>'S n</code> spot in <code>x ': xs</code> either! To show why, we can do a proof by contradiction.</p>
<p>Suppose there <em>was</em> an item <code>y</code> at the <code>'S n</code> spot in <code>x ': xs</code>. If so, then that means that there would be an item <code>y</code> in the <code>n</code> spot in <code>xs</code>. However, this was found to be false. Therefore, we cannot have an item in the <code>'S n</code> spot in <code>x ': xs</code>.</p></li>
</ul>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L155-L167</span></a>
<a class="sourceLine" id="cb48-2" data-line-number="2"></a>
<a class="sourceLine" id="cb48-3" data-line-number="3">inBounds_scons</a>
<a class="sourceLine" id="cb48-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">Sing</span> n</a>
<a class="sourceLine" id="cb48-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> x</a>
<a class="sourceLine" id="cb48-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> xs</a>
<a class="sourceLine" id="cb48-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> (&#39;<span class="dt">S</span> n) <span class="fu">@@</span> (x &#39;<span class="fu">:</span> xs))</a>
<a class="sourceLine" id="cb48-8" data-line-number="8">inBounds_scons n _ xs <span class="fu">=</span> <span class="kw">case</span> inBounds n xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-9" data-line-number="9">    <span class="dt">Proved</span> (y <span class="fu">:&amp;:</span> s) <span class="ot">-&gt;</span>       <span class="co">-- if xs has y in its n spot</span></a>
<a class="sourceLine" id="cb48-10" data-line-number="10">      <span class="dt">Proved</span> (y <span class="fu">:&amp;:</span> <span class="dt">SelS</span> s)   <span class="co">-- then (x : xs) has y in its (S n) spot</span></a>
<a class="sourceLine" id="cb48-11" data-line-number="11">    <span class="dt">Disproved</span> v      <span class="ot">-&gt;</span> <span class="dt">Disproved</span> <span class="fu">$</span> <span class="co">-- v is a disproof that an item is in n spot in xs</span></a>
<a class="sourceLine" id="cb48-12" data-line-number="12">      \(y <span class="fu">:&amp;:</span> s) <span class="ot">-&gt;</span>      <span class="co">-- suppose we had item y in (S n) spot in (x : xs)</span></a>
<a class="sourceLine" id="cb48-13" data-line-number="13">        <span class="kw">case</span> s <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-14" data-line-number="14">          <span class="dt">SelS</span> s&#39; <span class="ot">-&gt;</span>     <span class="co">-- this would mean that item y is in n spot in xs</span></a>
<a class="sourceLine" id="cb48-15" data-line-number="15">            v (y <span class="fu">:&amp;:</span> s&#39;) <span class="co">-- however, v disproves this.</span></a></code></pre></div>
<p>If you have problems understanding this, try playing around with typed holes in GHC, or trying to guess what types everything has in the implementation above, until you can figure out what is happening when.</p></li>
</ol>
<p>Finally, we can wrap everything up by providing our first ever <code>Decidable</code> instance. We need to give <code>inBounds</code> a <code>Sing n</code>, so we can do that using <code>sing :: Sing n</code>, provided that the instance has a <code>SingI n</code> constraint.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L127-L129</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2"></a>
<a class="sourceLine" id="cb49-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">SingI</span> n <span class="ot">=&gt;</span> <span class="dt">Decidable</span> (<span class="dt">InBounds</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb49-4" data-line-number="4"><span class="ot">    decide ::</span> <span class="dt">Sing</span> xs <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">InBounds</span> n <span class="fu">@@</span> xs)</a>
<a class="sourceLine" id="cb49-5" data-line-number="5">    decide <span class="fu">=</span> inBounds sing</a></code></pre></div>
<h3 id="proving-pick">Proving Pick</h3>
<p>Now that we can decide <code>InBounds</code>, let’s finally prove <code>Pick</code>.</p>
<p>Again, for learning purposes, we’ll define <code>pick</code> as its own function and then write an instance for <code>Provable</code>.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1">pick</a>
<a class="sourceLine" id="cb50-2" data-line-number="2"><span class="ot">    ::</span> forall i j b<span class="fu">.</span> ()</a>
<a class="sourceLine" id="cb50-3" data-line-number="3">    <span class="ot">=&gt;</span> <span class="dt">Sing</span> i</a>
<a class="sourceLine" id="cb50-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> j</a>
<a class="sourceLine" id="cb50-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> b</a>
<a class="sourceLine" id="cb50-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a>
<a class="sourceLine" id="cb50-7" data-line-number="7">pick <span class="dt">Sing</span> <span class="dt">Sing</span> b <span class="fu">=</span></a></code></pre></div>
<p>We’ll match with the <code>Sing</code> constructor for <code>Sing i</code> and <code>Sing j</code>; the <code>Sing</code> constructor is a pattern synonym that, if matched on, brings <code>SingI i</code> and <code>SingI j</code> instances into scope.</p>
<p>Remember, the goal is to try to prove we have a valid pick. We want to create something with the <code>PickValid</code> constructor if we can:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="dt">PickValid</span><span class="ot">  ::</span> <span class="dt">Coord</span> &#39;(i, j) b &#39;<span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a>
<a class="sourceLine" id="cb51-2" data-line-number="2"></a>
<a class="sourceLine" id="cb51-3" data-line-number="3"><span class="ot">(:$:) ::</span> <span class="dt">Sel</span> i rows row</a>
<a class="sourceLine" id="cb51-4" data-line-number="4">      <span class="ot">-&gt;</span> <span class="dt">Sel</span> j row  p</a>
<a class="sourceLine" id="cb51-5" data-line-number="5">      <span class="ot">-&gt;</span> <span class="dt">Coord</span> &#39;(i, j) rows p</a></code></pre></div>
<p>So we need a <code>Coord '(i, j) b 'Nothing</code>, which means we need a <code>Sel i b row</code> and a <code>Sel j row 'Nothing</code>. Let’s use our decision functions we wrote to get these! In particular, we can use <code>decide @(InBounds i) b</code> to get our <code>Sel i b row</code>, and then use <code>decide @(InBounds j) row</code> to get our <code>Sel j row piece</code>!</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1">pick</a>
<a class="sourceLine" id="cb52-2" data-line-number="2"><span class="ot">    ::</span> forall i j b<span class="fu">.</span> ()</a>
<a class="sourceLine" id="cb52-3" data-line-number="3">    <span class="ot">=&gt;</span> <span class="dt">Sing</span> i</a>
<a class="sourceLine" id="cb52-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> j</a>
<a class="sourceLine" id="cb52-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> b</a>
<a class="sourceLine" id="cb52-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a>
<a class="sourceLine" id="cb52-7" data-line-number="7">pick <span class="dt">Sing</span> <span class="dt">Sing</span> b <span class="fu">=</span> <span class="kw">case</span> decide <span class="fu">@</span>(<span class="dt">InBounds</span> i) b <span class="kw">of</span></a>
<a class="sourceLine" id="cb52-8" data-line-number="8">    <span class="dt">Proved</span> (row <span class="fu">:&amp;:</span> selX) <span class="ot">-&gt;</span> <span class="kw">case</span> decide <span class="fu">@</span>(<span class="dt">InBounds</span> j) row <span class="kw">of</span></a>
<a class="sourceLine" id="cb52-9" data-line-number="9">      <span class="dt">Proved</span> (p <span class="fu">:&amp;:</span> selY) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb52-10" data-line-number="10">        <span class="kw">let</span> c <span class="fu">=</span> selX <span class="fu">:$:</span> selY</a>
<a class="sourceLine" id="cb52-11" data-line-number="11">        <span class="kw">in</span>  <span class="co">-- success???</span></a></code></pre></div>
<p>Just to clarify what’s going on, let’s give types to the names above:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="ot">b    ::</span> <span class="dt">Sing</span> (<span class="ot">b   ::</span> [[<span class="dt">Maybe</span> <span class="dt">Piece</span>]])</a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="ot">row  ::</span> <span class="dt">Sing</span> (<span class="ot">row ::</span>  [<span class="dt">Maybe</span> <span class="dt">Piece</span>] )</a>
<a class="sourceLine" id="cb53-3" data-line-number="3"><span class="ot">selX ::</span> <span class="dt">Sel</span> i b row</a>
<a class="sourceLine" id="cb53-4" data-line-number="4"><span class="ot">p    ::</span> <span class="dt">Sing</span> (<span class="ot">p   ::</span>   <span class="dt">Maybe</span> <span class="dt">Piece</span>  )</a>
<a class="sourceLine" id="cb53-5" data-line-number="5"><span class="ot">selY ::</span> <span class="dt">Sel</span> j row p</a>
<a class="sourceLine" id="cb53-6" data-line-number="6"><span class="ot">c    ::</span> <span class="dt">Coord</span> &#39;(i, j) b p</a></code></pre></div>
<p><code>row</code> above is the <code>Sing</code> that comes attached with all <code>Σ</code> constructors, which is why we can give it to <code>decide @(InBounds j)</code>, which expects a singleton of the list.</p>
<p>So, now we have <code>Coord '(i, j) b p</code>. We know that <code>i</code> and <code>j</code> are in-bounds. But, we need to know that <code>p</code> is <code>'Nothing</code> before we can use it with <code>PickValid</code>. To do that, we can pattern match on <code>p</code>, because it’s the singleton that comes with the <code>Σ</code> constructor:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1">pick</a>
<a class="sourceLine" id="cb54-2" data-line-number="2"><span class="ot">    ::</span> forall i j b<span class="fu">.</span> ()</a>
<a class="sourceLine" id="cb54-3" data-line-number="3">    <span class="ot">=&gt;</span> <span class="dt">Sing</span> i</a>
<a class="sourceLine" id="cb54-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> j</a>
<a class="sourceLine" id="cb54-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> b</a>
<a class="sourceLine" id="cb54-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a>
<a class="sourceLine" id="cb54-7" data-line-number="7">pick <span class="dt">Sing</span> <span class="dt">Sing</span> b <span class="fu">=</span> <span class="kw">case</span> decide <span class="fu">@</span>(<span class="dt">InBounds</span> i) b <span class="kw">of</span></a>
<a class="sourceLine" id="cb54-8" data-line-number="8">    <span class="dt">Proved</span> (row <span class="fu">:&amp;:</span> selX) <span class="ot">-&gt;</span> <span class="kw">case</span> decide <span class="fu">@</span>(<span class="dt">InBounds</span> j) row <span class="kw">of</span></a>
<a class="sourceLine" id="cb54-9" data-line-number="9">      <span class="dt">Proved</span> (p <span class="fu">:&amp;:</span> selY) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb54-10" data-line-number="10">        <span class="kw">let</span> c <span class="fu">=</span> selX <span class="fu">:$:</span> selY</a>
<a class="sourceLine" id="cb54-11" data-line-number="11">        <span class="kw">in</span>  <span class="kw">case</span> p <span class="kw">of</span></a>
<a class="sourceLine" id="cb54-12" data-line-number="12">              <span class="dt">SNothing</span> <span class="ot">-&gt;</span> <span class="dt">PickValid</span>   c     <span class="co">-- p is &#39;Nothing</span></a>
<a class="sourceLine" id="cb54-13" data-line-number="13">              <span class="dt">SJust</span> q  <span class="ot">-&gt;</span> <span class="dt">PickPlayed</span>  c q   <span class="co">-- p is &#39;Just q</span></a></code></pre></div>
<p>Finally, knowing that <code>p</code> is <code>'Nothing</code>, we can create <code>PickValid</code>!</p>
<p>As a bonus, if we know that <code>p</code> is <code>'Just p</code>, we can create <code>PickPlayed</code>, which is the constructor for an in-bounds pick but pointing to a spot that is already occupied by piece <code>p'</code>.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="dt">PickPlayed</span><span class="ot"> ::</span> <span class="dt">Coord</span> &#39;(i, j) b (&#39;<span class="dt">Just</span> p)</a>
<a class="sourceLine" id="cb55-2" data-line-number="2">           <span class="ot">-&gt;</span> <span class="dt">Sing</span> p</a>
<a class="sourceLine" id="cb55-3" data-line-number="3">           <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a></code></pre></div>
<p>We now have to deal with the situations where things are out of bounds.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="dt">PickOoBX</span><span class="ot"> ::</span> <span class="dt">OutOfBounds</span> i <span class="fu">@@</span> b</a>
<a class="sourceLine" id="cb56-2" data-line-number="2">         <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a>
<a class="sourceLine" id="cb56-3" data-line-number="3"><span class="dt">PickOoBY</span><span class="ot"> ::</span> <span class="dt">Sel</span> i b row</a>
<a class="sourceLine" id="cb56-4" data-line-number="4">         <span class="ot">-&gt;</span> <span class="dt">OutOfBounds</span> j <span class="fu">@@</span> row</a>
<a class="sourceLine" id="cb56-5" data-line-number="5">         <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a></code></pre></div>
<p>However, thanks to the <em><a href="https://hackage.haskell.org/package/decidable">decidable</a></em> library, things work out nicely. That’s because <code>OutOfBounds n</code> we defined as:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L112-L112</span></a>
<a class="sourceLine" id="cb57-2" data-line-number="2"></a>
<a class="sourceLine" id="cb57-3" data-line-number="3"><span class="kw">type</span> <span class="dt">OutOfBounds</span> n <span class="fu">=</span> <span class="dt">Not</span> (<span class="dt">InBounds</span> n)</a></code></pre></div>
<p>and <code>Not</code>, the predicate combinator, is defined as:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Not</span><span class="ot"> ::</span> <span class="dt">Predicate</span> k <span class="ot">-&gt;</span> <span class="dt">Predicate</span> k</a>
<a class="sourceLine" id="cb58-2" data-line-number="2"></a>
<a class="sourceLine" id="cb58-3" data-line-number="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> (<span class="dt">Not</span> p) x <span class="fu">=</span> (p <span class="fu">@@</span> x) <span class="ot">-&gt;</span> <span class="dt">Void</span></a></code></pre></div>
<p>That is, a witness of <code>Not p @@ x</code> is a function of type <code>p @@ x -&gt; Void</code>. That means that <code>PickOoBX</code> expects an <code>InBounds i @@ b -&gt; Void</code>, and <code>PickOoBY</code> expects an <code>InBounds j @@ row -&gt; Void</code>. And that’s <em>exactly</em> what the <code>Disproved</code> branches give!</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L169-L187</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2"></a>
<a class="sourceLine" id="cb59-3" data-line-number="3">pick</a>
<a class="sourceLine" id="cb59-4" data-line-number="4"><span class="ot">    ::</span> forall i j b<span class="fu">.</span> ()</a>
<a class="sourceLine" id="cb59-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">Sing</span> i</a>
<a class="sourceLine" id="cb59-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> j</a>
<a class="sourceLine" id="cb59-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> b</a>
<a class="sourceLine" id="cb59-8" data-line-number="8">    <span class="ot">-&gt;</span> <span class="dt">Pick</span> &#39;(i, j, b)</a>
<a class="sourceLine" id="cb59-9" data-line-number="9">pick <span class="dt">Sing</span> <span class="dt">Sing</span> b <span class="fu">=</span> <span class="kw">case</span> decide <span class="fu">@</span>(<span class="dt">InBounds</span> i) b <span class="kw">of</span></a>
<a class="sourceLine" id="cb59-10" data-line-number="10">    <span class="dt">Proved</span> (row <span class="fu">:&amp;:</span> selX) <span class="ot">-&gt;</span> <span class="kw">case</span> decide <span class="fu">@</span>(<span class="dt">InBounds</span> j) row <span class="kw">of</span></a>
<a class="sourceLine" id="cb59-11" data-line-number="11">      <span class="dt">Proved</span> (p <span class="fu">:&amp;:</span> selY) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb59-12" data-line-number="12">        <span class="kw">let</span> c <span class="fu">=</span> selX <span class="fu">:$:</span> selY</a>
<a class="sourceLine" id="cb59-13" data-line-number="13">        <span class="kw">in</span>  <span class="kw">case</span> p <span class="kw">of</span></a>
<a class="sourceLine" id="cb59-14" data-line-number="14">              <span class="dt">SNothing</span> <span class="ot">-&gt;</span> <span class="dt">PickValid</span>   c     <span class="co">-- p is &#39;Nothing</span></a>
<a class="sourceLine" id="cb59-15" data-line-number="15">              <span class="dt">SJust</span> q  <span class="ot">-&gt;</span> <span class="dt">PickPlayed</span>  c q   <span class="co">-- p is &#39;Just q</span></a>
<a class="sourceLine" id="cb59-16" data-line-number="16">      <span class="dt">Disproved</span> vY <span class="ot">-&gt;</span> <span class="dt">PickOoBY</span> selX vY    <span class="co">-- vY :: InBounds j @@ row -&gt; Void</span></a>
<a class="sourceLine" id="cb59-17" data-line-number="17">                                          <span class="co">-- vY :: Not (InBounds j) @@ row</span></a>
<a class="sourceLine" id="cb59-18" data-line-number="18">                                          <span class="co">-- vY :: OutOfBounds j @@ row</span></a>
<a class="sourceLine" id="cb59-19" data-line-number="19">    <span class="dt">Disproved</span> vX <span class="ot">-&gt;</span> <span class="dt">PickOoBX</span> vX   <span class="co">-- vX :: InBounds i @@ b   -&gt; Void</span></a>
<a class="sourceLine" id="cb59-20" data-line-number="20">                                  <span class="co">-- vX :: Not (InBounds i) @@ b</span></a>
<a class="sourceLine" id="cb59-21" data-line-number="21">                                  <span class="co">-- vX :: OutOfBounds i @@ b</span></a></code></pre></div>
<p>And that’s it!</p>
<p>Now to just tie it all together with a <code>Provable</code> instance, using the <code>STuple3</code> singletons constructor:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/ttt/Part1.hs#L189-L191</span></a>
<a class="sourceLine" id="cb60-2" data-line-number="2"></a>
<a class="sourceLine" id="cb60-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Provable</span> (<span class="dt">TyPred</span> <span class="dt">Pick</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb60-4" data-line-number="4"><span class="ot">    prove ::</span> <span class="dt">Sing</span> ijb <span class="ot">-&gt;</span> <span class="dt">Pick</span> ijb</a>
<a class="sourceLine" id="cb60-5" data-line-number="5">    prove (<span class="dt">STuple3</span> i j b) <span class="fu">=</span> pick i j b</a></code></pre></div>
<h2 id="play-ball">Play Ball</h2>
<p>Bringing it all together, we can write a simple function to take user input and <em>play</em> it.</p></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/typesafe-tic-tac-toe-1.html';
    this.page.identifier = 'ttt-1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>