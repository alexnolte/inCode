<!DOCTYPE HTML>
<html><head><title>The Functor Combinatorpedia · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Recently I’ve been very productive what I have been calling the “Functor Combinator” design pattern. It is heavily influenced by ideas like Data types a la Carte and unified free monoidal functors, but the end goal is slightly different in spirit. The goal is to represent schemas, DSL’s, and computations (things like parsers, things to execute, things to consume or produce data) by assembling “self-evident” basic primitives and subjecting them to many different successive transformations and combiners. The process of doing so:  * Forces you to make explicit decisions about the structure of your computation type as an ADT. * Allows you to retain isolation of fundamental parts of your domain as separate types * Lets you manipulate the structure of your final computation type through normal Haskell techniques like pattern matching. The structure is available throughout the entire process, so you can replace individual components and values within your structure. * Allows you to fully reflect the structure of your final computation through pattern matching and folds, so you can inspect the structure and produce useful summaries. Like “data types a la carte” and free monad/applicative/alternative designs, these techniques allow you to separate the assembly and inspection of your programs from the “running” of them. However, the main difference is that here we focus not just on products and sums, but many different varied and multi-purpose combinators — a bona fide “zoo” of combinators. So, this focuses less on “fixed-points” like Free, Ap, Alt, and more on non-recursive simple building blocks…where recursive combinators like Free might be used along the way. The functor itself is the goal, not its fixed point. This post, then, will be a run-down on the wide variety of such “functor combinators” across the Haskell ecosystem — a functor combinator “zoo” of sorts. To speak about them all with the same language and vocabulary, this post also serves as an overview of the functor-combinators library, which mostly pulls them all together and provides a unified interface for working with them."><meta property="og:type" content="article"><meta property="og:title" content="The Functor Combinatorpedia"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/functor-combinatorpedia.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/functor-combinatorpedia.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">The Functor Combinatorpedia</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/functor-combinatorpedia.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/functor-combinatorpedia.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/functor-combinatorpedia.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Recently I’ve been very productive what I have been calling the “Functor Combinator” design pattern. It is heavily influenced by ideas like <a href="http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf">Data types a la Carte</a> and <a href="http://oleg.fi/gists/posts/2018-02-21-single-free.html">unified free monoidal functors</a>, but the end goal is slightly different in spirit.</p>
<p>The goal is to represent schemas, DSL’s, and computations (things like parsers, things to execute, things to consume or produce data) by assembling “self-evident” basic primitives and subjecting them to many <em>different</em> successive transformations and combiners. The process of doing so:</p>
<ol type="1">
<li>Forces you to make explicit decisions about the structure of your computation type as an ADT.</li>
<li>Allows you to retain isolation of fundamental parts of your domain as separate types</li>
<li>Lets you manipulate the structure of your final computation type through <em>normal Haskell techniques</em> like pattern matching. The structure is available throughout the entire process, so you can replace individual components and values within your structure.</li>
<li>Allows you to fully <em>reflect</em> the structure of your final computation through pattern matching and folds, so you can inspect the structure and produce useful summaries.</li>
</ol>
<p>Like “data types a la carte” and free monad/applicative/alternative designs, these techniques allow you to separate the assembly and inspection of your programs from the “running” of them. However, the main difference is that here we focus not just on products and sums, but many different varied and multi-purpose combinators — a bona fide “zoo” of combinators. So, this focuses less on “fixed-points” like <code>Free</code>, <code>Ap</code>, <code>Alt</code>, and more on non-recursive simple building blocks…where recursive combinators like <code>Free</code> might be used along the way. The <em>functor itself</em> is the goal, <em>not</em> its fixed point.</p>
<p>This post, then, will be a run-down on the wide variety of such “functor combinators” across the Haskell ecosystem — a functor combinator “zoo” of sorts. To speak about them all with the same language and vocabulary, this post also serves as an overview of the <em><a href="https://hackage.haskell.org/package/functor-combinators">functor-combinators</a></em> library, which mostly pulls them all together and provides a unified interface for working with them.</p>
<h2 id="prologue-what-is-a-functor-combinator">Prologue: What is a functor combinator?</h2>
<p>A functor combinator takes “functors” (or other indexed types) and returns a new functor, enhances or mixes them together in some way.</p>
<p>That is, they take things of kind <code>k -&gt; Type</code> and themselves return a <code>k -&gt; Type</code>. This lets us build complex functors out of simpler “primitive” ones.</p>
<p>For example, <code>ReaderT r</code> is a famous one that takes a functor <code>f</code> and enhances it with “access to an <code>r</code> environment” functionality. Another famous one is <code>Free</code>, which takes a functor <code>f</code> and enhances it with “sequential binding” capabilities: it turns <code>f</code> into a <code>Monad</code>. Yet another is <code>EnvT e</code>, which takes a functor <code>f</code> and enhances it by “tagging an <code>e</code> value” along our <code>f a</code>s.</p>
<p>Sometimes, we have binary functor combinators, like <code>:+:</code>, which takes two functors <code>f</code> and <code>g</code> and returns a functor that is “either” <code>f</code> or <code>g</code>. Binary functor combinators “mix together” the functionality of different functors in different ways.</p>
<h3 id="examples">Examples</h3>
<p>If your final DSL/program/schema is some functor, then functor combinators allow you to construct your final functor by combining simpler “primitive” functors, and take advantage of common functionality.</p>
<p>For example, if you were making a data type/EDSL to describe a command line parser, you might have two primitives: <code>data Arg a</code>, for positional arguments parsing <code>a</code>, and <code>data Option a</code>, for <code>--flag</code> non-positional options parsing <code>a</code>. From there, you can <em>choose</em> what structure of command line arguments you want to be able to express.</p>
<p>For instance, a structure that can support multiple arguments and optionally a single <code>Option</code> would be:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> <span class="dt">CommandArgs</span> <span class="ot">=</span> <span class="dt">Ap</span> <span class="dt">Arg</span> <span class="op">:*:</span> <span class="dt">Lift</span> <span class="dt">Option</span></span></code></pre></div>
<p>And a structure that supports <em>multiple commands</em> on top of that would be:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">type</span> <span class="dt">CommandArgs</span> <span class="ot">=</span> <span class="dt">MapF</span> <span class="dt">String</span> (<span class="dt">Ap</span> <span class="dt">Arg</span> <span class="op">:*:</span> <span class="dt">Lift</span> <span class="dt">Option</span>)</span></code></pre></div>
<p>You can mix or match combinators to decide exactly what sort of structures you allow in your DSL.</p>
<h3 id="common-functionality">Common Functionality</h3>
<p>Most of these functor combinators allow us to “swap out” the underlying functor, retaining all of the “enhanced” structure. We abstract over all of these using <code>hmap</code> for single-argument functor combinators (“enhancers”) and <code>hbimap</code> for two-argument functor combinators (“mixers”).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">class</span> <span class="dt">HFunctor</span> t <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="co">-- | Swap out underlying functor for a single-argument functor combinator</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    hmap</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="ot">        ::</span> t f a <span class="ot">-&gt;</span> t g a</span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="kw">class</span> <span class="dt">HBifunctor</span> t <span class="kw">where</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="co">-- | Swap out underlying functors for a two-argument functor combinator</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    hbimap</span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="ot">        ::</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> h x)</span>
<span id="cb3-10"><a href="#cb3-10"></a>        <span class="ot">-&gt;</span> (<span class="kw">forall</span> x<span class="op">.</span> g x <span class="ot">-&gt;</span> j x)</span>
<span id="cb3-11"><a href="#cb3-11"></a>        <span class="ot">-&gt;</span> t f g a</span>
<span id="cb3-12"><a href="#cb3-12"></a>        <span class="ot">-&gt;</span> t g j a</span></code></pre></div>
<p>However, for this post, the concept of a “natural transformation” between <code>f</code> and <code>g</code> — a function of type <code>forall x. f x -&gt; g x</code>, is given a type synonym:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">type</span> f <span class="op">~&gt;</span> g <span class="ot">=</span> <span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> g x</span></code></pre></div>
<p>Then the type signatures of <code>hmap</code> and <code>hbimap</code> become:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">class</span> <span class="dt">HFunctor</span> t <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>    hmap</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="ot">        ::</span> t f <span class="op">~&gt;</span> t g</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">class</span> <span class="dt">HBifunctor</span> t <span class="kw">where</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    hbimap</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="ot">        ::</span> f <span class="op">~&gt;</span> h</span>
<span id="cb5-8"><a href="#cb5-8"></a>        <span class="ot">-&gt;</span> g <span class="op">~&gt;</span> j</span>
<span id="cb5-9"><a href="#cb5-9"></a>        <span class="ot">-&gt;</span> t f g <span class="op">~&gt;</span> t h j</span></code></pre></div>
<p>What does it mean exactly when we say that <code>hmap</code> and <code>hbimap</code> “preserve the enhanced structure”? Well, for example, <code>ListF f a</code> is essentially a list of <code>f a</code>s. <code>hmap</code> will swap out and replace each <code>f a</code>, but it must <em>preserve the relative order</em> between each of the original <code>f a</code>s. And it must preserve the length of the list. It’s a complete “in-place swap”. This is formalizing by requiring <code>hmap id == id</code> and <code>hbimap id id == id</code>.</p>
<p>You can also always “lift” a functor value into its transformed type. We abstract over this by using <code>inject</code> (for single-argument functors) and <code>inL</code> and <code>inR</code> (for two-argument functors):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">class</span> <span class="dt">Inject</span> t <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="co">-- | Lift `f` into `t f`</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="ot">    inject ::</span> f <span class="op">~&gt;</span> t f</span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="ot">inL ::</span> (<span class="dt">Monoidal</span> t, <span class="dt">CM</span> t g)     <span class="co">-- more on the `CM t` later</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> t f g</span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="ot">inR ::</span> (<span class="dt">Monoidal</span> t, <span class="dt">CM</span> t f)     <span class="co">-- more on the `CM t` later</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="ot">=&gt;</span> g <span class="op">~&gt;</span> t f g</span></code></pre></div>
<p>Finally, in order to <em>use</em> any functor combinators, you have to <em>interpret</em> them into some target context. The choice of combinator imposes some constraints on the target context. We abstract over this using <code>interpret</code> and <code>binterpret</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">class</span> <span class="dt">Interpret</span> t <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="kw">type</span> <span class="dt">C</span><span class="ot"> t ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="co">-- | Interpret unary functor combinator</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    interpret</span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="ot">        ::</span> <span class="dt">C</span> t g</span>
<span id="cb7-7"><a href="#cb7-7"></a>        <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g             <span class="co">-- ^ interpreting function</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>        <span class="ot">-&gt;</span> t f <span class="op">~&gt;</span> g</span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw">instance</span> <span class="dt">Semigroupoidal</span> t <span class="kw">where</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="co">-- | Interpret binary functor combinator</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>    binterpret</span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="ot">        ::</span> (<span class="dt">Semigroupoidal</span> t, <span class="dt">CS</span> t h)</span>
<span id="cb7-14"><a href="#cb7-14"></a>        <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> h             <span class="co">-- ^ interpreting function on f</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>        <span class="ot">=&gt;</span> g <span class="op">~&gt;</span> h             <span class="co">-- ^ interpreting function on g</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>        <span class="ot">-&gt;</span> t f g <span class="op">~&gt;</span> h</span></code></pre></div>
<p>Each functor combinator defines a constraint (<code>C</code> for unary functor combinators, and <code>CS</code> and <code>CM</code> for binary functor combinators) that allows you to “exit”, or “run” the functor combinator.</p>
<p>For some concrete examples:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">ReaderT</span> r) <span class="ot">=</span> <span class="dt">MonadReader</span> r</span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a>interpret <span class="op">@</span>(<span class="dt">MonadReader</span> r)</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="ot">    ::</span> <span class="dt">MonadReader</span> r g</span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="ot">=&gt;</span> (f <span class="op">~&gt;</span> g)</span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r f a</span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="ot">-&gt;</span> g a</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Free</span> <span class="ot">=</span> <span class="dt">Monad</span></span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a>interpret <span class="op">@</span><span class="dt">Free</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="ot">    ::</span> <span class="dt">Monad</span> g</span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="ot">=&gt;</span> (f <span class="op">~&gt;</span> g)</span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</span>
<span id="cb8-15"><a href="#cb8-15"></a>    <span class="ot">-&gt;</span> g a</span>
<span id="cb8-16"><a href="#cb8-16"></a></span>
<span id="cb8-17"><a href="#cb8-17"></a><span class="kw">type</span> <span class="dt">CM</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Unconstrained</span>   <span class="co">-- no constraints on exiting</span></span>
<span id="cb8-18"><a href="#cb8-18"></a></span>
<span id="cb8-19"><a href="#cb8-19"></a>binterpret <span class="op">@</span>(<span class="op">:+:</span>)</span>
<span id="cb8-20"><a href="#cb8-20"></a><span class="ot">    ::</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb8-21"><a href="#cb8-21"></a>    <span class="ot">-&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb8-22"><a href="#cb8-22"></a>    <span class="ot">-&gt;</span> (f <span class="op">:+:</span> g) a</span>
<span id="cb8-23"><a href="#cb8-23"></a>    <span class="ot">-&gt;</span> h a</span></code></pre></div>
<p>We see that <code>interpret</code> lets you “run” a <code>ReaderT r f</code> into any <code>MonadReader r g</code> and “run” a <code>Free</code> in any monad <code>g</code>, and <code>binterpret</code> lets you “run” a function over both branches of an <code>f :+: g</code> to produce an <code>h</code>.</p>
<p>From these, we can build a lot of useful utility functions (like <code>retract</code>, <code>biretract</code>, <code>getI</code>, <code>biget</code>, etc.) for convenience in actually working on them. These are provided in <em><a href="https://hackage.haskell.org/package/functor-combinators">functor-combinators</a></em>.</p>
<p>Without further ado, let’s dive into the zoo of functor combinators!</p>
<h2 id="the-zoo">The Zoo</h2>
<h3 id="two-argument">Two-Argument</h3>
<p>Binary functor combinators “mix together” two functors/indexed types in different ways.</p>
<p>Each one has two associated constraints:</p>
<ul>
<li><p><code>CS t</code> is the constraint on where you can <em>interpret</em> or <em>run</em> values of the enhanced type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a>binterpret</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ot">    ::</span> (<span class="dt">Semigroupoidal</span> t, <span class="dt">CS</span> t h)</span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="ot">=&gt;</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="ot">=&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="ot">-&gt;</span> (t f g <span class="op">~&gt;</span> h)</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a>biretract</span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="ot">    ::</span> (<span class="dt">Semigroupoidal</span> t, <span class="dt">CS</span> t f)</span>
<span id="cb9-9"><a href="#cb9-9"></a>    <span class="ot">=&gt;</span> t f f <span class="op">~&gt;</span> f</span></code></pre></div></li>
<li><p><code>CM t</code> is the constraint on where you can <em>create</em> values of the enhanced type (<code>pureT</code>, <code>inL</code>, <code>inR</code>)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a>pureT</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ot">    ::</span> (<span class="dt">Monoidal</span> t, <span class="dt">CM</span> t f)</span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="ot">=&gt;</span> <span class="dt">I</span> t <span class="op">~&gt;</span> f</span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="ot">inL ::</span> (<span class="dt">Monoidal</span> t, <span class="dt">CM</span> t g)</span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> t f g</span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="ot">inR ::</span> (<span class="dt">Monoidal</span> t, <span class="dt">CM</span> t f)</span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="ot">=&gt;</span> g <span class="op">~&gt;</span> t f g</span></code></pre></div></li>
</ul>
<p>Most of these also have an identity, <code>I t</code>, where applying <code>t f (I t)</code> leaves <code>f</code> unchanged (<code>t f (I t) ~ f</code>). This is represented by the associated type <code>I t</code>.</p>
<p>All of these also have a “apply to self many times”, for situations where you want to represent the act of applying <code>t</code> to the same <code>f</code> multiple times, called the “induced monoidal functor combinator”, given by <code>MF t</code> (or <code>SF t</code> for the “nonempty” variant).</p>
<p>You can “convert” back and forth by using:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">toMF   ::</span> t f f <span class="op">~&gt;</span> <span class="dt">MF</span> t</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="ot">nilMF  ::</span> <span class="dt">I</span> t <span class="op">~&gt;</span> <span class="dt">MF</span> t</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="ot">consMF ::</span> t f (<span class="dt">MF</span> t) <span class="op">~&gt;</span> <span class="dt">MF</span> t</span></code></pre></div>
<p>and other helper functions.</p>
<p>Here we simply list the induced monoid with some small notes; for more details, see the actual section for that induced monoid later on.</p>
<h4 id="sum">:+: / Sum</h4>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/base/docs/GHC-Generics.html">GHC.Generics</a></em> (for <code>:+:</code>) / <em><a href="https://hackage.haskell.org/package/base/docs/Data-Functor-Sum.html">Data.Functor.Sum</a></em> (for <code>Sum</code>)</p></li>
<li><p><strong>Mixing Strategy</strong>: “Either-or”: provide either case, and user has to handle both possibilities. Basically higher-order <code>Either</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">data</span> (f <span class="op">:+:</span> g) a</span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="ot">=</span> <span class="dt">L1</span> (f a)</span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="op">|</span> <span class="dt">R1</span> (g a)</span>
<span id="cb12-4"><a href="#cb12-4"></a></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="kw">data</span> <span class="dt">Sum</span> f g a</span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="ot">=</span> <span class="dt">InL</span> (f a)</span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="op">|</span> <span class="dt">InR</span> (g a)</span></code></pre></div>
<p>It can be useful for situations where you can validly use one or the other in your schema or functor. For example, if you are describing an HTTP request, we could have <code>data GET a</code> describing a GET request and <code>data POST a</code> describing a POST request; <code>(GET :+: POST) a</code> would be a functor that describes either a GET or POST request.</p>
<p>The person who creates the <code>f :+: g</code> decides which one to give, and the person who consumes/interprets/runs the <code>f :+: g</code> must provide a way of handling <em>both</em></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a>binterpret <span class="op">@</span>(<span class="op">:+:</span>)</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="ot">    ::</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="ot">-&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="ot">-&gt;</span> (f <span class="op">:+:</span> g) a</span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="ot">-&gt;</span> h a</span></code></pre></div></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">type</span> <span class="dt">CS</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Unconstrained</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">type</span> <span class="dt">CM</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Unconstrained</span></span></code></pre></div>
<p>You don’t need any constraint in order to use <code>binterpret</code>, <code>inL</code>, <code>inR</code>, etc.</p>
<p>However, note that <code>pureT @(:+:) :: Void1 ~&gt; h</code> is effectively impossible to call, because no values of type <code>Void1 a</code> exist.</p></li>
<li><p><strong>Identity</strong></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">type</span> <span class="dt">I</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Void1</span></span></code></pre></div>
<p><code>f :+: Void1</code> is equivalent to just <code>f</code>, because you can never have a value of the right branch.</p></li>
<li><p><strong>Induced Monoid</strong></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">type</span> <span class="dt">SF</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Step</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">type</span> <span class="dt">MF</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Step</span></span></code></pre></div>
<p><code>Step</code> is the result of an infinite application of <code>:+:</code> to the same value:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">type</span> <span class="dt">Step</span> f <span class="ot">=</span> f <span class="op">:+:</span> f <span class="op">:+:</span> f <span class="op">:+:</span> f <span class="op">:+:</span> f <span class="op">:+:</span> f <span class="op">:+:</span> <span class="op">...</span> etc<span class="op">.</span></span></code></pre></div>
<p>It’s not a particularly useful type, but it can be useful if you want to provide an <code>f a</code> alongside “which position” it is on the infinite list. Repeatedly using <code>consMF</code> will push the <code>f</code> further and further along the list.</p></li>
</ul>
<h4 id="product">:*: / Product</h4>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/base/docs/GHC-Generics.html">GHC.Generics</a></em> (for <code>:*:</code>) / <em><a href="https://hackage.haskell.org/package/base/docs/Data-Functor-Product.html">Data.Functor.Product</a></em> (for <code>Product</code>)</p></li>
<li><p><strong>Mixing Strategy</strong>: “Both, separately”: provide values from <em>both</em> functors, and the user can choose which one they want to use. Basically a higher-order tuple.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">data</span> (f <span class="op">:*:</span> g) a <span class="ot">=</span> f a <span class="op">:*:</span> g a</span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="kw">data</span> <span class="dt">Product</span> f g a <span class="ot">=</span> <span class="dt">Pair</span> (f a) (g a)</span></code></pre></div>
<p>It can be useful for situations where your schema/functor must be <em>specified</em> using <em>both</em> functors, but the <em>interpreter</em> can choose to use only one or the other (or both).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">prodOutL ::</span> (f <span class="op">:*:</span> g) <span class="op">~&gt;</span> f</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="ot">prodOutR ::</span> (f <span class="op">:*:</span> g) <span class="op">~&gt;</span> g</span></code></pre></div></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">type</span> <span class="dt">CS</span> (<span class="op">:*:</span>) <span class="ot">=</span> <span class="dt">Alt</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="kw">type</span> <span class="dt">CM</span> (<span class="op">:*:</span>) <span class="ot">=</span> <span class="dt">Plus</span></span></code></pre></div>
<p>Fully interpreting out of <code>:*:</code> requires <a href="https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Alt.html"><code>Alt</code></a> (to combine both branches), but if we use only one branch or ther other, we can use <code>prodOutL</code> or <code>prodOutR</code> and require no constraint.</p></li>
<li><p><strong>Identity</strong></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">type</span> <span class="dt">I</span> (<span class="op">:*:</span>) <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p><code>f :+: Proxy</code> is equivalent to just <code>f</code>, because the left hand side doesn’t add anything extra to the pair.</p></li>
<li><p><strong>Induced Monoid</strong></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">type</span> <span class="dt">SF</span> (<span class="op">:*:</span>) <span class="ot">=</span> <span class="dt">NonEmptyF</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">type</span> <span class="dt">MF</span> (<span class="op">:*:</span>) <span class="ot">=</span> <span class="dt">ListF</span></span></code></pre></div>
<p><code>ListF f a</code> is a “list of <code>f a</code>s”. It represents the posibility of having <code>Proxy</code> (zero items), <code>x :: f a</code> (one item), <code>x :*: y</code> (two items), <code>x :*: y :*: z</code> (three items), etc.</p>
<p>It’s basically an ordered collection of <code>f a</code>s <code>:*:</code>d with each other.</p>
<p>It is useful if you want to define a schema where you can offer <em>multiple</em> options for the <code>f a</code>, and the interpreter/consumer can freely pick any one that they want to use.</p>
<p><code>NonEmptyF</code> is the version of <code>ListF</code> that has “at least one <code>f a</code>”.</p></li>
</ul>
<h4 id="day">Day</h4>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Day.html">Data.Functor.Day</a></em></p></li>
<li><p><strong>Mixing Strategy</strong>: “Both, together forever”: provide values from <em>both</em> functors, and the user <em>must</em> also <em>use</em> both.</p>
<p>It can be useful for situations where your schema/functor must be <em>specified</em> using <em>both</em> functors, and the user must also <em>use</em> both.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a>binterpret <span class="op">@</span><span class="dt">Day</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="ot">    ::</span> <span class="dt">Apply</span> h          <span class="co">-- superclass of Applicative</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    <span class="ot">=&gt;</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb23-4"><a href="#cb23-4"></a>    <span class="ot">-&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb23-5"><a href="#cb23-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Day</span> f g <span class="op">~&gt;</span> h</span></code></pre></div>
<p>Unlike for <code>:*:</code>, you always have to interpret <em>both</em> functor values in order to interpret a <code>Day</code>. It’s a “full mixing”.</p></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">type</span> <span class="dt">CS</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Apply</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="kw">type</span> <span class="dt">CM</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Applicative</span></span></code></pre></div>
<p>We need <code>Applicative</code> to interpret out of a <code>Day</code>. Note that all <code>Applicative</code> instances should have an <code>Apply</code> instance, but due to how <em>base</em> is structured, <code>Apply</code> is not a true superclass officially. You can use <code>upgradeC @Day</code> to bring an <code>Apply</code> instance into scope for any <code>Applicative</code> instance.</p>
<p>For example, let’s say we had a type <code>Parser</code> from an external library that is <code>Applicative</code> but not <code>Apply</code>. In that case,</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="ot">biretract ::</span> <span class="dt">Day</span> <span class="dt">Parser</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span></code></pre></div>
<p>is a type error (because <code>Parser</code> has no <code>Apply</code> instance), but</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a>upgradeC <span class="op">@</span><span class="dt">Day</span> (<span class="dt">Proxy</span> <span class="op">@</span><span class="dt">Parser</span>) biretract</span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="ot">    ::</span> <span class="dt">Day</span> <span class="dt">Parser</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span></code></pre></div>
<p>will typecheck.</p></li>
<li><p><strong>Identity</strong></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">type</span> <span class="dt">I</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Identity</span></span></code></pre></div>
<p><code>Day f Identity</code> is equivalent to just <code>f</code>, because <code>Identity</code> adds no extra effects or structure.</p></li>
<li><p><strong>Induced Monoid</strong></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">type</span> <span class="dt">SF</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Ap1</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="kw">type</span> <span class="dt">MF</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Ap</span></span></code></pre></div>
<p><code>Ap f a</code> is a bunch of <code>f x</code>s <code>Day</code>d with each other. It is either:</p>
<ul>
<li><code>a</code> (zero <code>f</code>s)</li>
<li><code>f a</code> (one <code>f</code>)</li>
<li><code>Day f f a</code> (two <code>f</code>s)</li>
<li><code>Day f (Day f f) a</code> (three <code>f</code>s)</li>
<li>.. etc.</li>
</ul>
<p>Like <code>ListF</code> this is very useful if you want your schema to provide a “bag” of <code>f a</code>s and your interpreter <em>must use all of them</em>.</p>
<p>For example, if we have a schema for a command line argument parser, each <code>f</code> may represent a command line option. To interpret it, we must look at <em>all</em> command line options.</p>
<p><code>Ap1</code> is a version with “at least one” <code>f a</code>.</p></li>
</ul>
<h4 id="comp">Comp</h4>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Control-Monad-Freer-Church.html">Control.Monad.Freer.Church</a></em>. Note that an equivalent type is also found in <em><a href="https://hackage.haskell.org/package/base/docs/GHC-Generics.html">GHC.Generics</a></em> and <em><a href="https://hackage.haskell.org/package/base/docs/Data-Functor-Compose.html">Data.Functor.Compose</a></em>, but they are incompatible with the <code>HBifunctor</code> typeclass.</p></li>
<li><p><strong>Mixing Strategy</strong>: “Both, together, sequentially”: provide values from <em>both</em> functors; the user must <em>use</em> both, and <em>in order</em>.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">data</span> <span class="dt">Comp</span> f g a <span class="ot">=</span> <span class="dt">Comp</span> (f (g a))</span></code></pre></div>
<p>It can be useful for situations where your schema/functor must be specified using both functors, and the user must <em>use</em> both, but also enforcing that they must use both in the <em>given order</em>: that is, for a <code>Comp f g</code>, they interpret <code>f</code> <em>before</em> they interpret <code>g</code>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a>binterpret <span class="op">@</span><span class="dt">Day</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="ot">    ::</span> <span class="dt">Bind</span> h          <span class="co">-- superclass of Monad</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>    <span class="ot">=&gt;</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb30-4"><a href="#cb30-4"></a>    <span class="ot">-&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb30-5"><a href="#cb30-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Comp</span> f g <span class="op">~&gt;</span> h</span></code></pre></div>
<p>Unlike for <code>:*:</code>, you always have to interpret <em>both</em> functor values. And, unlike for <code>Day</code>, you must interpret both functor values <em>in that order</em>.</p></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">type</span> <span class="dt">CS</span> <span class="dt">Comp</span> <span class="ot">=</span> <span class="dt">Bind</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">type</span> <span class="dt">CM</span> <span class="dt">Comp</span> <span class="ot">=</span> <span class="dt">Monad</span></span></code></pre></div>
<p>We need <code>Monad</code> to interpret out of a <code>Comp</code>. Note that all <code>Monad</code> instances should have a <code>Bind</code> instance, but due to how <em>base</em> is structured, <code>Bind</code> is not a true superclass officially. See the note on <code>Day</code> for more information on getting around this with <code>upgradeC</code>.</p></li>
<li><p><strong>Identity</strong></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">type</span> <span class="dt">I</span> <span class="dt">Comp</span> <span class="ot">=</span> <span class="dt">Identity</span></span></code></pre></div>
<p><code>Comp f Identity</code> is equivalent to just <code>f</code>, because <code>Identity</code> adds no extra effects or structure.</p></li>
<li><p><strong>Induced Monoid</strong></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">type</span> <span class="dt">SF</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Free1</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="kw">type</span> <span class="dt">MF</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Free</span></span></code></pre></div>
<p><code>Free f a</code> is a bunch of <code>f x</code>s composed with each other. It is either:</p>
<ul>
<li><code>a</code> (zero <code>f</code>s)</li>
<li><code>f a</code> (one <code>f</code>)</li>
<li><code>f (f a)</code> (two <code>f</code>s)</li>
<li><code>f (f (f a))</code> (three <code>f</code>s)</li>
<li>.. etc.</li>
</ul>
<p><code>Free</code> is very useful because it allows you to specify that your schema can have many <code>f</code>s, sequenced one after the other, in which the <em>choice</em> of “the next <code>f</code>” is allowed to depend on the <em>result</em> of “the previous <code>f</code>”.</p>
<p>For example, in an interactive “wizard” sort of schema, where <code>f</code> represents a wizard dialog box, we can represent our wizard using <code>Free f a</code> — an ordered sequence of dialog boxes, where the choice of the next box can depend on result of the previous box.</p>
<p><code>Free1</code> is a version with “at least one” <code>f a</code>.</p></li>
</ul>
<h4 id="these1">These1</h4>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/these/docs/Data-Functor-These.html">Data.Functor.These</a></em>.</p></li>
<li><p><strong>Mixing Strategy</strong>: “Either-or, or both”: provide either (or both) cases, and user has to handle both possibilities. An “inclusive either”</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">data</span> <span class="dt">These1</span> f g a</span>
<span id="cb34-2"><a href="#cb34-2"></a>    <span class="ot">=</span> <span class="dt">This1</span>  (f a)</span>
<span id="cb34-3"><a href="#cb34-3"></a>    <span class="op">|</span> <span class="dt">That1</span>        (g a)</span>
<span id="cb34-4"><a href="#cb34-4"></a>    <span class="op">|</span> <span class="dt">These1</span> (f a) (g a)</span></code></pre></div>
<p>This can be useful for situations where your schema/functor can be specified using one functor or another, or even both. See description on <code>:+:</code> for examples.</p>
<p>The person who creates the <code>These1 f g</code> decides which one to give, and the person who consumes/interprets/runs the <code>f :+: g</code> must provide a way of handling <em>both</em> situations.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a>binterpret <span class="op">@</span><span class="dt">These</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="ot">    ::</span> <span class="dt">Alt</span> h</span>
<span id="cb35-3"><a href="#cb35-3"></a>    <span class="ot">=&gt;</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb35-4"><a href="#cb35-4"></a>    <span class="ot">-&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb35-5"><a href="#cb35-5"></a>    <span class="ot">-&gt;</span> <span class="dt">These</span> f g a</span>
<span id="cb35-6"><a href="#cb35-6"></a>    <span class="ot">-&gt;</span> h a</span></code></pre></div>
<p>You can also pattern match on the <code>These1</code> directly to be more explicit with how you handle each case.</p></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">type</span> <span class="dt">CS</span> <span class="dt">These1</span> <span class="ot">=</span> <span class="dt">Alt</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="kw">type</span> <span class="dt">CM</span> <span class="dt">These1</span> <span class="ot">=</span> <span class="dt">Alt</span></span></code></pre></div>
<p>You need at least <code>Alt</code> to be able to interpret out of a <code>These1</code>, because you need to be able to handle the case where you have <em>both</em> <code>f</code> and <code>g</code>, and need to combine the result.</p></li>
<li><p><strong>Identity</strong></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">type</span> <span class="dt">I</span> <span class="dt">These1</span> <span class="ot">=</span> <span class="dt">Void</span></span></code></pre></div>
<p><code>These1 f Void</code> is equivalent to just <code>f</code>, because it means the <code>That1</code> and <code>These1</code> branches will be impossible to construct, and you are left with only the <code>This1</code> branch.</p></li>
<li><p><strong>Induced Monoid</strong></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">type</span> <span class="dt">SF</span> <span class="dt">These1</span> <span class="ot">=</span> <span class="dt">ComposeT</span> <span class="dt">Flagged</span> <span class="dt">Steps</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="kw">type</span> <span class="dt">MF</span> <span class="dt">These1</span> <span class="ot">=</span> <span class="dt">Steps</span></span></code></pre></div>
<p><code>Steps</code> is the result of an infinite application of `These1 to the same value:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">type</span> <span class="dt">Steps</span> f <span class="ot">=</span> f <span class="ot">`These1`</span> f <span class="ot">`These1`</span> f <span class="ot">`These1`</span> f <span class="ot">`These1`</span> <span class="op">...</span> etc<span class="op">.</span></span></code></pre></div>
<p>It essentially represents an infinite <em>sparse</em> array of <code>f a</code>s, where an <code>f a</code> might exist at many different positions, with gaps here and there. There is always at least <em>one</em> <code>f a</code>.</p>
<p>Like <code>Step</code>, it’s not particularly useful, but it can be used in situations where you want a giant infinite sparse array of <code>f a</code>s, each at a given position, with many gaps between them.</p>
<p>The induced semigroupoidal functor requires an extra “flag” because of some of the quirks of the definition of semigroupoidal functor: It’s a <code>Steps</code>, but also with a boolean flag telling you if it was made using <code>inject</code> or some other method.</p></li>
</ul>
<h4 id="leftf-rightf">LeftF / RightF</h4>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html">Data.HBifunctor</a></em> (for <code>LeftF</code> and <code>RightF</code>)</p></li>
<li><p><strong>Mixing Strategy</strong>: “Ignore the left” / “ignore the right”.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">data</span> <span class="dt">LeftF</span>  f g a <span class="ot">=</span> <span class="dt">LeftF</span>  {<span class="ot"> runLeftF  ::</span> f a }</span>
<span id="cb40-2"><a href="#cb40-2"></a></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="kw">data</span> <span class="dt">RightF</span> f g a <span class="ot">=</span> <span class="dt">RightF</span> {<span class="ot"> runRightF ::</span> g a }</span></code></pre></div>
<p>You can think of <code>LeftF</code> as “<code>:+:</code> without the Right case, <code>R1</code>”, or <code>RightF</code> as “<code>:+:</code> without the Left case, <code>L1</code>”. <code>RightF f</code> is also equivalent to <code>IdentityT</code> for any <code>f</code>.</p>
<p>This can be useful if you want the second (or first) argument to be ignored, and only be used maybe at the type level.</p>
<p>For example, <code>RightF IgnoreMe MyFunctor</code> is equivalent to just <code>MyFunctor</code>, but you might want to use <code>IgnoreMe</code> as a phantom type to help limit what values can be used for what functions.</p></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">type</span> <span class="dt">CS</span> <span class="dt">LeftF</span>  <span class="ot">=</span> <span class="dt">Unconstrained</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="kw">type</span> <span class="dt">CS</span> <span class="dt">RightF</span> <span class="ot">=</span> <span class="dt">Unconstrained</span></span></code></pre></div>
<p>Interpreting out of either of these is unconstrained, and can be done in any context.</p></li>
<li><p><strong>Identity</strong></p>
<p>Unlike the previous functor combinators, these three are only <code>Semigroupoidal</code>, not <code>Monoidal</code>: this is because there is no functor <code>i</code> such that <code>LeftF i g</code> is equal to <code>g</code>, for all <code>g</code>, and no functor <code>i</code> such that <code>RightF f i</code> is equal to <code>f</code>, for all <code>f</code>.</p></li>
<li><p><strong>Induced Semigroup</strong></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">type</span> <span class="dt">SF</span> <span class="dt">LeftF</span> <span class="ot">=</span> <span class="dt">Flagged</span></span></code></pre></div>
<p>For <code>LeftF</code>, the induced semigroup is <code>Flagged</code>, which is the <code>f a</code> tupled with a <code>Bool</code>. See the information on <code>Flagged</code> for more details. This can be useful as a type that marks if an <code>f</code> is made with <code>inject</code>/<code>pure</code> and is “pure” (<code>False</code>), or “tainted” (<code>True</code>). The <em>provider</em> of an <code>EnvT Any f</code> can specify “pure or tainted”, and the <em>interpreter</em> can make a decision based on that tag.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">type</span> <span class="dt">SF</span> <span class="dt">RightF</span> <span class="ot">=</span> <span class="dt">Step</span></span></code></pre></div>
<p>For <code>RightF</code>, the induced semigroup is <code>Step</code>. See <code>Step</code> and the information on <code>:+:</code> for more details. This can be useful for having a value of <code>f a</code> at “some point”, indexed by a <code>Natural</code>.</p></li>
</ul></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/functor-combinatorpedia.html';
    this.page.identifier = 'functor-combinatorpedia';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>