<!DOCTYPE HTML>
<html><head><title>The Functor Combinatorpedia · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Recently I’ve been very productive what I have been calling the “Functor Combinator” design pattern. It is heavily influenced by ideas like Data types a la Carte and unified free monoidal functors, but the end goal is slightly different in spirit. The goal is to represent schemas, DSL’s, and computations (things like parsers, things to execute, things to consume or produce data) by assembling “self-evident” basic primitives and subjecting them to many different successive transformations and combiners. The process of doing so:  * Forces you to make explicit decisions about the structure of your computation type as an ADT. * Allows you to retain isolation of fundamental parts of your domain as separate types * Lets you manipulate the structure of your final computation type through normal Haskell techniques like pattern matching. The structure is available throughout the entire process, so you can replace individual components and values within your structure. * Allows you to fully reflect the structure of your final computation through pattern matching and folds, so you can inspect the structure and produce useful summaries. Like “data types a la carte” and free monad/applicative/alternative designs, these techniques allow you to separate the assembly and inspection of your programs from the “running” of them. However, the main difference is that here we focus not just on products and sums, but many different varied and multi-purpose combinators — a bona fide “zoo” of combinators. The fixed point is not “the end goal”. This post is a run-down on the wide variety of such “functor combinators” across the Haskell ecosystem — a functor combinator “zoo” of sorts. To speak about them all with the same language and vocabulary, this post also serves as an overview of the functor-combinators library, which mostly pulls them all together and provides a unified interface for working with them. Most of these types and typeclasses are exported by Data.Functor.Combinator. For concrete examples on using these, see my previous articles on free structures). In a way, this post also serves as a run-down of all the popular free structures in Haskell :)"><meta property="og:type" content="article"><meta property="og:title" content="The Functor Combinatorpedia"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/functor-combinatorpedia.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/functor-combinatorpedia.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">The Functor Combinatorpedia</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/functor-combinatorpedia.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/functor-combinatorpedia.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/functor-combinatorpedia.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Recently I’ve been very productive what I have been calling the “Functor Combinator” design pattern. It is heavily influenced by ideas like <a href="http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf">Data types a la Carte</a> and <a href="http://oleg.fi/gists/posts/2018-02-21-single-free.html">unified free monoidal functors</a>, but the end goal is slightly different in spirit.</p>
<p>The goal is to represent schemas, DSL’s, and computations (things like parsers, things to execute, things to consume or produce data) by assembling “self-evident” basic primitives and subjecting them to many <em>different</em> successive transformations and combiners. The process of doing so:</p>
<ol type="1">
<li>Forces you to make explicit decisions about the structure of your computation type as an ADT.</li>
<li>Allows you to retain isolation of fundamental parts of your domain as separate types</li>
<li>Lets you manipulate the structure of your final computation type through <em>normal Haskell techniques</em> like pattern matching. The structure is available throughout the entire process, so you can replace individual components and values within your structure.</li>
<li>Allows you to fully <em>reflect</em> the structure of your final computation through pattern matching and folds, so you can inspect the structure and produce useful summaries.</li>
</ol>
<p>Like “data types a la carte” and free monad/applicative/alternative designs, these techniques allow you to separate the assembly and inspection of your programs from the “running” of them. However, the main difference is that here we focus not just on products and sums, but many different varied and multi-purpose combinators — a bona fide “zoo” of combinators. The fixed point is not “the end goal”.</p>
<p>This post is a run-down on the wide variety of such “functor combinators” across the Haskell ecosystem — a functor combinator “zoo” of sorts. To speak about them all with the same language and vocabulary, this post also serves as an overview of the <em><a href="https://hackage.haskell.org/package/functor-combinators">functor-combinators</a></em> library, which mostly pulls them all together and provides a unified interface for working with them. Most of these types and typeclasses are exported by <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Combinator.html">Data.Functor.Combinator</a></em>.</p>
<p>For concrete examples on <em>using</em> these, see my previous <a href="https://blog.jle.im/entry/alchemical-groups.html">articles</a> <a href="https://blog.jle.im/entry/interpreters-a-la-carte-duet.html">on</a> <a href="https://blog.jle.im/entry/const-applicative-and-monoids.html">free</a> <a href="https://blog.jle.im/entry/free-alternative-regexp.html">structures</a>). In a way, this post also serves as a run-down of all the popular free structures in Haskell :)</p>
<p>Please refer to the <a href="https://blog.jle.im/entry/functor-combinatorpedia.html#title">table of contents</a> if you are using this as a reference!</p>
<h2 id="prologue-what-is-a-functor-combinator">Prologue: What is a functor combinator?</h2>
<p>A functor combinator takes “functors” (or other indexed types) and returns a new functor, enhances or mixes them together in some way. That is, they take things of kind <code>k -&gt; Type</code> and themselves return a <code>k -&gt; Type</code>. This lets us build complex functors out of simpler “primitive” ones.</p>
<p>For example, <code>ReaderT r</code> is a famous one that takes a functor <code>f</code> and enhances it with “access to an <code>r</code> environment” functionality. Another famous one is <code>Free</code>, which takes a functor <code>f</code> and enhances it with “sequential binding” capabilities: it turns <code>f</code> into a <code>Monad</code>.</p>
<p>The main thing that distinguishes these functor combinators from things like monad transformers is that they are “natural on <code>f</code>”: they work on <em>all</em> <code>f</code>s, not just monads, and assume no structure.</p>
<p>Sometimes, we have binary functor combinators, like <code>:+:</code>, which takes two functors <code>f</code> and <code>g</code> and returns a functor that is “either” <code>f</code> or <code>g</code>. Binary functor combinators “mix together” the functionality of different functors in different ways.</p>
<h3 id="examples">Examples</h3>
<p>If your final DSL/program/schema is some functor, then functor combinators allow you to construct your final functor by combining simpler “primitive” functors, and take advantage of common functionality.</p>
<p>For example, if you were making a data type/EDSL to describe a command line parser, you might have two primitives: <code>data Arg a</code>, for positional arguments parsing <code>a</code>, and <code>data Option a</code>, for <code>--flag</code> non-positional options parsing <code>a</code>. From there, you can <em>choose</em> what structure of command line arguments you want to be able to express.</p>
<p>For instance, a structure that can support multiple arguments and optionally a single <code>Option</code> would be:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> <span class="dt">CommandArgs</span> <span class="ot">=</span> <span class="dt">Ap</span> <span class="dt">Arg</span> <span class="op">:*:</span> <span class="dt">Lift</span> <span class="dt">Option</span></span></code></pre></div>
<p>And a structure that supports <em>multiple commands</em> on top of that would be:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">type</span> <span class="dt">CommandArgs</span> <span class="ot">=</span> <span class="dt">MapF</span> <span class="dt">String</span> (<span class="dt">Ap</span> <span class="dt">Arg</span> <span class="op">:*:</span> <span class="dt">Lift</span> <span class="dt">Option</span>)</span></code></pre></div>
<p>You can mix or match combinators to decide exactly what sort of structures you allow in your DSL.</p>
<p>Now, instead of writing one “giant” <code>runParser :: MapF String (Ap Arg :*: Lift Option) a -&gt; IO a</code> function, you can instead just write parsers for your simple primitives <code>Arg a -&gt; IO a</code> and <code>Option a -&gt; IO a</code>, and then use functor combinator tools to “promote” them to being runnable on a full <code>MapF String (Ap Arg :*: Lift Option)</code> without any extra work.</p>
<h3 id="common-functionality">Common Functionality</h3>
<p>Most of these functor combinators allow us to “swap out” the underlying functor, retaining all of the “enhanced” structure. We abstract over all of these using <code>hmap</code> for single-argument functor combinators (“enhancers”) and <code>hbimap</code> for two-argument functor combinators (“mixers”).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">class</span> <span class="dt">HFunctor</span> t <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="co">-- | Swap out underlying functor for a single-argument functor combinator</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    hmap</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="ot">        ::</span> t f a <span class="ot">-&gt;</span> t g a</span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="kw">class</span> <span class="dt">HBifunctor</span> t <span class="kw">where</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="co">-- | Swap out underlying functors for a two-argument functor combinator</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    hbimap</span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="ot">        ::</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> h x)</span>
<span id="cb3-10"><a href="#cb3-10"></a>        <span class="ot">-&gt;</span> (<span class="kw">forall</span> x<span class="op">.</span> g x <span class="ot">-&gt;</span> j x)</span>
<span id="cb3-11"><a href="#cb3-11"></a>        <span class="ot">-&gt;</span> t f g a</span>
<span id="cb3-12"><a href="#cb3-12"></a>        <span class="ot">-&gt;</span> t g j a</span></code></pre></div>
<p>However, for this post, the concept of a “natural transformation” between <code>f</code> and <code>g</code> — a function of type <code>forall x. f x -&gt; g x</code>, is given a type synonym:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">type</span> f <span class="op">~&gt;</span> g <span class="ot">=</span> <span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> g x</span></code></pre></div>
<p>Then the type signatures of <code>hmap</code> and <code>hbimap</code> become:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">class</span> <span class="dt">HFunctor</span> t <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>    hmap</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="ot">        ::</span> t f <span class="op">~&gt;</span> t g</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">class</span> <span class="dt">HBifunctor</span> t <span class="kw">where</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    hbimap</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="ot">        ::</span> f <span class="op">~&gt;</span> h</span>
<span id="cb5-8"><a href="#cb5-8"></a>        <span class="ot">-&gt;</span> g <span class="op">~&gt;</span> j</span>
<span id="cb5-9"><a href="#cb5-9"></a>        <span class="ot">-&gt;</span> t f g <span class="op">~&gt;</span> t h j</span></code></pre></div>
<p>What does it mean exactly when we say that <code>hmap</code> and <code>hbimap</code> “preserve the enhanced structure”? Well, for example, <code>ListF f a</code> is essentially a list of <code>f a</code>s. <code>hmap</code> will swap out and replace each <code>f a</code>, but it must <em>preserve the relative order</em> between each of the original <code>f a</code>s. And it must preserve the length of the list. It’s a complete “in-place swap”. This is formalizing by requiring <code>hmap id == id</code> and <code>hbimap id id == id</code>.</p>
<p>You can also always “lift” a functor value into its transformed type. We abstract over this by using <code>inject</code> (for single-argument functors) and <code>inL</code> and <code>inR</code> (for two-argument functors):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">class</span> <span class="dt">Inject</span> t <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="co">-- | Lift `f` into `t f`</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="ot">    inject ::</span> f <span class="op">~&gt;</span> t f</span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="ot">inL ::</span> (<span class="dt">Monoidal</span> t, <span class="dt">CM</span> t g)     <span class="co">-- more on the `CM t` later</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> t f g</span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="ot">inR ::</span> (<span class="dt">Monoidal</span> t, <span class="dt">CM</span> t f)     <span class="co">-- more on the `CM t` later</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="ot">=&gt;</span> g <span class="op">~&gt;</span> t f g</span></code></pre></div>
<p>Finally, in order to <em>use</em> any functor combinators, you have to <em>interpret</em> them into some target context. The choice of combinator imposes some constraints on the target context. We abstract over this using <code>interpret</code> and <code>binterpret</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">class</span> <span class="dt">Interpret</span> t <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="kw">type</span> <span class="dt">C</span><span class="ot"> t ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="co">-- | Interpret unary functor combinator</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    interpret</span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="ot">        ::</span> <span class="dt">C</span> t g</span>
<span id="cb7-7"><a href="#cb7-7"></a>        <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g             <span class="co">-- ^ interpreting function</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>        <span class="ot">-&gt;</span> t f <span class="op">~&gt;</span> g</span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw">class</span> <span class="dt">Semigroupoidal</span> t <span class="kw">where</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="co">-- | Interpret binary functor combinator</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>    binterpret</span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="ot">        ::</span> <span class="dt">CS</span> t h</span>
<span id="cb7-14"><a href="#cb7-14"></a>        <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> h             <span class="co">-- ^ interpreting function on f</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>        <span class="ot">=&gt;</span> g <span class="op">~&gt;</span> h             <span class="co">-- ^ interpreting function on g</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>        <span class="ot">-&gt;</span> t f g <span class="op">~&gt;</span> h</span></code></pre></div>
<p>Each functor combinator defines a constraint (<code>C</code> for unary functor combinators, and <code>CS</code> and <code>CM</code> for binary functor combinators) that allows you to “exit”, or “run” the functor combinator.</p>
<p>For some concrete examples:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Free</span> <span class="ot">=</span> <span class="dt">Monad</span></span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a>interpret <span class="op">@</span><span class="dt">Free</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="ot">    ::</span> <span class="dt">Monad</span> g</span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="ot">=&gt;</span> (f <span class="op">~&gt;</span> g)</span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="ot">-&gt;</span> g a</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="kw">type</span> <span class="dt">CM</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Unconstrained</span>   <span class="co">-- no constraints on exiting</span></span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a>binterpret <span class="op">@</span>(<span class="op">:+:</span>)</span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="ot">    ::</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="ot">-&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="ot">-&gt;</span> (f <span class="op">:+:</span> g) a</span>
<span id="cb8-15"><a href="#cb8-15"></a>    <span class="ot">-&gt;</span> h a</span></code></pre></div>
<p>We see that <code>interpret</code> lets you “run” a <code>Free</code> in any monad <code>g</code>, and <code>binterpret</code> lets you “run” a function over both <em>branches</em> of an <code>f :+: g</code> to produce an <code>h</code>.</p>
<p>From these, we can also build a lot of useful utility functions (like <code>retract</code>, <code>biretract</code>, <code>getI</code>, <code>biget</code>, etc.) for convenience in actually working on them. These are provided in <em><a href="https://hackage.haskell.org/package/functor-combinators">functor-combinators</a></em>.</p>
<p>Without further ado, let’s dive into the zoo of functor combinators!</p>
<h2 id="two-argument">Two-Argument</h2>
<p>Binary functor combinators “mix together” two functors/indexed types in different ways.</p>
<p>We can finally <em>interpret</em> (or “run”) these into some target context (like <code>Parser</code>, or <code>IO</code>), provided the target satisfies some constraints.</p>
<p>We can separate the functionality associated with each binary functor combinator into two typeclasses: <code>Semigroupoidal</code> and <code>Monoidal</code>. <code>Semigroupoidal</code> deals with the “interpreting” and “collapsing” of the mixed functors, and <code>Monoidal</code> deals with the “introduction” and “creation” of them. A more detailed run-down is available in the docs for <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Combinator.html">Data.Functor.Combinator</a></em>.</p>
<p>From each we have two associated constraints, <code>CS t</code> (for <code>Semigroupoidal</code>) and <code>CM t</code> (for <code>Monoidal</code>):</p>
<ul>
<li><p><code>CS t</code> is what we will call the constraint on where you can <em>interpret</em> or <em>run</em> values of the enhanced type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a>binterpret</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ot">    ::</span> (<span class="dt">Semigroupoidal</span> t, <span class="dt">CS</span> t h)</span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="ot">=&gt;</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="ot">=&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="ot">-&gt;</span> (t f g <span class="op">~&gt;</span> h)</span></code></pre></div></li>
<li><p><code>CM t</code> is the constraint on where you can <em>create</em> values of the enhanced type (<code>pureT</code>, <code>inL</code>, <code>inR</code>)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a>pureT</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ot">    ::</span> (<span class="dt">Monoidal</span> t, <span class="dt">CM</span> t f)</span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="ot">=&gt;</span> <span class="dt">I</span> t <span class="op">~&gt;</span> f</span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="ot">inL ::</span> (<span class="dt">Monoidal</span> t, <span class="dt">CM</span> t g)</span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> t f g</span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="ot">inR ::</span> (<span class="dt">Monoidal</span> t, <span class="dt">CM</span> t f)</span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="ot">=&gt;</span> g <span class="op">~&gt;</span> t f g</span></code></pre></div>
<p>It should always be a subclass of <code>CS</code>.</p></li>
</ul>
<p>These constraints all depend on the extra structure that the specific functor combinator imbues.</p>
<p>As it turns out, <code>CS</code> and <code>CM</code> generalize the “has an identity” property of many typeclasses — for example, for <code>Comp</code> (functor composition), <code>CS</code> is <code>Bind</code> (“<code>Monad</code> without <code>pure</code>”), and <code>CM</code> is <code>Monad</code>.</p>
<p>Most of these also have an identity functor, <code>I t</code>, where applying <code>t f (I t)</code> leaves <code>f</code> unchanged (<code>t f (I t)</code> is isomorphic to <code>f</code>) and <code>t (I t) f</code> is also just <code>f</code>. This is represented by the associated type <code>I t</code> (examples will be provided below).</p>
<p>One interesting property of these is that for a lot of these, if we have a binary functor combinator <code>*</code>, we can represent a type <code>f | f * f | f * f * f | f * f * f * f | ...</code> (“repeatedly apply to something multiple times”), which essentially forms a linked list along that functor combinator. We call this the “induced monoidal functor combinator”, given by <code>MF t</code>. We can also make a “non-empty variant”, <code>SF t</code>, the “induced semigroupoidal functor combinator”, which contains “at least one <code>f</code>” (examples provided below).</p>
<p>They all support functions for “converting” back and forth, like <code>toMF :: t f f ~&gt; MF f</code> (provided by <em>functor-combinators</em> in the <code>Monoidal</code> typeclass).</p>
<p>This is all a bit abstract, but let’s dive into some actual examples, which will make these all clearer.</p>
<h3 id="sum">:+: / Sum</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/base/docs/GHC-Generics.html">GHC.Generics</a></em> (for <code>:+:</code>) / <em><a href="https://hackage.haskell.org/package/base/docs/Data-Functor-Sum.html">Data.Functor.Sum</a></em> (for <code>Sum</code>)</p></li>
<li><p><strong>Mixing Strategy</strong>: “Either-or”: provide either case, and user has to handle both possibilities. Basically higher-order <code>Either</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">data</span> (f <span class="op">:+:</span> g) a</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="ot">=</span> <span class="dt">L1</span> (f a)</span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="op">|</span> <span class="dt">R1</span> (g a)</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="kw">data</span> <span class="dt">Sum</span> f g a</span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="ot">=</span> <span class="dt">InL</span> (f a)</span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="op">|</span> <span class="dt">InR</span> (g a)</span></code></pre></div>
<p>It can be useful for situations where you can validly use one or the other in your schema or functor. For example, if you are describing an HTTP request, we could have <code>data GET a</code> describing a GET request and <code>data POST a</code> describing a POST request; <code>(GET :+: POST) a</code> would be a functor that describes either a GET or POST request.</p>
<p>The person who creates the <code>f :+: g</code> decides which one to give, and the person who consumes/interprets/runs the <code>f :+: g</code> must provide a way of handling <em>both</em></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a>binterpret <span class="op">@</span>(<span class="op">:+:</span>)</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="ot">    ::</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="ot">-&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb12-4"><a href="#cb12-4"></a>    <span class="ot">-&gt;</span> (f <span class="op">:+:</span> g) a</span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="ot">-&gt;</span> h a</span></code></pre></div>
<p><code>binterpret</code> becomes analogous to <code>either</code> from <em><a href="https://hackage.haskell.org/package/base/docs/Data-Either.html">Data.Either</a></em></p></li>
<li><p><strong>Identity</strong></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">type</span> <span class="dt">I</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Void1</span></span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co">-- | Data type with no inhabitants</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="kw">data</span> <span class="dt">Void1</span> a</span></code></pre></div>
<p><code>f :+: Void1</code> is equivalent to just <code>f</code>, because you can never have a value of the right branch.</p></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">type</span> <span class="dt">CS</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Unconstrained</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">type</span> <span class="dt">CM</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Unconstrained</span></span>
<span id="cb14-3"><a href="#cb14-3"></a></span>
<span id="cb14-4"><a href="#cb14-4"></a>binterpret <span class="op">@</span>(<span class="op">:+:</span>)</span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="ot">    ::</span> f <span class="op">~&gt;</span> h</span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="ot">-&gt;</span> g <span class="op">~&gt;</span> h</span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="ot">-&gt;</span> (f <span class="op">:+:</span> g) <span class="op">~&gt;</span> h</span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a>inL   <span class="op">@</span><span class="ot">(:+:) ::</span> f     <span class="op">~&gt;</span> f <span class="op">:+:</span> g</span>
<span id="cb14-10"><a href="#cb14-10"></a>inR   <span class="op">@</span><span class="ot">(:+:) ::</span> g     <span class="op">~&gt;</span> f <span class="op">:+:</span> g</span>
<span id="cb14-11"><a href="#cb14-11"></a>pureT <span class="op">@</span><span class="ot">(:+:) ::</span> <span class="dt">Void1</span> <span class="op">~&gt;</span> h</span></code></pre></div>
<p>You don’t need any constraint in order to use <code>binterpret</code>, <code>inL</code>, <code>inR</code>, etc.</p>
<p>However, note that <code>pureT</code> is effectively impossible to call, because no values of type <code>Void1 a</code> exist.</p></li>
<li><p><strong>Induced Monoid</strong></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">type</span> <span class="dt">SF</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Step</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">type</span> <span class="dt">MF</span> (<span class="op">:+:</span>) <span class="ot">=</span> <span class="dt">Step</span></span></code></pre></div>
<p><code>Step</code> is the result of an infinite application of <code>:+:</code> to the same value:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">type</span> <span class="dt">Step</span> f <span class="ot">=</span> f <span class="op">:+:</span> f <span class="op">:+:</span> f <span class="op">:+:</span> f <span class="op">:+:</span> f <span class="op">:+:</span> f <span class="op">:+:</span> <span class="op">...</span> etc<span class="op">.</span></span></code></pre></div>
<p>The correspondence is:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="dt">L1</span> x           <span class="op">&lt;=&gt;</span> <span class="dt">Step</span> <span class="dv">0</span> x</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="dt">R1</span> (<span class="dt">L1</span> y)      <span class="op">&lt;=&gt;</span> <span class="dt">Step</span> <span class="dv">1</span> y</span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="dt">R1</span> (<span class="dt">R1</span> (<span class="dt">L1</span> z)) <span class="op">&lt;=&gt;</span> <span class="dt">Step</span> <span class="dv">2</span> z</span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="co">-- etc.</span></span></code></pre></div>
<p>It’s not a particularly useful type, but it can be useful if you want to provide an <code>f a</code> alongside “which position” it is on the infinite list. Repeatedly using <code>consMF</code> will push the <code>f</code> further and further along the list.</p></li>
</ul>
<h3 id="product">:*: / Product</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/base/docs/GHC-Generics.html">GHC.Generics</a></em> (for <code>:*:</code>) / <em><a href="https://hackage.haskell.org/package/base/docs/Data-Functor-Product.html">Data.Functor.Product</a></em> (for <code>Product</code>)</p></li>
<li><p><strong>Mixing Strategy</strong>: “Both, separately”: provide values from <em>both</em> functors, and the user can choose which one they want to use. Basically a higher-order tuple.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">data</span> (f <span class="op">:*:</span> g) a <span class="ot">=</span> f a <span class="op">:*:</span> g a</span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="kw">data</span> <span class="dt">Product</span> f g a <span class="ot">=</span> <span class="dt">Pair</span> (f a) (g a)</span></code></pre></div>
<p>It can be useful for situations where your schema/functor must be <em>specified</em> using <em>both</em> functors, but the <em>interpreter</em> can choose to use only one or the other (or both).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">prodOutL ::</span> (f <span class="op">:*:</span> g) <span class="op">~&gt;</span> f</span>
<span id="cb19-2"><a href="#cb19-2"></a>prodOutL (x <span class="op">:*:</span> _) <span class="ot">=</span> x</span>
<span id="cb19-3"><a href="#cb19-3"></a></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="ot">prodOutR ::</span> (f <span class="op">:*:</span> g) <span class="op">~&gt;</span> g</span>
<span id="cb19-5"><a href="#cb19-5"></a>prodOutR (_ <span class="op">:*:</span> y) <span class="ot">=</span> y</span></code></pre></div></li>
<li><p><strong>Identity</strong></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">type</span> <span class="dt">I</span> (<span class="op">:*:</span>) <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="co">-- | Data type with only a single constructor and no information</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="kw">data</span> <span class="dt">Proxy</span> a <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p><code>f :+: Proxy</code> is equivalent to just <code>f</code>, because the left hand side doesn’t add anything extra to the pair.</p></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">type</span> <span class="dt">CS</span> (<span class="op">:*:</span>) <span class="ot">=</span> <span class="dt">Alt</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="kw">type</span> <span class="dt">CM</span> (<span class="op">:*:</span>) <span class="ot">=</span> <span class="dt">Plus</span></span>
<span id="cb21-3"><a href="#cb21-3"></a></span>
<span id="cb21-4"><a href="#cb21-4"></a>binterpret <span class="op">@</span>(<span class="op">:*:</span>)</span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="ot">    ::</span> <span class="dt">Alt</span> h</span>
<span id="cb21-6"><a href="#cb21-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> h</span>
<span id="cb21-7"><a href="#cb21-7"></a>    <span class="ot">-&gt;</span> g <span class="op">~&gt;</span> h</span>
<span id="cb21-8"><a href="#cb21-8"></a>    <span class="ot">-&gt;</span> (f <span class="op">:*:</span> g) <span class="op">~&gt;</span> h</span>
<span id="cb21-9"><a href="#cb21-9"></a></span>
<span id="cb21-10"><a href="#cb21-10"></a>inL   <span class="op">@</span><span class="ot">(:*:) ::</span> <span class="dt">Plus</span> g <span class="ot">=&gt;</span> f     <span class="op">~&gt;</span> f <span class="op">:*:</span> g</span>
<span id="cb21-11"><a href="#cb21-11"></a>inR   <span class="op">@</span><span class="ot">(:*:) ::</span> <span class="dt">Plus</span> f <span class="ot">=&gt;</span> g     <span class="op">~&gt;</span> f <span class="op">:*:</span> g</span>
<span id="cb21-12"><a href="#cb21-12"></a>pureT <span class="op">@</span><span class="ot">(:*:) ::</span> <span class="dt">Plus</span> h <span class="ot">=&gt;</span> <span class="dt">Proxy</span> <span class="op">~&gt;</span> h</span></code></pre></div>
<p><code>Alt</code>, from <em><a href="https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Alt.html">Data.Functor.Alt</a></em> in <em>semigroupoids</em>, can be thought of a “higher-kinded semigroup”: it’s like <code>Alternative</code>, but with no <code>Applicative</code> constraint and no identity:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">class</span> <span class="dt">Alt</span> f <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="ot">    (&lt;!&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>It is used to combine the results in both branches of the <code>:*:</code>.</p>
<p>To introduce an “empty” branch, we need <code>Plus</code> (in <em><a href="https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Plus.html">Data.Functor.Plus</a></em>), which is like a higher-kinded <code>Monoid</code>, or <code>Alternative</code> with no <code>Applicative</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">class</span> <span class="dt">Alt</span> f <span class="ot">=&gt;</span> <span class="dt">Plus</span> f <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="ot">    zero ::</span> f a</span></code></pre></div></li>
<li><p><strong>Induced Monoid</strong></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">type</span> <span class="dt">SF</span> (<span class="op">:*:</span>) <span class="ot">=</span> <span class="dt">NonEmptyF</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="kw">type</span> <span class="dt">MF</span> (<span class="op">:*:</span>) <span class="ot">=</span> <span class="dt">ListF</span></span></code></pre></div>
<p><code>ListF f a</code> is a “list of <code>f a</code>s”. It represents the posibility of having <code>Proxy</code> (zero items), <code>x :: f a</code> (one item), <code>x :*: y</code> (two items), <code>x :*: y :*: z</code> (three items), etc.</p>
<p>It’s basically an ordered collection of <code>f a</code>s <code>:*:</code>d with each other.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="dt">Proxy</span>         <span class="op">&lt;=&gt;</span> <span class="dt">ListF</span> []</span>
<span id="cb25-2"><a href="#cb25-2"></a>x             <span class="op">&lt;=&gt;</span> <span class="dt">ListF</span> [x]</span>
<span id="cb25-3"><a href="#cb25-3"></a>x <span class="op">:*:</span> y       <span class="op">&lt;=&gt;</span> <span class="dt">ListF</span> [x,y]</span>
<span id="cb25-4"><a href="#cb25-4"></a>x <span class="op">:*:</span> y <span class="op">:*:</span> z <span class="op">&lt;=&gt;</span> <span class="dt">ListF</span> [x,y,z]</span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="co">-- etc.</span></span></code></pre></div>
<p>It is useful if you want to define a schema where you can offer <em>multiple</em> options for the <code>f a</code>, and the interpreter/consumer can freely pick any one that they want to use.</p>
<p><code>NonEmptyF</code> is the version of <code>ListF</code> that has “at least one <code>f a</code>”.</p>
<p>See the information later on <code>ListF</code> alone (in the single-argument functor combinator section) for more information on usage and utility.</p></li>
</ul>
<h3 id="day">Day</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Day.html">Data.Functor.Day</a></em></p></li>
<li><p><strong>Mixing Strategy</strong>: “Both, together forever”: provide values from <em>both</em> functors, and the user <em>must</em> also <em>use</em> both.</p>
<p>It can be useful for situations where your schema/functor must be <em>specified</em> using <em>both</em> functors, and the user must also <em>use</em> both.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a>binterpret <span class="op">@</span><span class="dt">Day</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="ot">    ::</span> <span class="dt">Apply</span> h          <span class="co">-- superclass of Applicative</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>    <span class="ot">=&gt;</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb26-4"><a href="#cb26-4"></a>    <span class="ot">-&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb26-5"><a href="#cb26-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Day</span> f g <span class="op">~&gt;</span> h</span></code></pre></div>
<p>Unlike for <code>:*:</code>, you always have to interpret <em>both</em> functor values in order to interpret a <code>Day</code>. It’s a “full mixing”.</p></li>
<li><p><strong>Identity</strong></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">type</span> <span class="dt">I</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Identity</span></span></code></pre></div>
<p><code>Day f Identity</code> is equivalent to just <code>f</code>, because <code>Identity</code> adds no extra effects or structure.</p></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">type</span> <span class="dt">CS</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Apply</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="kw">type</span> <span class="dt">CM</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Applicative</span></span>
<span id="cb28-3"><a href="#cb28-3"></a></span>
<span id="cb28-4"><a href="#cb28-4"></a>binterpret <span class="op">@</span><span class="dt">Day</span></span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="ot">    ::</span> <span class="dt">Apply</span> h</span>
<span id="cb28-6"><a href="#cb28-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> h</span>
<span id="cb28-7"><a href="#cb28-7"></a>    <span class="ot">-&gt;</span> g <span class="op">~&gt;</span> h</span>
<span id="cb28-8"><a href="#cb28-8"></a>    <span class="ot">-&gt;</span> <span class="dt">Day</span> f g <span class="op">~&gt;</span> h</span>
<span id="cb28-9"><a href="#cb28-9"></a></span>
<span id="cb28-10"><a href="#cb28-10"></a>inL   <span class="op">@</span><span class="dt">Day</span><span class="ot"> ::</span> <span class="dt">Applicative</span> g <span class="ot">=&gt;</span> f        <span class="op">~&gt;</span> <span class="dt">Day</span> f g</span>
<span id="cb28-11"><a href="#cb28-11"></a>inR   <span class="op">@</span><span class="dt">Day</span><span class="ot"> ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> g        <span class="op">~&gt;</span> <span class="dt">Day</span> f g</span>
<span id="cb28-12"><a href="#cb28-12"></a>pureT <span class="op">@</span><span class="dt">Day</span><span class="ot"> ::</span> <span class="dt">Applicative</span> h <span class="ot">=&gt;</span> <span class="dt">Identity</span> <span class="op">~&gt;</span> h</span></code></pre></div>
<p><code>Apply</code>, from <em><a href="https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Apply.html">Data.Functor.Apply</a></em> in <em>semigroupoids</em>, is “<code>Applicative</code> without <code>pure</code>”; it only has <code>&lt;*&gt;</code> (called <code>&lt;.&gt;</code>).</p>
<p><code>pureT</code> is essentially <code>pure :: Applicative h =&gt; a -&gt; h a</code>.</p></li>
<li><p><strong>Induced Monoid</strong></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">type</span> <span class="dt">SF</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Ap1</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="kw">type</span> <span class="dt">MF</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Ap</span></span></code></pre></div>
<p><code>Ap f a</code> is a bunch of <code>f x</code>s <code>Day</code>d with each other. It is either:</p>
<ul>
<li><code>a</code> (zero <code>f</code>s)</li>
<li><code>f a</code> (one <code>f</code>)</li>
<li><code>Day f f a</code> (two <code>f</code>s)</li>
<li><code>Day f (Day f f) a</code> (three <code>f</code>s)</li>
<li>.. etc.</li>
</ul>
<p>Like <code>ListF</code> this is very useful if you want your schema to provide a “bag” of <code>f a</code>s and your interpreter <em>must use all of them</em>.</p>
<p>For example, if we have a schema for a command line argument parser, each <code>f</code> may represent a command line option. To interpret it, we must look at <em>all</em> command line options.</p>
<p><code>Ap1</code> is a version with “at least one” <code>f a</code>.</p>
<p>See the information later on <code>Ap</code> alone (in the single-argument functor combinator section) for more information on usage and utility.</p></li>
</ul>
<h3 id="comp">Comp</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Control-Monad-Freer-Church.html">Control.Monad.Freer.Church</a></em>. Note that an equivalent type is also found in <em><a href="https://hackage.haskell.org/package/base/docs/GHC-Generics.html">GHC.Generics</a></em> and <em><a href="https://hackage.haskell.org/package/base/docs/Data-Functor-Compose.html">Data.Functor.Compose</a></em>, but they are incompatible with the <code>HBifunctor</code> typeclass because they require the second input to have a <code>Functor</code> instance.</p></li>
<li><p><strong>Mixing Strategy</strong>: “Both, together, sequentially” : provide values from <em>both</em> functors; the user must <em>use</em> both, and <em>in order</em>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">data</span> <span class="dt">Comp</span> f g a <span class="ot">=</span> <span class="dt">Comp</span> (f (g a))</span></code></pre></div>
<p>It can be useful for situations where your schema/functor must be specified using both functors, and the user must <em>use</em> both, but also enforcing that they must use both in the <em>given order</em>: that is, for a <code>Comp f g</code>, they interpret <code>f</code> <em>before</em> they interpret <code>g</code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a>binterpret <span class="op">@</span><span class="dt">Day</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="ot">    ::</span> <span class="dt">Bind</span> h          <span class="co">-- superclass of Monad</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>    <span class="ot">=&gt;</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb31-4"><a href="#cb31-4"></a>    <span class="ot">-&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb31-5"><a href="#cb31-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Comp</span> f g <span class="op">~&gt;</span> h</span></code></pre></div>
<p>Unlike for <code>:*:</code>, you always have to interpret <em>both</em> functor values. And, unlike for <code>Day</code>, you must interpret both functor values <em>in that order</em>.</p></li>
<li><p><strong>Identity</strong></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">type</span> <span class="dt">I</span> <span class="dt">Comp</span> <span class="ot">=</span> <span class="dt">Identity</span></span></code></pre></div>
<p><code>Comp f Identity</code> is equivalent to just <code>f</code>, because <code>Identity</code> adds no extra effects or structure.</p></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">type</span> <span class="dt">CS</span> <span class="dt">Comp</span> <span class="ot">=</span> <span class="dt">Bind</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="kw">type</span> <span class="dt">CM</span> <span class="dt">Comp</span> <span class="ot">=</span> <span class="dt">Monad</span></span>
<span id="cb33-3"><a href="#cb33-3"></a></span>
<span id="cb33-4"><a href="#cb33-4"></a>binterpret <span class="op">@</span><span class="dt">Comp</span></span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="ot">    ::</span> <span class="dt">Bind</span> h</span>
<span id="cb33-6"><a href="#cb33-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> h</span>
<span id="cb33-7"><a href="#cb33-7"></a>    <span class="ot">-&gt;</span> g <span class="op">~&gt;</span> h</span>
<span id="cb33-8"><a href="#cb33-8"></a>    <span class="ot">-&gt;</span> <span class="dt">Comp</span> f g <span class="op">~&gt;</span> h</span>
<span id="cb33-9"><a href="#cb33-9"></a></span>
<span id="cb33-10"><a href="#cb33-10"></a>inL   <span class="op">@</span><span class="dt">Comp</span><span class="ot"> ::</span> <span class="dt">Monad</span> g <span class="ot">=&gt;</span> f        <span class="op">~&gt;</span> <span class="dt">Comp</span> f g</span>
<span id="cb33-11"><a href="#cb33-11"></a>inR   <span class="op">@</span><span class="dt">Comp</span><span class="ot"> ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> g        <span class="op">~&gt;</span> <span class="dt">Comp</span> f g</span>
<span id="cb33-12"><a href="#cb33-12"></a>pureT <span class="op">@</span><span class="dt">Comp</span><span class="ot"> ::</span> <span class="dt">Monad</span> h <span class="ot">=&gt;</span> <span class="dt">Identity</span> <span class="op">~&gt;</span> h</span></code></pre></div>
<p><code>Bind</code>, from <em>semigroupoids</em>, is “<code>Monad</code> without <code>return</code>”; it only has <code>&gt;&gt;=</code> (called <code>&gt;&gt;-</code>).</p>
<p>Somewhat serendipitously, the <code>CM</code> constraint associated with <code>Comp</code> is the infamous <code>Monad</code>. Hopefully this insight also gives you some insight on the nature of <code>Monad</code> as an abstraction: it’s a way to “interpret” in and out of <code>Comp</code> :)</p></li>
<li><p><strong>Induced Monoid</strong></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">type</span> <span class="dt">SF</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Free1</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="kw">type</span> <span class="dt">MF</span> <span class="dt">Day</span> <span class="ot">=</span> <span class="dt">Free</span></span></code></pre></div>
<p><code>Free f a</code> is a bunch of <code>f x</code>s composed with each other. It is either:</p>
<ul>
<li><code>a</code> (zero <code>f</code>s)</li>
<li><code>f a</code> (one <code>f</code>)</li>
<li><code>f (f a)</code> (two <code>f</code>s)</li>
<li><code>f (f (f a))</code> (three <code>f</code>s)</li>
<li>.. etc.</li>
</ul>
<p><code>Free</code> is very useful because it allows you to specify that your schema can have many <code>f</code>s, sequenced one after the other, in which the <em>choice</em> of “the next <code>f</code>” is allowed to depend on the <em>result</em> of “the previous <code>f</code>”.</p>
<p>For example, in an interactive “wizard” sort of schema, where <code>f</code> represents a wizard dialog box, we can represent our wizard using <code>Free f a</code> — an ordered sequence of dialog boxes, where the choice of the next box can depend on result of the previous box.</p>
<p><code>Free1</code> is a version with “at least one” <code>f a</code>.</p>
<p>See the information later on <code>Free</code> alone (in the single-argument functor combinator section) for more information on usage and utility.</p></li>
</ul>
<h3 id="these1">These1</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/these/docs/Data-Functor-These.html">Data.Functor.These</a></em>.</p></li>
<li><p><strong>Mixing Strategy</strong>: “Either-or, or both”: provide either (or both) cases, and user has to handle both possibilities. An “inclusive either”</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">data</span> <span class="dt">These1</span> f g a</span>
<span id="cb35-2"><a href="#cb35-2"></a>    <span class="ot">=</span> <span class="dt">This1</span>  (f a)</span>
<span id="cb35-3"><a href="#cb35-3"></a>    <span class="op">|</span> <span class="dt">That1</span>        (g a)</span>
<span id="cb35-4"><a href="#cb35-4"></a>    <span class="op">|</span> <span class="dt">These1</span> (f a) (g a)</span></code></pre></div>
<p>This can be useful for situations where your schema/functor can be specified using one functor or another, or even both. See description on <code>:+:</code> for examples.</p>
<p>The person who creates the <code>These1 f g</code> decides which one to give, and the person who consumes/interprets/runs the <code>f :+: g</code> must provide a way of handling <em>both</em> situations.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a>binterpret <span class="op">@</span><span class="dt">These</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="ot">    ::</span> <span class="dt">Alt</span> h</span>
<span id="cb36-3"><a href="#cb36-3"></a>    <span class="ot">=&gt;</span> (f <span class="op">~&gt;</span> h)</span>
<span id="cb36-4"><a href="#cb36-4"></a>    <span class="ot">-&gt;</span> (g <span class="op">~&gt;</span> h)</span>
<span id="cb36-5"><a href="#cb36-5"></a>    <span class="ot">-&gt;</span> <span class="dt">These</span> f g a</span>
<span id="cb36-6"><a href="#cb36-6"></a>    <span class="ot">-&gt;</span> h a</span></code></pre></div>
<p>You can also pattern match on the <code>These1</code> directly to be more explicit with how you handle each of the tree cases.</p></li>
<li><p><strong>Identity</strong></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">type</span> <span class="dt">I</span> <span class="dt">These1</span> <span class="ot">=</span> <span class="dt">Void</span></span></code></pre></div>
<p><code>These1 f Void</code> is equivalent to just <code>f</code>, because it means the <code>That1</code> and <code>These1</code> branches will be impossible to construct, and you are left with only the <code>This1</code> branch.</p></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">type</span> <span class="dt">CS</span> <span class="dt">These1</span> <span class="ot">=</span> <span class="dt">Alt</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="kw">type</span> <span class="dt">CM</span> <span class="dt">These1</span> <span class="ot">=</span> <span class="dt">Alt</span></span>
<span id="cb38-3"><a href="#cb38-3"></a></span>
<span id="cb38-4"><a href="#cb38-4"></a>binterpret <span class="op">@</span><span class="dt">These1</span></span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="ot">    ::</span> <span class="dt">Alt</span> h</span>
<span id="cb38-6"><a href="#cb38-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> h</span>
<span id="cb38-7"><a href="#cb38-7"></a>    <span class="ot">-&gt;</span> g <span class="op">~&gt;</span> h</span>
<span id="cb38-8"><a href="#cb38-8"></a>    <span class="ot">-&gt;</span> <span class="dt">These1</span> f g <span class="op">~&gt;</span> h</span>
<span id="cb38-9"><a href="#cb38-9"></a></span>
<span id="cb38-10"><a href="#cb38-10"></a>inL   <span class="op">@</span><span class="dt">These1</span><span class="ot"> ::</span> <span class="dt">Alt</span> g <span class="ot">=&gt;</span> f     <span class="op">~&gt;</span> <span class="dt">Comp</span> f g</span>
<span id="cb38-11"><a href="#cb38-11"></a>inR   <span class="op">@</span><span class="dt">These1</span><span class="ot"> ::</span> <span class="dt">Alt</span> f <span class="ot">=&gt;</span> g     <span class="op">~&gt;</span> <span class="dt">Comp</span> f g</span>
<span id="cb38-12"><a href="#cb38-12"></a>pureT <span class="op">@</span><span class="dt">These1</span><span class="ot"> ::</span> <span class="dt">Alt</span> h <span class="ot">=&gt;</span> <span class="dt">Void1</span> <span class="op">~&gt;</span> h</span></code></pre></div>
<p>You need at least <code>Alt</code> to be able to interpret out of a <code>These1</code>, because you need to be able to handle the case where you have <em>both</em> <code>f</code> and <code>g</code>, and need to combine the result. However, you never need a full <code>Plus</code> because we always have at least one value to use.</p></li>
<li><p><strong>Induced Monoid</strong></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">type</span> <span class="dt">MF</span> <span class="dt">These1</span> <span class="ot">=</span> <span class="dt">Steps</span></span></code></pre></div>
<p><code>Steps</code>, the induced monoidal functor combinator, is the result of an infinite application of `These1 to the same value:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">type</span> <span class="dt">Steps</span> f <span class="ot">=</span> f <span class="ot">`These1`</span> f <span class="ot">`These1`</span> f <span class="ot">`These1`</span> f <span class="ot">`These1`</span> <span class="op">...</span> etc<span class="op">.</span></span></code></pre></div>
<p>It essentially represents an infinite <em>sparse</em> array of <code>f a</code>s, where an <code>f a</code> might exist at many different positions, with gaps here and there. There is always at least <em>one</em> <code>f a</code>.</p>
<p>Like <code>Step</code>, it’s not particularly useful, but it can be used in situations where you want a giant infinite sparse array of <code>f a</code>s, each at a given position, with many gaps between them.</p>
<p>I’ve skipped over the the induced semigroupoidal functor, which is <code>ComposeT Flagged Steps</code>; it requires an extra boolean “flag” because of some of the quirks of nonemptiness. I feel it is even less useful than <code>Steps</code>.</p></li>
</ul>
<h3 id="leftf-rightf">LeftF / RightF</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html">Data.HBifunctor</a></em> (for <code>LeftF</code> and <code>RightF</code>)</p></li>
<li><p><strong>Mixing Strategy</strong>: “Ignore the left” / “ignore the right”.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">data</span> <span class="dt">LeftF</span>  f g a <span class="ot">=</span> <span class="dt">LeftF</span>  {<span class="ot"> runLeftF  ::</span> f a }</span>
<span id="cb41-2"><a href="#cb41-2"></a></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="kw">data</span> <span class="dt">RightF</span> f g a <span class="ot">=</span> <span class="dt">RightF</span> {<span class="ot"> runRightF ::</span> g a }</span></code></pre></div>
<p>You can think of <code>LeftF</code> as “<code>:+:</code> without the Right case, <code>R1</code>”, or <code>RightF</code> as “<code>:+:</code> without the Left case, <code>L1</code>”. <code>RightF</code> can be considered a higher-order version of <em>Tagged</em>, which “tags” a value with some type-level information.</p>
<p>This can be useful if you want the second (or first) argument to be ignored, and only be used maybe at the type level.</p>
<p>For example, <code>RightF IgnoreMe MyFunctor</code> is equivalent to just <code>MyFunctor</code>, but you might want to use <code>IgnoreMe</code> as a phantom type to help limit what values can be used for what functions.</p></li>
<li><p><strong>Identity</strong></p>
<p>Unlike the previous functor combinators, these three are only <code>Semigroupoidal</code>, not <code>Monoidal</code>: this is because there is no functor <code>i</code> such that <code>LeftF i g</code> is equal to <code>g</code>, for all <code>g</code>, and no functor <code>i</code> such that <code>RightF f i</code> is equal to <code>f</code>, for all <code>f</code>.</p></li>
<li><p><strong>Constraints</strong></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">type</span> <span class="dt">CS</span> <span class="dt">LeftF</span>  <span class="ot">=</span> <span class="dt">Unconstrained</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="kw">type</span> <span class="dt">CS</span> <span class="dt">RightF</span> <span class="ot">=</span> <span class="dt">Unconstrained</span></span></code></pre></div>
<p>Interpreting out of either of these is unconstrained, and can be done in any context.</p></li>
<li><p><strong>Induced Semigroup</strong></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">type</span> <span class="dt">SF</span> <span class="dt">LeftF</span> <span class="ot">=</span> <span class="dt">Flagged</span></span></code></pre></div>
<p>For <code>LeftF</code>, the induced semigroup is <code>Flagged</code>, which is the <code>f a</code> tupled with a <code>Bool</code>. See the information on <code>Flagged</code> for more details. This can be useful as a type that marks if an <code>f</code> is made with <code>inject</code>/<code>pure</code> and is “pure” (<code>False</code>), or “tainted” (<code>True</code>). The <em>provider</em> of a <code>Flagged</code> can specify “pure or tainted”, and the <em>interpreter</em> can make a decision based on that tag.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1"></a><span class="kw">type</span> <span class="dt">SF</span> <span class="dt">RightF</span> <span class="ot">=</span> <span class="dt">Step</span></span></code></pre></div>
<p>For <code>RightF</code>, the induced semigroup is <code>Step</code>. See <code>Step</code> and the information on <code>:+:</code> for more details. This can be useful for having a value of <code>f a</code> at “some point”, indexed by a <code>Natural</code>.</p></li>
</ul>
<h2 id="single-argument">Single-Argument</h2>
<p>Unary functor combinators usually directly “enhance” a functor with extra capabilities — usually in the form of a typeclass instance, or extra data fields/constructors.</p>
<p>All of these can be “lifted into” with any constraint on <code>f</code>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">class</span> <span class="dt">HFunctor</span> t <span class="ot">=&gt;</span> <span class="dt">Inject</span> t <span class="kw">where</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="ot">    inject ::</span> f <span class="op">~&gt;</span> t f</span></code></pre></div>
<p><code>Inject</code> seems very similar to <code>MonadTrans</code>’s <code>lift</code>; the difference is that <code>inject</code> must be <em>natural</em> on <code>f</code>: it can assume nothing about the structure of <code>f</code>, and must work universally the same. <code>MonadTrans</code>, in contrast, requires <code>Monad f</code>.</p>
<p>Each one has an associated constraint, <code>C t</code>, which is the constraint on where you can <em>interpret</em> or <em>run</em> values of the enhanced type:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1"></a><span class="kw">class</span> <span class="dt">Inject</span> t <span class="ot">=&gt;</span> <span class="dt">Interpret</span> t <span class="kw">where</span></span>
<span id="cb46-2"><a href="#cb46-2"></a>    <span class="kw">type</span> <span class="dt">C</span><span class="ot"> t ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb46-3"><a href="#cb46-3"></a></span>
<span id="cb46-4"><a href="#cb46-4"></a>    interpret</span>
<span id="cb46-5"><a href="#cb46-5"></a><span class="ot">        ::</span> <span class="dt">C</span> t g</span>
<span id="cb46-6"><a href="#cb46-6"></a>        <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb46-7"><a href="#cb46-7"></a>        <span class="ot">-&gt;</span> t f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>The constraint depends on the structure that the specific functor combinator imbues.</p>
<p>An important law is that:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1"></a>interpret <span class="fu">id</span> <span class="op">.</span> inject <span class="op">==</span> <span class="fu">id</span></span></code></pre></div>
<p>This means that if we inject and immediately interpret out of, we should never <em>lose</em> any information in <code>f</code>. All of the original structure in <code>f</code> must stay intact: functor combinators only ever <em>add</em> structure.</p>
<h3 id="coyoneda">Coyoneda</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html">Data.Functor.Coyoneda</a></em></p></li>
<li><p><strong>Enhancement</strong>: The ability to map over the parameter; it’s the free <code>Functor</code>.</p>
<p>Can be useful if <code>f</code> is created using a <code>GADT</code> that cannot be given a <code>Functor</code> instance.</p>
<p>For example, here is an indexed type that represents the type of a “form element”, where the type parameter represents the output result of the form element.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">data</span> <span class="dt">FormElem</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb48-2"><a href="#cb48-2"></a>    <span class="dt">FInput</span><span class="ot">    ::</span> <span class="dt">FormElem</span> <span class="dt">String</span></span>
<span id="cb48-3"><a href="#cb48-3"></a>    <span class="dt">FTextbox</span><span class="ot">  ::</span> <span class="dt">FormElem</span> <span class="dt">Text</span></span>
<span id="cb48-4"><a href="#cb48-4"></a>    <span class="dt">FCheckbox</span><span class="ot"> ::</span> <span class="dt">FormElem</span> <span class="dt">Bool</span></span>
<span id="cb48-5"><a href="#cb48-5"></a>    <span class="dt">FNumber</span><span class="ot">   ::</span> <span class="dt">FormElem</span> <span class="dt">Int</span></span></code></pre></div>
<p>Then <code>Coyoneda FormElem</code> has a <code>Functor</code> instance. We can now fmap over the result type of the form element; for example, <code>fmap :: (a -&gt; b) -&gt; Coyoneda FormElem a -&gt; Coyoneda FormElem b</code> takes a form element whose result is an <code>a</code> and returns a form element whose result is a <code>b</code>.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Coyoneda</span> <span class="ot">=</span> <span class="dt">Functor</span></span>
<span id="cb49-2"><a href="#cb49-2"></a></span>
<span id="cb49-3"><a href="#cb49-3"></a>interpret <span class="op">@</span><span class="dt">Coyoneda</span></span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="ot">    ::</span> <span class="dt">Functor</span> g</span>
<span id="cb49-5"><a href="#cb49-5"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb49-6"><a href="#cb49-6"></a>    <span class="ot">-&gt;</span> <span class="dt">Coyoneda</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of a <code>Coyoneda f</code> requires the target context to itself be <code>Functor</code>. Usually, the context is an <code>Applicative</code> or <code>Monad</code>, so this is typically always satisfied.</p>
<p>For example, if we want to “run” a <code>Coyoneda FormElem</code> into <code>IO</code>, this would be <code>interpret :: (forall x. FormElem x -&gt; IO x) -&gt; Coyoneda FormElem a -&gt; IO a</code>.</p></li>
</ul>
<h3 id="listf-nonemptyf">ListF / NonEmptyF</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-ListF.html">Control.Applicative.ListF</a></em></p></li>
<li><p><strong>Enhancement</strong>: The ability to offer multiple options for the interpreter to pick from; <code>ListF</code> is the free <code>Plus</code>, and <code>NonEmptyF</code> is the free <code>Alt</code>.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1"></a><span class="kw">data</span> <span class="dt">ListF</span>     f a <span class="ot">=</span> <span class="dt">ListF</span>     {<span class="ot"> runListF     ::</span> [f a]          }</span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="kw">data</span> <span class="dt">NonEmptyF</span> f a <span class="ot">=</span> <span class="dt">NonEmptyF</span> {<span class="ot"> runNonEmptyF ::</span> <span class="dt">NonEmpty</span> (f a) }</span></code></pre></div>
<p>Can be useful if you want to provide the ability when you <em>define</em> your schema to provide multiple <code>f a</code>s that the <em>interpreter</em>/consumer can freely pick from.</p>
<p>For example, for a schema specifying a form, you might have multiple ways to enter a name. If you had a <code>Name</code> schema <code>data Name a</code>, then you can represent “many different potential name inputs” schema as <code>ListF Name a</code>.</p>
<p>Because this has a <code>Plus</code> instance, you can use <code>(&lt;!&gt;) :: ListF f a -&gt; ListF f a -&gt; ListF f a</code> to combine multiple option sets, and <code>zero :: ListF f a</code> to provide the “choice that always fails/is unusuable”.</p>
<p><code>NonEmptyF</code> is a variety of <code>ListF</code> where you always have “at least one <code>f a</code>”. Can be useful if you want to ensure, for your interpreter’s sake, that you always have at least one <code>f a</code> option to pick from. For example, <code>NonEmptyF Name a</code> will always have at least <em>one</em> name schema.</p>
<p>This is essentially <code>f</code> <code>:*:</code>d with itself multiple times; <code>ListF</code> is the monoidal functor combinator induced by <code>:*:</code>, and <code>NonEmptyF</code> is the semigroupoidal functor combinator induced by <code>:*:</code>.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1"></a>x             <span class="op">&lt;=&gt;</span> <span class="dt">ListF</span> [x]     <span class="op">&lt;=&gt;</span> <span class="dt">NonEmptyF</span> (x <span class="op">:|</span> [])</span>
<span id="cb51-2"><a href="#cb51-2"></a>x <span class="op">:*:</span> y       <span class="op">&lt;=&gt;</span> <span class="dt">ListF</span> [x,y]   <span class="op">&lt;=&gt;</span> <span class="dt">NonEmptyF</span> (x <span class="op">:|</span> [y])</span>
<span id="cb51-3"><a href="#cb51-3"></a>x <span class="op">:*:</span> y <span class="op">:*:</span> z <span class="op">&lt;=&gt;</span> <span class="dt">ListF</span> [x,y,z] <span class="op">&lt;=&gt;</span> <span class="dt">NonEmptyF</span> (x <span class="op">:|</span> [y,z])</span></code></pre></div></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">ListF</span>     <span class="ot">=</span> <span class="dt">Plus</span></span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">NonEmptyF</span> <span class="ot">=</span> <span class="dt">Alt</span></span>
<span id="cb52-3"><a href="#cb52-3"></a></span>
<span id="cb52-4"><a href="#cb52-4"></a>interpret <span class="op">@</span><span class="dt">ListF</span></span>
<span id="cb52-5"><a href="#cb52-5"></a><span class="ot">    ::</span> <span class="dt">Plus</span> g</span>
<span id="cb52-6"><a href="#cb52-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb52-7"><a href="#cb52-7"></a>    <span class="ot">-&gt;</span> <span class="dt">ListF</span> f <span class="op">~&gt;</span> g</span>
<span id="cb52-8"><a href="#cb52-8"></a></span>
<span id="cb52-9"><a href="#cb52-9"></a>interpret <span class="op">@</span><span class="dt">NonEmptyF</span></span>
<span id="cb52-10"><a href="#cb52-10"></a><span class="ot">    ::</span> <span class="dt">Alt</span> g</span>
<span id="cb52-11"><a href="#cb52-11"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb52-12"><a href="#cb52-12"></a>    <span class="ot">-&gt;</span> <span class="dt">NonEmptyF</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of a <code>ListF f</code> requires the target context to be <code>Plus</code>, and interpreting out of a <code>NonEmptyF f</code> requires <code>Alt</code> (because you will never have the empty case). However, you can directly pattern match on the list and pick an item you want directly, which requires no constraint.</p></li>
</ul>
<h3 id="ap-ap1">Ap / Ap1</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html">Control.Applicative.Free</a></em> / <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Apply-Free.html">Data.Functor.Apply.Free</a></em></p></li>
<li><p><strong>Enhancement</strong>: The ability to provide multiple <code>f</code>s that the interpreter <em>must</em> consume <em>all</em> of; <code>Ap</code> is the free <code>Applicative</code>, and <code>Ap1</code> is the free <code>Apply</code>.</p>
<p>While <code>ListF</code> may be considered “multiple options <em>offered</em>”, <code>Ap</code> can be considered “multiple actions all <em>required</em>”. The interpreter must consume/interpret <em>all</em> of the multiple <code>f</code>s in order to interpret an <code>Ap</code>.</p>
<p>For example, for a form schema, you might want to have multiple form elements. If a single form element is <code>data FormElem a</code>, then you can make a multi-form schema with <code>Ap FormElem a</code>. The consumer of the form schema must handle <em>every</em> <code>FormElem</code> provided.</p>
<p>Note that ordering is not enforced: while the consumer must handle each <code>f</code> eventually, they are free to handle it in whatever order they desire. In fact, they could even all be handled in parallel. See <code>Free</code> for a version where ordering is enforced.</p>
<p>Because this has an <code>Applicative</code> instance, you can use <code>(&lt;*&gt;) :: Ap f (a -&gt; b) -&gt; Ap f a -&gt; Ap f b</code> to sequence multiple <code>Ap f</code>s together, and <code>pure :: a -&gt; Ap f a</code> to produce a “no-op” <code>Ap</code> without any <code>f</code>s.</p>
<p><code>Ap</code> has some utility over <code>Free</code> in that you can pattern match on the constructors directly and look at each individual sequenced <code>f a</code>, for static analysis, before anything is ever run or interpreted.</p>
<p><code>Ap1</code> is a variety of <code>Ap</code> where you always have to have “at least one <code>f</code>”. Can be useful if you want to ensure, for example, that your form has at least one element.</p>
<p>Note that this is essentially <code>f</code> <code>Day</code>d with itself multiple times; <code>Ap</code> is the monoidal functor combinator induced by <code>Day</code> and <code>Ap1</code> is the semigroupoidal functor combinator induced by <code>Day</code>.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Ap</span>  <span class="ot">=</span> <span class="dt">Applicative</span></span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Ap1</span> <span class="ot">=</span> <span class="dt">Apply</span></span>
<span id="cb53-3"><a href="#cb53-3"></a></span>
<span id="cb53-4"><a href="#cb53-4"></a>interpret <span class="op">@</span><span class="dt">Ap</span></span>
<span id="cb53-5"><a href="#cb53-5"></a><span class="ot">    ::</span> <span class="dt">Applicative</span> g</span>
<span id="cb53-6"><a href="#cb53-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb53-7"><a href="#cb53-7"></a>    <span class="ot">-&gt;</span> <span class="dt">Ap</span> f <span class="op">~&gt;</span> g</span>
<span id="cb53-8"><a href="#cb53-8"></a></span>
<span id="cb53-9"><a href="#cb53-9"></a>interpret <span class="op">@</span><span class="dt">Ap1</span></span>
<span id="cb53-10"><a href="#cb53-10"></a><span class="ot">    ::</span> <span class="dt">Apply</span> g</span>
<span id="cb53-11"><a href="#cb53-11"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb53-12"><a href="#cb53-12"></a>    <span class="ot">-&gt;</span> <span class="dt">Ap1</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of an <code>Ap f</code> requires the target context to be <code>Applicative</code>, and interpreting out of a <code>Ap1 f</code> requires <code>Apply</code> (because you will never need the pure case).</p></li>
</ul>
<h3 id="alt">Alt</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/free/docs/Control-Alternative-Free.html">Control.Alternative.Free</a></em></p></li>
<li><p><strong>Enhancement</strong>: A combination of both <code>ListF</code> and <code>Ap</code>: provide a choice (<code>ListF</code>-style) of sequences (<code>Ap</code>-style) of choices of sequences of choices ….; it’s the free <code>Alternative</code>.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1"></a><span class="dt">Alt</span> f <span class="op">~</span> <span class="dt">ListF</span> (<span class="dt">Ap</span> (<span class="dt">ListF</span> (<span class="dt">Ap</span> (<span class="dt">ListF</span> (<span class="dt">Ap</span> (<span class="op">...</span>))))</span>
<span id="cb54-2"><a href="#cb54-2"></a>      <span class="op">~</span> <span class="dt">ListF</span> (<span class="dt">Ap</span> (<span class="dt">Alt</span> f))</span></code></pre></div>
<p>This type imbues <code>f</code> with both sequential “must use both” operations (via <code>&lt;*&gt;</code>) and choice-like “can use either” operations (via <code>&lt;|&gt;</code>).</p>
<p>It can be useful for implementing parser schemas, which often involve both sequential and choice-like combinations. If <code>f</code> is a primitive parsing unit, then <code>Alt f</code> represents a non-deterministic parser of a bunch of <code>f</code>s one after the other, with multiple possible results. I wrote <a href="https://blog.jle.im/entry/free-alternative-regexp.html">an entire article</a> on the usage of this combinator alone to implement a version of regular expressions.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Alt</span> <span class="ot">=</span> <span class="dt">Alternative</span></span>
<span id="cb55-2"><a href="#cb55-2"></a></span>
<span id="cb55-3"><a href="#cb55-3"></a>interpret <span class="op">@</span><span class="dt">Alt</span></span>
<span id="cb55-4"><a href="#cb55-4"></a><span class="ot">    ::</span> <span class="dt">Alternative</span> g</span>
<span id="cb55-5"><a href="#cb55-5"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb55-6"><a href="#cb55-6"></a>    <span class="ot">-&gt;</span> <span class="dt">Alt</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of an <code>Alt f</code> requires the target context to be <code>Alternative</code> — it uses <code>&lt;*&gt;</code> for sequencing, and <code>&lt;|&gt;</code> for choice.</p></li>
</ul>
<h3 id="free-free1">Free / Free1</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Control-Monad-Freer-Church.html">Control.Monad.Freer.Church</a></em>, which is a variant of <em><a href="https://hackage.haskell.org/package/free/docs/Control-Monad-Free.html">Control.Monad.Free</a></em> that is compatible with <code>HFunctor</code>.</p></li>
<li><p><strong>Enhancement</strong>: The ability to provide multiple <code>f</code>s that the interpreter must consume <em>in order</em>, sequentially — the free <code>Monad</code>.</p>
<p>Contrast with <code>Ap</code>, which also sequences multiple <code>f</code>s together, but without any enforced order. It does this by <em>hiding</em> the “next <code>f a</code>” until the previous <code>f a</code> has already been interpreted.</p>
<p>Perhaps more importantly, you can sequence <code>f</code>s in a way where the <em>choice of the next <code>f</code></em> is allowed to depend on the <em>result of the previous <code>f</code></em>.</p>
<p>For example, in an interactive “wizard” sort of schema, where <code>f</code> represents a wizard dialog box, we can represent our wizard using <code>Free f a</code> — an ordered sequence of dialog boxes, where the choice of the next box can depend on result of the previous box. Contrast to <code>Ap</code>, where the choice of all dialog boxes must be made in advanced, up-front, before reading any input from the user.</p>
<p>In having this, however, we loose the ability to be able to inspect each <code>f a</code> before interpreting anything.</p>
<p>Because this has a <code>Monad</code> instance, you can use <code>(&lt;*&gt;) :: Free f (a -&gt; b) -&gt; Free f a -&gt; Free f b</code> and <code>(&gt;&gt;=) :: Free f a -&gt; (a -&gt; Free f b) -&gt; Free f b)</code> to sequence multiple <code>Free f</code>s together, and <code>pure :: a -&gt; Free f a</code> to produce a “no-op” <code>Free</code> without any <code>f</code>s.</p>
<p><code>Free1</code> is a variety of <code>Free1</code> where you always have to have “at least one <code>f</code>”. Can be useful if you want to ensure, for example, that your wizard has at least one dialog box.</p>
<p>Note that this is essentially <code>f</code> <code>Comp</code>d with itself multiple times; <code>Free</code> is the monoidal functor combinator induced by <code>Comp</code> and <code>Free1</code> is the semigroupoidal functor combinator induced by <code>Comp</code>.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Free</span>  <span class="ot">=</span> <span class="dt">Monad</span></span>
<span id="cb56-2"><a href="#cb56-2"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Free1</span> <span class="ot">=</span> <span class="dt">Bind</span></span>
<span id="cb56-3"><a href="#cb56-3"></a></span>
<span id="cb56-4"><a href="#cb56-4"></a>interpret <span class="op">@</span><span class="dt">Free</span></span>
<span id="cb56-5"><a href="#cb56-5"></a><span class="ot">    ::</span> <span class="dt">Monad</span> g</span>
<span id="cb56-6"><a href="#cb56-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb56-7"><a href="#cb56-7"></a>    <span class="ot">-&gt;</span> <span class="dt">Free</span> f <span class="op">~&gt;</span> g</span>
<span id="cb56-8"><a href="#cb56-8"></a></span>
<span id="cb56-9"><a href="#cb56-9"></a>interpret <span class="op">@</span><span class="dt">Free1</span></span>
<span id="cb56-10"><a href="#cb56-10"></a><span class="ot">    ::</span> <span class="dt">Bind</span> g</span>
<span id="cb56-11"><a href="#cb56-11"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb56-12"><a href="#cb56-12"></a>    <span class="ot">-&gt;</span> <span class="dt">Free1</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of a <code>Free f</code> requires the target context to be <code>Monad</code>, and interpreting out of a <code>Free1 f</code> requires <code>Bind</code> (because you will never need the pure case).</p></li>
</ul>
<h3 id="lift-maybeapply">Lift / MaybeApply</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/transformers/docs/Control-Applicative-Lift.html">Control.Applicative.Lift</a></em> / <em><a href="https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Apply.html">Data.Functor.Apply</a></em> (the same type)</p></li>
<li><p><strong>Enhancement</strong>: Make <code>f</code> “optional” in the schema in a way that the interpreter can still work with as if the <code>f</code> was still there; it’s the free <code>Pointed</code>.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1"></a><span class="kw">data</span> <span class="dt">Lift</span> f a <span class="ot">=</span> <span class="dt">Pure</span>  a</span>
<span id="cb57-2"><a href="#cb57-2"></a>              <span class="op">|</span> <span class="dt">Other</span> (f a)</span>
<span id="cb57-3"><a href="#cb57-3"></a></span>
<span id="cb57-4"><a href="#cb57-4"></a><span class="kw">newtype</span> <span class="dt">MaybeApply</span> f a <span class="ot">=</span> <span class="dt">MaybeApply</span> {<span class="ot"> runMaybeApply ::</span> <span class="dt">Either</span> a (f a) }</span>
<span id="cb57-5"><a href="#cb57-5"></a>    <span class="co">-- ^ same type, from semigroupoids</span></span></code></pre></div>
<p>Can be useful so that an <code>f a</code> is <em>optional</em> for the schema definition, but in a way where the consumer can still continue from it as if they <em>had</em> the <code>f</code>.</p>
<p>It can be used, for example, to turn an required parameter <code>Param a</code> into an optional paramter <code>Lift Param a</code>.</p>
<p>Contrast this to <code>MaybeF</code>: this allows the interpreter to still “continue on” as normal even if the <code>f</code> is not there. However, <code>MaybeF</code> forces the interpreter to abort if the <code>f</code> is not there.</p>
<p>This can be thought of as <code>Identity :+: f</code>.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Lift</span> <span class="ot">=</span> <span class="dt">Pointed</span></span>
<span id="cb58-2"><a href="#cb58-2"></a></span>
<span id="cb58-3"><a href="#cb58-3"></a>interpret <span class="op">@</span><span class="dt">Lift</span></span>
<span id="cb58-4"><a href="#cb58-4"></a><span class="ot">    ::</span> <span class="dt">Pointed</span> g</span>
<span id="cb58-5"><a href="#cb58-5"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb58-6"><a href="#cb58-6"></a>    <span class="ot">-&gt;</span> <span class="dt">Lift</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of a <code>Lift f</code> requires the target context to be <code>Pointed</code>, from <em><a href="https://hackage.haskell.org/package/pointed/docs/Data-Pointed.html">Data.Pointed</a></em> — it uses <code>point :: Pointed f =&gt; a -&gt; f a</code> to handle the case where the <code>f</code> is not there.</p></li>
</ul>
<h3 id="maybef">MaybeF</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-ListF.html">Control.Applicative.ListF</a></em></p></li>
<li><p><strong>Enhancement</strong>: Make <code>f</code> “optional” in the schema in a way that the interpreter <em>must fail</em> if the <code>f</code> is not present.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1"></a><span class="kw">newtype</span> <span class="dt">MaybeF</span> f a <span class="ot">=</span> <span class="dt">MaybeF</span> {<span class="ot"> runMaybeF ::</span> <span class="dt">Maybe</span> (f a) }</span></code></pre></div>
<p>Can be useful so that an <code>f a</code> is <em>optional</em> for the schema definition; if the <code>f</code> is not present, the consumer must abort the current branch, or find some other external way to continue onwards.</p>
<p>Contrast this to <code>Lift</code>, which is an “optional” <code>f</code> that the consumer may continue on from.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">MaybeF</span> <span class="ot">=</span> <span class="dt">Plus</span></span>
<span id="cb60-2"><a href="#cb60-2"></a></span>
<span id="cb60-3"><a href="#cb60-3"></a>interpret <span class="op">@</span><span class="dt">MaybeF</span></span>
<span id="cb60-4"><a href="#cb60-4"></a><span class="ot">    ::</span> <span class="dt">Plus</span> g</span>
<span id="cb60-5"><a href="#cb60-5"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb60-6"><a href="#cb60-6"></a>    <span class="ot">-&gt;</span> <span class="dt">MaybeF</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of a <code>Lift f</code> requires the target context to be <code>Plus</code> — it uses <code>zero :: f a</code> to handle the case where the <code>f</code> is not there. Note that this is actually “over-constrained”: we really only need <code>zero</code>, and not all of <code>Plus</code> (which includes <code>&lt;!&gt;</code>). However, there is no common typeclass in Haskell that provides this, so this is the most pragmatic choice.</p></li>
</ul>
<h3 id="envt">EnvT</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/comonad/docs/Control-Comonad-Trans-Env.html">Control.Comonad.Trans.Env</a></em></p></li>
<li><p><strong>Enhancement</strong>: Provide extra (monoidal) data alongside <code>f a</code> that the interpreter can access. Basically tuples extra <code>e</code> alongside the <code>f a</code>.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1"></a><span class="kw">newtype</span> <span class="dt">EnvT</span> e f a <span class="ot">=</span> <span class="dt">EnvT</span> e (f a)</span></code></pre></div>
<p>You can use this to basically tuple some extra data alongside an <code>f a</code>. It can be useful if you want to provide extra information that isn’t inside the <code>f</code> for the interpreter use for interpretation.</p>
<p>When using <code>inject :: Monoid e =&gt; f a -&gt; EnvT e f a</code>, it uses <code>mempty</code> as the initial <code>e</code> value.</p>
<p>This can be thought of as <code>Const e :*: f</code>.</p>
<p>This type exists specialized a few times here, as well:</p>
<ul>
<li><code>Step</code> is <code>EnvT (Sum Natural)</code></li>
<li><code>Flagged</code> is <code>EnvT Any</code></li>
</ul></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">EnvT</span> e) <span class="ot">=</span> <span class="dt">Unconstrained</span></span>
<span id="cb62-2"><a href="#cb62-2"></a></span>
<span id="cb62-3"><a href="#cb62-3"></a>interpret <span class="op">@</span>(<span class="dt">EnvT</span> e)</span>
<span id="cb62-4"><a href="#cb62-4"></a><span class="ot">    ::</span> f <span class="op">~&gt;</span> g</span>
<span id="cb62-5"><a href="#cb62-5"></a>    <span class="ot">-&gt;</span> <span class="dt">EnvT</span> e f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of <code>EnvT e</code> requires no constraints.</p></li>
</ul>
<h3 id="mapf-nemapf">MapF / NEMapF</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-ListF.html">Control.Applicative.ListF</a></em></p></li>
<li><p><strong>Enhancement</strong>: Contain multiple <code>f a</code>s, each indexed at a specific <em>key</em>.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1"></a><span class="kw">newtype</span> <span class="dt">MapF</span>   k f a <span class="ot">=</span> <span class="dt">MapF</span>   {<span class="ot"> runMapF ::</span> <span class="dt">Map</span>   k (f a) }</span>
<span id="cb63-2"><a href="#cb63-2"></a><span class="kw">newtype</span> <span class="dt">NEMapF</span> k f a <span class="ot">=</span> <span class="dt">NEMapF</span> {<span class="ot"> runMapF ::</span> <span class="dt">NEMap</span> k (f a) }</span></code></pre></div>
<p>This is very similar in functionality to <code>ListF</code> and <code>NonEmptyF</code>, except instead of “positional” location, each <code>f a</code> exists at a given index. <code>NEMapF k</code> is the “non-empty” variant. You can think of this as a <code>ListF</code> plus <code>EnvT</code>: it’s a “container” of multiple <code>f a</code>s, but each one exists with a given “tag” index <code>k</code>.</p>
<p>In usage, like for <code>ListF</code>, the <em>definer</em> provides multiple “labeled” <code>f a</code>s, and the <em>interpreter</em> can choose to interpret some or all of them, with accews to each labeled.</p>
<p><code>inject</code> creates a singleton <code>Map</code> at key <code>mempty</code>.</p>
<p>This is very useful in schemas that have sub-schemas indexed at specific keys. For example, in a command line argument parser, if we have a functor that represents a single command:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1"></a><span class="kw">data</span> <span class="dt">Command</span> a</span></code></pre></div>
<p>We can immediately promote it to be a functor representing <em>multiple possible</em> commands, each at a given string:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1"></a><span class="kw">type</span> <span class="dt">Commands</span> <span class="ot">=</span> <span class="dt">MapF</span> <span class="dt">String</span> <span class="dt">Command</span></span></code></pre></div>
<p>So we can implement “git push” and “git pull” using:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1"></a><span class="ot">push ::</span> <span class="dt">Command</span> <span class="dt">Action</span></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="ot">pull ::</span> <span class="dt">Command</span> <span class="dt">Action</span></span>
<span id="cb66-3"><a href="#cb66-3"></a></span>
<span id="cb66-4"><a href="#cb66-4"></a><span class="ot">gitCommands ::</span> <span class="dt">Commands</span> <span class="dt">Action</span></span>
<span id="cb66-5"><a href="#cb66-5"></a>gitCOmmands <span class="ot">=</span> <span class="dt">MapF</span> <span class="op">.</span> M.fromList <span class="op">$</span></span>
<span id="cb66-6"><a href="#cb66-6"></a>    [ (<span class="st">&quot;push&quot;</span>, push)</span>
<span id="cb66-7"><a href="#cb66-7"></a>    , (<span class="st">&quot;pull&quot;</span>, pull)</span>
<span id="cb66-8"><a href="#cb66-8"></a>    ]</span></code></pre></div>
<p>This is also useful for specifying things like routes in a server.</p>
<p>This type exists specialized as <code>Steps</code>, which is <code>NEMapF (Sum Natural)</code>.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">MapF</span> k  ) <span class="ot">=</span> <span class="dt">Plus</span></span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">NEMapF</span> k) <span class="ot">=</span> <span class="dt">Alt</span></span>
<span id="cb67-3"><a href="#cb67-3"></a></span>
<span id="cb67-4"><a href="#cb67-4"></a>interpret <span class="op">@</span>(<span class="dt">MapF</span> k)</span>
<span id="cb67-5"><a href="#cb67-5"></a><span class="ot">    ::</span> <span class="dt">Plus</span> g</span>
<span id="cb67-6"><a href="#cb67-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb67-7"><a href="#cb67-7"></a>    <span class="ot">-&gt;</span> <span class="dt">MapF</span> f <span class="op">~&gt;</span> g</span>
<span id="cb67-8"><a href="#cb67-8"></a></span>
<span id="cb67-9"><a href="#cb67-9"></a>interpret <span class="op">@</span>(<span class="dt">NEMapF</span> k)</span>
<span id="cb67-10"><a href="#cb67-10"></a><span class="ot">    ::</span> <span class="dt">Alt</span> g</span>
<span id="cb67-11"><a href="#cb67-11"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb67-12"><a href="#cb67-12"></a>    <span class="ot">-&gt;</span> <span class="dt">NEMapF</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of a <code>MapF f</code> requires the target context to be <code>Plus</code>, and interpreting out of a <code>NEMapF f</code> requires <code>Alt</code> (because you will never have the empty case). However, you can directly <em>look up</em> into the <code>Map</code> and pick an item you want directly, which requires no constraint.</p></li>
</ul>
<h3 id="readert">ReaderT</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-Reader.html">Control.Monad.Trans.Reader</a></em></p></li>
<li><p><strong>Enhancement</strong>: Provide each <code>f a</code> with access to some “environment” <code>r</code>.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1"></a><span class="kw">newtype</span> <span class="dt">ReaderT</span> r f a <span class="ot">=</span> <span class="dt">ReaderT</span> {<span class="ot"> runReaderT ::</span> r <span class="ot">-&gt;</span> f a }</span></code></pre></div>
<p><code>ReaderT r</code> is often used to model some form of <a href="https://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a>: it allows you to work “assuming” you had an <code>r</code>; later, when you <em>run</em> it, you provide the <code>r</code>. It delays the evaluation of your final result until you provide the missing <code>r</code>.</p>
<p>Another way of looking at it is that it makes your entire functor have values that are <em>parameterized</em> with an <code>r</code>.</p>
<p>For example, if you have a form data type:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1"></a><span class="kw">data</span> <span class="dt">FormElem</span> a</span></code></pre></div>
<p>you can now make a form data type that is parameterized by the current server hostname:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1"></a><span class="kw">type</span> <span class="dt">FormElemWithHost</span> <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="dt">HostName</span> <span class="dt">FormElem</span></span></code></pre></div>
<p>The actual structure of your <code>FormElem</code> is deferred until you provide the <code>HostName</code>.</p>
<p>Note that, unlike <code>ReaderT</code>, most monad transformers from <em>transformers</em> are actually valid functor combinators under our perspective here, because most of them are not <em>natural</em> on <code>f</code>: they require <code>Functor f</code>, at least, to implement <code>inject</code> or <code>hmap</code>.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">ReaderT</span> r) <span class="ot">=</span> <span class="dt">MonadReader</span> r</span>
<span id="cb71-2"><a href="#cb71-2"></a></span>
<span id="cb71-3"><a href="#cb71-3"></a>interpret <span class="op">@</span>(<span class="dt">ReaderT</span> r)</span>
<span id="cb71-4"><a href="#cb71-4"></a><span class="ot">    ::</span> <span class="dt">MonadReader</span> r g</span>
<span id="cb71-5"><a href="#cb71-5"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb71-6"><a href="#cb71-6"></a>    <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> r f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of a <code>ReaderT r</code> requires requires the target context to be <code>MonadReader r</code>, which means it must have access to <code>ask :: MonadReader r f =&gt; f r</code>.</p></li>
</ul>
<h3 id="step">Step</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-Step.html">Control.Applicative.Step</a></em></p></li>
<li><p><strong>Enhancement</strong>: Tuples the <code>f a</code> with an extra natural number index.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1"></a><span class="kw">data</span> <span class="dt">Step</span> f a <span class="ot">=</span> <span class="dt">Step</span> {<span class="ot"> stepPos ::</span> <span class="dt">Natural</span>,<span class="ot"> stepVal ::</span> f a }</span></code></pre></div>
<p>This is essentially a specialized <code>EnvT</code>: it’s <code>EnvT (Sum Natural)</code>.</p>
<p>This is a useful type because it can be seen as equivalent to <code>f :+: f :+: f :+: f :+: f ...</code> forever: it’s an <code>f</code>, but at some index. In <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-Step.html">Control.Applicative.Step</a></em>, we have specialized functions <code>stepUp</code> and <code>stepDown</code>, which allows you to “match” on the “first” <code>f</code> in that infinite chain; it will increment and decrement the index relatively to make this work properly.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Step</span> <span class="ot">=</span> <span class="dt">Unconstrained</span></span>
<span id="cb73-2"><a href="#cb73-2"></a></span>
<span id="cb73-3"><a href="#cb73-3"></a>interpret <span class="op">@</span><span class="dt">Step</span></span>
<span id="cb73-4"><a href="#cb73-4"></a><span class="ot">    ::</span> f <span class="op">~&gt;</span> g</span>
<span id="cb73-5"><a href="#cb73-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Step</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of <code>Step</code> requires no constraints; we just drop the <code>Natural</code> data.</p></li>
</ul>
<h3 id="steps">Steps</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-Step.html">Control.Applicative.Step</a></em></p></li>
<li><p><strong>Enhancement</strong>: The ability to offer multiple <em>indexed</em> options for the interpreter to pick from. Like <code>NonEmptyF</code>, except with each <code>f a</code> existing at an indexed position that the consumer/interpreter can look up or access.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1"></a><span class="kw">newtype</span> <span class="dt">Steps</span> f a <span class="ot">=</span> <span class="dt">Steps</span> {<span class="ot"> getSteps ::</span> <span class="dt">NEMap</span> <span class="dt">Natural</span> (f a) }</span></code></pre></div>
<p>This is like a mix between <code>NonEmptyF</code> and <code>Step</code>: multiple <code>f a</code> options (at least one) for the consumer/interpreter to pick from. Unlike <code>NonEmptyF</code>, each <code>f a</code> exists at an “index” — there might be one at 0, one at 5, one at 100, etc.</p>
<p>Another way of looking at this is like an infinite <em>sparse array</em> of <code>f a</code>s: it’s an inifinitely large collection where each spot may potentially have an <code>f a</code>.</p>
<p>Useful for “provide options that the consumer can pick from, index, or access”, like <code>ListF</code>/<code>NonEmptyF</code>.</p>
<p>This type can be seen as an infinite <code>f `These1` f `These1` f `These1` f ...</code>, and along these lines, <code>stepsDown</code> and <code>stepsUp</code> exist inside <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-Step.html">Control.Applicative.Step</a></em> analogous to <code>stepUp</code> and <code>stepDown</code> to treat a <code>Steps</code> in this manner.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Steps</span> <span class="ot">=</span> <span class="dt">Alt</span></span>
<span id="cb75-2"><a href="#cb75-2"></a></span>
<span id="cb75-3"><a href="#cb75-3"></a>interpret <span class="op">@</span><span class="dt">Steps</span></span>
<span id="cb75-4"><a href="#cb75-4"></a><span class="ot">    ::</span> <span class="dt">Alt</span> g</span>
<span id="cb75-5"><a href="#cb75-5"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb75-6"><a href="#cb75-6"></a>    <span class="ot">-&gt;</span> <span class="dt">Steps</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of <code>Steps</code> requires an <code>Alt</code> to combine different possibilities. It does not require a full <code>Plus</code> constraint because we never need <code>zero</code>: a <code>Steps f a</code> always has at least one <code>f a</code>.</p></li>
</ul>
<h3 id="flagged">Flagged</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-Step.html">Control.Applicative.Step</a></em></p></li>
<li><p><strong>Enhancement</strong>: The ability to “tag” a functor value with a <code>True</code>/<code>False</code> boolean value.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1"></a><span class="kw">data</span> <span class="dt">Flagged</span> f a <span class="ot">=</span> <span class="dt">Flagged</span> {<span class="ot"> flaggedFlag ::</span> <span class="dt">Bool</span>,<span class="ot"> flaggedVal ::</span> f a }</span></code></pre></div>
<p>This is essentially a specialized <code>EnvT</code>: it’s <code>EnvT Any</code>.</p>
<p>If created with <code>inject</code> or <code>pure</code>, it adds the flag <code>False</code>. This is helpful for helping indicate if the value was created using a “pure” method like <code>inject</code> or <code>pure</code>, or an “impure” method (any other method, including direct construction).</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">Flagged</span> <span class="ot">=</span> <span class="dt">Unconstrained</span></span>
<span id="cb77-2"><a href="#cb77-2"></a></span>
<span id="cb77-3"><a href="#cb77-3"></a>interpret <span class="op">@</span><span class="dt">Flagged</span></span>
<span id="cb77-4"><a href="#cb77-4"></a><span class="ot">    ::</span> f <span class="op">~&gt;</span> g</span>
<span id="cb77-5"><a href="#cb77-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Flagged</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of <code>Flagged</code> requires no constraints; we just drop the boolean flag.</p></li>
</ul>
<h3 id="final">Final</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Final.html">Data.HFunctor.Final</a></em></p></li>
<li><p><strong>Enhancement</strong>: <code>Final c</code> will lift <code>f</code> into a free structure of any typeclass <code>c</code>; it will give it all of the actions/API of a typeclass for “free”. <code>Final c f</code> is the “free <code>c</code>” over <code>f</code>.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1"></a><span class="kw">data</span> <span class="dt">Final</span> c f a</span></code></pre></div>
<p>In a way, this is the “ultimate free structure”: it can fully replace all other free structures of typeclasses of kind <code>Type -&gt; Type</code>. For example:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1"></a><span class="dt">Coyoneda</span>  <span class="op">~</span> <span class="dt">Final</span> <span class="dt">Functor</span></span>
<span id="cb79-2"><a href="#cb79-2"></a><span class="dt">ListF</span>     <span class="op">~</span> <span class="dt">Final</span> <span class="dt">Plus</span></span>
<span id="cb79-3"><a href="#cb79-3"></a><span class="dt">NonEmptyF</span> <span class="op">~</span> <span class="dt">Final</span> <span class="dt">Alt</span></span>
<span id="cb79-4"><a href="#cb79-4"></a><span class="dt">Ap</span>        <span class="op">~</span> <span class="dt">Final</span> <span class="dt">Applicative</span></span>
<span id="cb79-5"><a href="#cb79-5"></a><span class="dt">Ap1</span>       <span class="op">~</span> <span class="dt">Final</span> <span class="dt">Apply</span></span>
<span id="cb79-6"><a href="#cb79-6"></a><span class="dt">Free</span>      <span class="op">~</span> <span class="dt">Final</span> <span class="dt">Monad</span></span>
<span id="cb79-7"><a href="#cb79-7"></a><span class="dt">Free1</span>     <span class="op">~</span> <span class="dt">Final</span> <span class="dt">Bind</span></span>
<span id="cb79-8"><a href="#cb79-8"></a><span class="dt">Lift</span>      <span class="op">~</span> <span class="dt">Final</span> <span class="dt">Pointed</span></span>
<span id="cb79-9"><a href="#cb79-9"></a><span class="dt">IdentityT</span> <span class="op">~</span> <span class="dt">Final</span> <span class="dt">Unconstrained</span></span></code></pre></div>
<p>All of these are connections are witnessed by instances of the typeclass <code>FreeOf</code> in <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Final.html">Data.HFunctor.Final</a></em>.</p>
<p>In fact, <code>Final c</code> is often more performant than the actual concrete free structures.</p>
<p>The main downside is that you cannot directly pattern match on the structure of a <code>Final c</code> the same way you can pattern match on, say, <code>Ap</code> or <code>ListF</code>. However, you can get often around this by using <code>Final Plus</code> for most of your operations, and then <code>interpret inject</code>-ing it into <code>ListF</code> when you want to actually pattern match.</p>
<p>You can also think of this as the “ultimate <code>Interpret</code>”, because with <code>inject</code> you can push <code>f</code> into <code>Final c f</code>, and with <code>interpret</code> you only ever need the <code>c</code> constraint to “run”/interpret this.</p>
<p>So, next time you want to give an <code>f</code> the ability to <code>&lt;*&gt;</code> and <code>pure</code>, you can throw it into <code>Final Applicative</code>: <code>f</code> now gets “sequencing” abilities, and is equivalent to <code>Ap f</code>.</p>
<p>If you want the API of a given typeclass <code>c</code>, you can inject <code>f</code> into <code>Final c</code>, and you get the API of that typeclass for free on <code>f</code>.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">Final</span> c) <span class="ot">=</span> c</span>
<span id="cb80-2"><a href="#cb80-2"></a></span>
<span id="cb80-3"><a href="#cb80-3"></a>interpret <span class="op">@</span>(<span class="dt">Final</span> c)</span>
<span id="cb80-4"><a href="#cb80-4"></a><span class="ot">    ::</span> c g</span>
<span id="cb80-5"><a href="#cb80-5"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb80-6"><a href="#cb80-6"></a>    <span class="ot">-&gt;</span> <span class="dt">Final</span> c f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of a <code>Final c</code> requires <code>c</code>, since that is the extra context that <code>f</code> is lifted into.</p></li>
</ul>
<h3 id="chain-chain1">Chain / Chain1</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Chain.html">Data.HFunctor.Chain</a></em></p></li>
<li><p><strong>Enhancement</strong>: <code>Chain t</code> will lift <code>f</code> into a linked list of <code>f</code>s chained by <code>t</code>.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1"></a><span class="co">-- i is intended to be the identity of t</span></span>
<span id="cb81-2"><a href="#cb81-2"></a><span class="kw">data</span> <span class="dt">Chain</span> t i f a <span class="ot">=</span> <span class="dt">Done</span> (i a)</span>
<span id="cb81-3"><a href="#cb81-3"></a>                   <span class="op">|</span> <span class="dt">More</span> (t f (<span class="dt">Chain</span> t i f a))</span></code></pre></div>
<p>For example, for <code>:*:</code>, <code>Chain (:*:) Proxy f</code> is equivalent to one of:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1"></a><span class="dt">Proxy</span>   <span class="op">&lt;=&gt;</span> <span class="dt">Done</span> <span class="dt">Proxy</span>                           <span class="op">&lt;=&gt;</span> <span class="dt">ListF</span> []</span>
<span id="cb82-2"><a href="#cb82-2"></a>x       <span class="op">&lt;=&gt;</span> <span class="dt">More</span> (x <span class="op">:*:</span> <span class="dt">Done</span> <span class="dt">Proxy</span>)              <span class="op">&lt;=&gt;</span> <span class="dt">ListF</span> [x]</span>
<span id="cb82-3"><a href="#cb82-3"></a>x <span class="op">:*:</span> y <span class="op">&lt;=&gt;</span> <span class="dt">More</span> (x <span class="op">:*:</span> <span class="dt">More</span> (y <span class="op">:*:</span> <span class="dt">Done</span> <span class="dt">Proxy</span>)) <span class="op">&lt;=&gt;</span> <span class="dt">ListF</span> [x,y]</span>
<span id="cb82-4"><a href="#cb82-4"></a><span class="co">-- etc.</span></span></code></pre></div>
<p>For <code>:+:</code>, <code>Chain (:+:) Void1 f</code> is equivalent to one of:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1"></a><span class="dt">L1</span> x           <span class="op">&lt;=&gt;</span> <span class="dt">More</span> (<span class="dt">L1</span> x)                         <span class="op">&lt;=&gt;</span> <span class="dt">Step</span> <span class="dv">0</span> x</span>
<span id="cb83-2"><a href="#cb83-2"></a><span class="dt">R1</span> (<span class="dt">L1</span> y)      <span class="op">&lt;=&gt;</span> <span class="dt">More</span> (<span class="dt">R1</span> (<span class="dt">More</span> (<span class="dt">L1</span> y)))             <span class="op">&lt;=&gt;</span> <span class="dt">Step</span> <span class="dv">1</span> y</span>
<span id="cb83-3"><a href="#cb83-3"></a><span class="dt">R1</span> (<span class="dt">R1</span> (<span class="dt">L1</span> z)) <span class="op">&lt;=&gt;</span> <span class="dt">More</span> (<span class="dt">R1</span> (<span class="dt">More</span> (<span class="dt">R1</span> (<span class="dt">More</span> (<span class="dt">L1</span> z))))) <span class="op">&lt;=&gt;</span> <span class="dt">Step</span> <span class="dv">2</span> z</span>
<span id="cb83-4"><a href="#cb83-4"></a><span class="co">-- etc.</span></span></code></pre></div>
<p>This is useful because it provides a nice uniform way to work with all “induced Monoidal functors”. That’s because the following types are all isomorphic:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1"></a><span class="dt">ListF</span> <span class="op">~</span> <span class="dt">Chain</span> (<span class="op">:*:</span>)  <span class="dt">Proxy</span></span>
<span id="cb84-2"><a href="#cb84-2"></a><span class="dt">Ap</span>    <span class="op">~</span> <span class="dt">Chain</span> <span class="dt">Day</span>    <span class="dt">Identity</span></span>
<span id="cb84-3"><a href="#cb84-3"></a><span class="dt">Free</span>  <span class="op">~</span> <span class="dt">Chain</span> <span class="dt">Comp</span>   <span class="dt">Identity</span></span>
<span id="cb84-4"><a href="#cb84-4"></a><span class="dt">Step</span>  <span class="op">~</span> <span class="dt">Chain</span> (<span class="op">:+:</span>)  <span class="dt">Void</span></span>
<span id="cb84-5"><a href="#cb84-5"></a><span class="dt">Steps</span> <span class="op">~</span> <span class="dt">Chain</span> <span class="dt">These1</span> <span class="dt">Void</span></span></code></pre></div>
<p>This isomorphism is witnessed by <code>unrollMF</code> (turn into the <code>Chain</code>) and <code>rerollMF</code> (convert back from the <code>Chain</code>) in <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Chain.html">Data.HFunctor.Chain</a></em>.</p>
<p>We also have a “non-empty” version, <code>Chain1</code>, for induced semigroupoids:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1"></a><span class="kw">data</span> <span class="dt">Chain1</span> t f a <span class="ot">=</span> <span class="dt">Done1</span> (f a)</span>
<span id="cb85-2"><a href="#cb85-2"></a>                  <span class="op">|</span> <span class="dt">More1</span> (t f (<span class="dt">Chain1</span> t f a))</span></code></pre></div>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1"></a><span class="dt">NonEmptyF</span> <span class="op">~</span> <span class="dt">Chain1</span> (<span class="op">:*:</span>)</span>
<span id="cb86-2"><a href="#cb86-2"></a><span class="dt">Ap1</span>       <span class="op">~</span> <span class="dt">Chain1</span> <span class="dt">Day</span></span>
<span id="cb86-3"><a href="#cb86-3"></a><span class="dt">Free1</span>     <span class="op">~</span> <span class="dt">Chain1</span> <span class="dt">Comp</span></span>
<span id="cb86-4"><a href="#cb86-4"></a><span class="dt">Step</span>      <span class="op">~</span> <span class="dt">Chain1</span> (<span class="op">:+:</span>)</span>
<span id="cb86-5"><a href="#cb86-5"></a><span class="dt">Steps</span>     <span class="op">~</span> <span class="dt">Chain1</span> <span class="dt">These1</span></span>
<span id="cb86-6"><a href="#cb86-6"></a><span class="dt">EnvT</span> <span class="dt">Any</span>  <span class="op">~</span> <span class="dt">Chain1</span> <span class="dt">LeftF</span></span>
<span id="cb86-7"><a href="#cb86-7"></a><span class="dt">Step</span>      <span class="op">~</span> <span class="dt">Chain1</span> <span class="dt">RightF</span></span></code></pre></div>
<p>Using <code>ListF</code>, <code>Ap</code>, <code>Free</code>, <code>Step</code>, <code>Steps</code>, etc. can sometimes feel very different, but with <code>Chain</code> you get a uniform interface to pattern match on (and construct) all of them in the same way.</p>
<p>Using <code>NonEmptyF</code>, <code>Ap1</code>, <code>Free1</code>, <code>Step</code>, <code>Steps</code>, <code>EnvT</code>, etc. can sometimes feel very different, but with <code>Chain1</code> you get a uniform interface to pattern match on (and construct) all of them in the same way.</p>
<p>The construction of <code>Chain</code> is inspired by <a href="http://oleg.fi/gists/posts/2018-02-21-single-free.html">Oleg Grenrus’s blog post</a>, and the construction of <code>Chain1</code> is inspired by implementations of finite automata and iteratees.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">Chain</span>  t (<span class="dt">I</span> t)) <span class="ot">=</span> <span class="dt">CM</span> t</span>
<span id="cb87-2"><a href="#cb87-2"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">Chain1</span> t      ) <span class="ot">=</span> <span class="dt">CS</span> t</span>
<span id="cb87-3"><a href="#cb87-3"></a></span>
<span id="cb87-4"><a href="#cb87-4"></a>interpret <span class="op">@</span>(<span class="dt">Chain</span> t (<span class="dt">I</span> t))</span>
<span id="cb87-5"><a href="#cb87-5"></a><span class="ot">    ::</span> <span class="dt">CM</span> t g</span>
<span id="cb87-6"><a href="#cb87-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb87-7"><a href="#cb87-7"></a>    <span class="ot">-&gt;</span> <span class="dt">Chain</span> t (<span class="dt">I</span> t) f <span class="op">~&gt;</span> g</span>
<span id="cb87-8"><a href="#cb87-8"></a></span>
<span id="cb87-9"><a href="#cb87-9"></a>interpret <span class="op">@</span>(<span class="dt">Chain1</span> t)</span>
<span id="cb87-10"><a href="#cb87-10"></a><span class="ot">    ::</span> <span class="dt">CS</span> t g</span>
<span id="cb87-11"><a href="#cb87-11"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb87-12"><a href="#cb87-12"></a>    <span class="ot">-&gt;</span> <span class="dt">Chain1</span> t f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of a <code>Chain</code> requires the monoidal constraint on <code>t</code>, since we have to “squish” all of the layers of <code>t</code> together with a potential empty case. Interpreting out of a <code>Chain1</code> requires the semigroupoidal constraint on <code>t</code>, since we have to squish all of the layers of <code>t</code> together, but we don’t have to worry about the empty case.</p>
<p>For example, we have:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">Chain</span>  (<span class="op">:*:</span>) <span class="dt">Proxy</span>) <span class="ot">=</span> <span class="dt">Plus</span></span>
<span id="cb88-2"><a href="#cb88-2"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">Chain1</span> (<span class="op">:*:</span>)      ) <span class="ot">=</span> <span class="dt">Alt</span></span>
<span id="cb88-3"><a href="#cb88-3"></a></span>
<span id="cb88-4"><a href="#cb88-4"></a>interpret <span class="op">@</span>(<span class="dt">Chain</span> (<span class="op">:*:</span>) <span class="dt">Proxy</span>)</span>
<span id="cb88-5"><a href="#cb88-5"></a><span class="ot">    ::</span> <span class="dt">Plus</span> g</span>
<span id="cb88-6"><a href="#cb88-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb88-7"><a href="#cb88-7"></a>    <span class="ot">-&gt;</span> <span class="dt">Chain</span> (<span class="op">:*:</span>) <span class="dt">Proxy</span> f <span class="op">~&gt;</span> g</span>
<span id="cb88-8"><a href="#cb88-8"></a></span>
<span id="cb88-9"><a href="#cb88-9"></a>interpret <span class="op">@</span>(<span class="dt">Chain1</span> (<span class="op">:*:</span>))</span>
<span id="cb88-10"><a href="#cb88-10"></a><span class="ot">    ::</span> <span class="dt">Alt</span> g</span>
<span id="cb88-11"><a href="#cb88-11"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb88-12"><a href="#cb88-12"></a>    <span class="ot">-&gt;</span> <span class="dt">Chain1</span> (<span class="op">:*:</span>) f <span class="op">~&gt;</span> g</span>
<span id="cb88-13"><a href="#cb88-13"></a></span>
<span id="cb88-14"><a href="#cb88-14"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">Chain</span>  <span class="dt">Day</span> <span class="dt">Identity</span>) <span class="ot">=</span> <span class="dt">Applicative</span></span>
<span id="cb88-15"><a href="#cb88-15"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">Chain1</span> <span class="dt">Day</span>         ) <span class="ot">=</span> <span class="dt">Apply</span></span>
<span id="cb88-16"><a href="#cb88-16"></a></span>
<span id="cb88-17"><a href="#cb88-17"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">Chain</span>  <span class="dt">Comp</span> <span class="dt">Identity</span>) <span class="ot">=</span> <span class="dt">Monad</span></span>
<span id="cb88-18"><a href="#cb88-18"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">Chain1</span> <span class="dt">Comp</span>         ) <span class="ot">=</span> <span class="dt">Bind</span></span></code></pre></div></li>
</ul>
<h3 id="identityt">IdentityT</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/base/docs/Data-Functor-Identity.html">Data.Functor.Identity</a></em></p></li>
<li><p><strong>Enhancement</strong>: None whatsoever; it adds no extra structure to <code>f</code>, and <code>IdentityT f</code> is the same as <code>f</code>; it’s the “free <code>Unconstrained</code>”</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1"></a><span class="kw">data</span> <span class="dt">IdentityT</span> f a <span class="ot">=</span> <span class="dt">IdentityT</span> {<span class="ot"> runIdentityT ::</span> f a }</span></code></pre></div>
<p>This isn’t too useful on its own, but it can be useful to give to the functor combinator combinators as a no-op functor combinator. It can also be used to signify “no structure”, or as a placeholder until you figure out what sort of structure you want to have.</p>
<p>In that sense, it can be thought of as a “<code>ListF</code> with always one item”, a “<code>MaybeF</code> that’s always <code>Just</code>”’, an “<code>Ap</code> with always one sequenced item”, a “<code>Free</code> with always exactly one layer of effects”, etc.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">IdentityT</span> <span class="ot">=</span> <span class="dt">Unconstrained</span></span>
<span id="cb90-2"><a href="#cb90-2"></a></span>
<span id="cb90-3"><a href="#cb90-3"></a>interpret <span class="op">@</span><span class="dt">IdentityT</span></span>
<span id="cb90-4"><a href="#cb90-4"></a><span class="ot">    ::</span> f <span class="op">~&gt;</span> g</span>
<span id="cb90-5"><a href="#cb90-5"></a>    <span class="ot">-&gt;</span> <span class="dt">IdentityT</span> f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of <code>IdentityT</code> requires no constraints — it basically does nothing.</p></li>
</ul>
<h3 id="proxyf-constf">ProxyF / ConstF</h3>
<ul>
<li><p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/base/docs/Data-HFunctor.html">Data.HFunctor</a></em></p></li>
<li><p><strong>Enhancement</strong>: “Black holes” — they completely forget all the structure of <code>f</code>, and are impossible to <code>interpret</code> out of. <code>Impossible</code>".</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1"></a><span class="kw">data</span> <span class="dt">ProxyF</span> f a <span class="ot">=</span> <span class="dt">ProxyF</span></span>
<span id="cb91-2"><a href="#cb91-2"></a><span class="kw">data</span> <span class="dt">ConstF</span> e f a <span class="ot">=</span> <span class="dt">ConstF</span> e</span></code></pre></div>
<p><code>ProxyF</code> is essentially <code>ConstF ()</code>.</p>
<p>These are both valid functor combinators in that you can inject into them, and <code>interpret id . inject == id</code> is <em>technically</em> true (the best kind of true).</p>
<p>You can use them if you want your schema to be impossible to interpret, as a placeholder or to signify that one branch is uninterpretable. In this sense, this is like a “<code>ListF</code> that is always empty” or a “<code>MaybeF</code> that is always <code>Nothing</code>”.</p>
<p>Because of this, they aren’t too useful on their own — they’re more useful in the context of swapping out and combining or manipulating with other functor combinators or using with functor combinator combinators.</p></li>
<li><p><strong>Constraint</strong></p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="dt">ProxyF</span>     <span class="ot">=</span> <span class="dt">Impossible</span></span>
<span id="cb92-2"><a href="#cb92-2"></a><span class="kw">type</span> <span class="dt">C</span> (<span class="dt">ConstF</span> e) <span class="ot">=</span> <span class="dt">Impossible</span></span>
<span id="cb92-3"><a href="#cb92-3"></a></span>
<span id="cb92-4"><a href="#cb92-4"></a>interpret <span class="op">@</span><span class="dt">ProxyF</span></span>
<span id="cb92-5"><a href="#cb92-5"></a><span class="ot">    ::</span> <span class="dt">Impossible</span> g</span>
<span id="cb92-6"><a href="#cb92-6"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb92-7"><a href="#cb92-7"></a>    <span class="ot">-&gt;</span> <span class="dt">ProxyF</span> f <span class="op">~&gt;</span> g</span>
<span id="cb92-8"><a href="#cb92-8"></a></span>
<span id="cb92-9"><a href="#cb92-9"></a>interpret <span class="op">@</span>(<span class="dt">ConstF</span> e)</span>
<span id="cb92-10"><a href="#cb92-10"></a><span class="ot">    ::</span> <span class="dt">Impossible</span> g</span>
<span id="cb92-11"><a href="#cb92-11"></a>    <span class="ot">=&gt;</span> f <span class="op">~&gt;</span> g</span>
<span id="cb92-12"><a href="#cb92-12"></a>    <span class="ot">-&gt;</span> <span class="dt">ConstF</span> e f <span class="op">~&gt;</span> g</span></code></pre></div>
<p>Interpreting out of these requires an impossible constraint.</p></li>
</ul></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/functor-combinatorpedia.html';
    this.page.identifier = 'functor-combinatorpedia';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>